<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>4 Details of specific functions | dispRity manual</title>
  <meta name="description" content="dispRity R package vignette" />
  <meta name="generator" content="bookdown 0.18 and GitBook 2.6.7" />

  <meta property="og:title" content="4 Details of specific functions | dispRity manual" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="dispRity R package vignette" />
  <meta name="github-repo" content="TGuillerme/dispRity" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="4 Details of specific functions | dispRity manual" />
  
  <meta name="twitter:description" content="dispRity R package vignette" />
  

<meta name="author" content="Thomas Guillerme (guillert@tcd.ie), Mark Puttick (marknputtick@gmail.com) and Natalie Cooper (natalie.cooper@nhm.ac.uk)" />


<meta name="date" content="2021-04-15" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="getting-started-with-disprity.html"/>
<link rel="next" href="making-stuff-up.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />











<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">dispRity manual</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> <code>dispRity</code></a><ul>
<li class="chapter" data-level="1.1" data-path="index.html"><a href="index.html#what-is-disprity"><i class="fa fa-check"></i><b>1.1</b> What is <code>dispRity</code>?</a><ul>
<li class="chapter" data-level="1.1.1" data-path="index.html"><a href="index.html#modular"><i class="fa fa-check"></i><b>1.1.1</b> Modular?</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="index.html"><a href="index.html#installing-and-running-the-package"><i class="fa fa-check"></i><b>1.2</b> Installing and running the package</a></li>
<li class="chapter" data-level="1.3" data-path="index.html"><a href="index.html#version"><i class="fa fa-check"></i><b>1.3</b> Which version do I choose?</a></li>
<li class="chapter" data-level="1.4" data-path="index.html"><a href="index.html#disprity-is-always-changing-how-do-i-know-its-not-broken"><i class="fa fa-check"></i><b>1.4</b> <code>dispRity</code> is always changing, how do I know it’s not broken?</a></li>
<li class="chapter" data-level="1.5" data-path="index.html"><a href="index.html#help"><i class="fa fa-check"></i><b>1.5</b> Help</a></li>
<li class="chapter" data-level="1.6" data-path="index.html"><a href="index.html#citations"><i class="fa fa-check"></i><b>1.6</b> Citations</a><ul>
<li class="chapter" data-level="1.6.1" data-path="index.html"><a href="index.html#why-is-it-important-to-cite-us"><i class="fa fa-check"></i><b>1.6.1</b> Why is it important to cite us?</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="glossary.html"><a href="glossary.html"><i class="fa fa-check"></i><b>2</b> Glossary</a><ul>
<li class="chapter" data-level="2.1" data-path="glossary.html"><a href="glossary.html#glossary-equivalences-in-palaeobiology-and-ecology"><i class="fa fa-check"></i><b>2.1</b> Glossary equivalences in palaeobiology and ecology</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="getting-started-with-disprity.html"><a href="getting-started-with-disprity.html"><i class="fa fa-check"></i><b>3</b> Getting started with <code>dispRity</code></a><ul>
<li class="chapter" data-level="3.1" data-path="getting-started-with-disprity.html"><a href="getting-started-with-disprity.html#what-sort-of-data-does-disprity-work-with"><i class="fa fa-check"></i><b>3.1</b> What sort of data does <code>dispRity</code> work with?</a></li>
<li class="chapter" data-level="3.2" data-path="getting-started-with-disprity.html"><a href="getting-started-with-disprity.html#ordinated-matrices"><i class="fa fa-check"></i><b>3.2</b> Ordinated matrices</a><ul>
<li class="chapter" data-level="3.2.1" data-path="getting-started-with-disprity.html"><a href="getting-started-with-disprity.html#ordination-matrices-from-geomorph"><i class="fa fa-check"></i><b>3.2.1</b> Ordination matrices from <code>geomorph</code></a></li>
<li class="chapter" data-level="3.2.2" data-path="getting-started-with-disprity.html"><a href="getting-started-with-disprity.html#Claddis-ordination"><i class="fa fa-check"></i><b>3.2.2</b> Ordination matrices from <code>Claddis</code></a></li>
<li class="chapter" data-level="3.2.3" data-path="getting-started-with-disprity.html"><a href="getting-started-with-disprity.html#other-kinds-of-ordination-matrices"><i class="fa fa-check"></i><b>3.2.3</b> Other kinds of ordination matrices</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="getting-started-with-disprity.html"><a href="getting-started-with-disprity.html#simpleanalysis"><i class="fa fa-check"></i><b>3.3</b> Performing a simple dispRity analysis</a><ul>
<li class="chapter" data-level="3.3.1" data-path="getting-started-with-disprity.html"><a href="getting-started-with-disprity.html#example-data"><i class="fa fa-check"></i><b>3.3.1</b> Example data</a></li>
<li class="chapter" data-level="3.3.2" data-path="getting-started-with-disprity.html"><a href="getting-started-with-disprity.html#disparity-through-time"><i class="fa fa-check"></i><b>3.3.2</b> Disparity through time</a></li>
<li class="chapter" data-level="3.3.3" data-path="getting-started-with-disprity.html"><a href="getting-started-with-disprity.html#disparity-among-groups"><i class="fa fa-check"></i><b>3.3.3</b> Disparity among groups</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html"><i class="fa fa-check"></i><b>4</b> Details of specific functions</a><ul>
<li class="chapter" data-level="4.1" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#chrono-subsets"><i class="fa fa-check"></i><b>4.1</b> Time slicing</a><ul>
<li class="chapter" data-level="4.1.1" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#time-binning"><i class="fa fa-check"></i><b>4.1.1</b> Time-binning</a></li>
<li class="chapter" data-level="4.1.2" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#time-slicing"><i class="fa fa-check"></i><b>4.1.2</b> Time-slicing</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#custom-subsets"><i class="fa fa-check"></i><b>4.2</b> Customised subsets</a></li>
<li class="chapter" data-level="4.3" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#bootstraps-and-rarefactions"><i class="fa fa-check"></i><b>4.3</b> Bootstraps and rarefactions</a></li>
<li class="chapter" data-level="4.4" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#disparity-metrics"><i class="fa fa-check"></i><b>4.4</b> Disparity metrics</a><ul>
<li class="chapter" data-level="4.4.1" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#the-function-dimension-levels"><i class="fa fa-check"></i><b>4.4.1</b> The function dimension-levels</a></li>
<li class="chapter" data-level="4.4.2" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#betweengroupmetricsexplain"><i class="fa fa-check"></i><b>4.4.2</b> Between groups metrics</a></li>
<li class="chapter" data-level="4.4.3" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#makemetric"><i class="fa fa-check"></i><b>4.4.3</b> <code>make.metric</code></a></li>
<li class="chapter" data-level="4.4.4" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#metrics-in-the-disprity-function"><i class="fa fa-check"></i><b>4.4.4</b> Metrics in the <code>dispRity</code> function</a></li>
<li class="chapter" data-level="4.4.5" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#metrics-implemented-in-disprity"><i class="fa fa-check"></i><b>4.4.5</b> Metrics implemented in <code>dispRity</code></a></li>
<li class="chapter" data-level="4.4.6" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#equations-and-implementations"><i class="fa fa-check"></i><b>4.4.6</b> Equations and implementations</a></li>
<li class="chapter" data-level="4.4.7" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#using-the-different-disparity-metrics"><i class="fa fa-check"></i><b>4.4.7</b> Using the different disparity metrics</a></li>
<li class="chapter" data-level="4.4.8" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#which-disparity-metric-to-choose"><i class="fa fa-check"></i><b>4.4.8</b> Which disparity metric to choose?</a></li>
</ul></li>
<li class="chapter" data-level="4.5" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#summarising-disprity-data-plots"><i class="fa fa-check"></i><b>4.5</b> Summarising dispRity data (plots)</a><ul>
<li class="chapter" data-level="4.5.1" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#summarising-disprity-data"><i class="fa fa-check"></i><b>4.5.1</b> Summarising <code>dispRity</code> data</a></li>
<li class="chapter" data-level="4.5.2" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#plotting-disprity-data"><i class="fa fa-check"></i><b>4.5.2</b> Plotting <code>dispRity</code> data</a></li>
<li class="chapter" data-level="4.5.3" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#type-preview"><i class="fa fa-check"></i><b>4.5.3</b> <code>type = preview</code></a></li>
</ul></li>
<li class="chapter" data-level="4.6" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#testing-disparity-hypotheses"><i class="fa fa-check"></i><b>4.6</b> Testing disparity hypotheses</a><ul>
<li class="chapter" data-level="4.6.1" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#adonis"><i class="fa fa-check"></i><b>4.6.1</b> NPMANOVA in <code>dispRity</code></a></li>
<li class="chapter" data-level="4.6.2" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#dtt"><i class="fa fa-check"></i><b>4.6.2</b> <code>geiger::dtt</code> model fitting in <code>dispRity</code></a></li>
<li class="chapter" data-level="4.6.3" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#null-test"><i class="fa fa-check"></i><b>4.6.3</b> null morphospace testing with <code>null.test</code></a></li>
</ul></li>
<li class="chapter" data-level="4.7" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#model-fitting"><i class="fa fa-check"></i><b>4.7</b> Fitting modes of evolution to disparity data</a><ul>
<li class="chapter" data-level="4.7.1" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#simple-modes-of-disparity-change-through-time"><i class="fa fa-check"></i><b>4.7.1</b> Simple modes of disparity change through time</a></li>
<li class="chapter" data-level="4.7.2" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#plot-and-run-simulation-tests-in-a-single-step"><i class="fa fa-check"></i><b>4.7.2</b> Plot and run simulation tests in a single step</a></li>
<li class="chapter" data-level="4.7.3" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#multiple-modes-of-evolution-time-shifts"><i class="fa fa-check"></i><b>4.7.3</b> Multiple modes of evolution (time shifts)</a></li>
<li class="chapter" data-level="4.7.4" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#model.test.sim"><i class="fa fa-check"></i><b>4.7.4</b> <code>model.test.sim</code></a></li>
</ul></li>
<li class="chapter" data-level="4.8" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#disparity-distribution"><i class="fa fa-check"></i><b>4.8</b> Disparity as a distribution</a></li>
<li class="chapter" data-level="4.9" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#other-matrices"><i class="fa fa-check"></i><b>4.9</b> Disparity from other matrices</a></li>
<li class="chapter" data-level="4.10" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#multi.input"><i class="fa fa-check"></i><b>4.10</b> Disparity from multiple matrices (and multiple trees!)</a></li>
<li class="chapter" data-level="4.11" data-path="details-of-specific-functions.html"><a href="details-of-specific-functions.html#disparity-with-trees-dispritree"><i class="fa fa-check"></i><b>4.11</b> Disparity with trees: <em>dispRitree!</em></a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="making-stuff-up.html"><a href="making-stuff-up.html"><i class="fa fa-check"></i><b>5</b> Making stuff up!</a><ul>
<li class="chapter" data-level="5.1" data-path="making-stuff-up.html"><a href="making-stuff-up.html#simulating-discrete-morphological-data"><i class="fa fa-check"></i><b>5.1</b> Simulating discrete morphological data</a><ul>
<li class="chapter" data-level="5.1.1" data-path="making-stuff-up.html"><a href="making-stuff-up.html#a-more-detailed-description"><i class="fa fa-check"></i><b>5.1.1</b> A more detailed description</a></li>
<li class="chapter" data-level="5.1.2" data-path="making-stuff-up.html"><a href="making-stuff-up.html#parameters-for-a-realisticish-matrix"><i class="fa fa-check"></i><b>5.1.2</b> Parameters for a realistic(ish) matrix</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="making-stuff-up.html"><a href="making-stuff-up.html#simulating-multidimensional-spaces"><i class="fa fa-check"></i><b>5.2</b> Simulating multidimensional spaces</a><ul>
<li class="chapter" data-level="5.2.1" data-path="making-stuff-up.html"><a href="making-stuff-up.html#personalised-dimensions-distributions"><i class="fa fa-check"></i><b>5.2.1</b> Personalised dimensions distributions</a></li>
<li class="chapter" data-level="5.2.2" data-path="making-stuff-up.html"><a href="making-stuff-up.html#visualising-the-space"><i class="fa fa-check"></i><b>5.2.2</b> Visualising the space</a></li>
<li class="chapter" data-level="5.2.3" data-path="making-stuff-up.html"><a href="making-stuff-up.html#generating-realistic-spaces"><i class="fa fa-check"></i><b>5.2.3</b> Generating realistic spaces</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="6" data-path="other-functionalities.html"><a href="other-functionalities.html"><i class="fa fa-check"></i><b>6</b> Other functionalities</a><ul>
<li class="chapter" data-level="6.1" data-path="other-functionalities.html"><a href="other-functionalities.html#char.diff"><i class="fa fa-check"></i><b>6.1</b> <code>char.diff</code></a></li>
<li class="chapter" data-level="6.2" data-path="other-functionalities.html"><a href="other-functionalities.html#clean.data"><i class="fa fa-check"></i><b>6.2</b> <code>clean.data</code></a></li>
<li class="chapter" data-level="6.3" data-path="other-functionalities.html"><a href="other-functionalities.html#crown.stem"><i class="fa fa-check"></i><b>6.3</b> <code>crown.stem</code></a></li>
<li class="chapter" data-level="6.4" data-path="other-functionalities.html"><a href="other-functionalities.html#get.bin.ages"><i class="fa fa-check"></i><b>6.4</b> <code>get.bin.ages</code></a></li>
<li class="chapter" data-level="6.5" data-path="other-functionalities.html"><a href="other-functionalities.html#pair.plot"><i class="fa fa-check"></i><b>6.5</b> <code>pair.plot</code></a></li>
<li class="chapter" data-level="6.6" data-path="other-functionalities.html"><a href="other-functionalities.html#reduce.matrix"><i class="fa fa-check"></i><b>6.6</b> <code>reduce.matrix</code></a></li>
<li class="chapter" data-level="6.7" data-path="other-functionalities.html"><a href="other-functionalities.html#slice.tree"><i class="fa fa-check"></i><b>6.7</b> <code>slice.tree</code></a></li>
<li class="chapter" data-level="6.8" data-path="other-functionalities.html"><a href="other-functionalities.html#slide.nodes-and-remove.zero.brlen"><i class="fa fa-check"></i><b>6.8</b> <code>slide.nodes</code> and <code>remove.zero.brlen</code></a></li>
<li class="chapter" data-level="6.9" data-path="other-functionalities.html"><a href="other-functionalities.html#tree.age"><i class="fa fa-check"></i><b>6.9</b> <code>tree.age</code></a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="the-guts-of-the-disprity-package.html"><a href="the-guts-of-the-disprity-package.html"><i class="fa fa-check"></i><b>7</b> The guts of the <code>dispRity</code> package</a><ul>
<li class="chapter" data-level="7.1" data-path="the-guts-of-the-disprity-package.html"><a href="the-guts-of-the-disprity-package.html#manipulating-disprity-objects"><i class="fa fa-check"></i><b>7.1</b> Manipulating <code>dispRity</code> objects</a></li>
<li class="chapter" data-level="7.2" data-path="the-guts-of-the-disprity-package.html"><a href="the-guts-of-the-disprity-package.html#utilities"><i class="fa fa-check"></i><b>7.2</b> <code>dispRity</code> utilities</a><ul>
<li class="chapter" data-level="7.2.1" data-path="the-guts-of-the-disprity-package.html"><a href="the-guts-of-the-disprity-package.html#disprity-object-utilities"><i class="fa fa-check"></i><b>7.2.1</b> <code>dispRity</code> object utilities <a name="dispRity.utilities"></a></a></li>
</ul></li>
<li class="chapter" data-level="7.3" data-path="the-guts-of-the-disprity-package.html"><a href="the-guts-of-the-disprity-package.html#disprity-object"><i class="fa fa-check"></i><b>7.3</b> The <code>dispRity</code> object content</a><ul>
<li class="chapter" data-level="7.3.1" data-path="the-guts-of-the-disprity-package.html"><a href="the-guts-of-the-disprity-package.html#matrix"><i class="fa fa-check"></i><b>7.3.1</b> <code>$matrix</code></a></li>
<li class="chapter" data-level="7.3.2" data-path="the-guts-of-the-disprity-package.html"><a href="the-guts-of-the-disprity-package.html#call"><i class="fa fa-check"></i><b>7.3.2</b> <code>$call</code></a></li>
<li class="chapter" data-level="7.3.3" data-path="the-guts-of-the-disprity-package.html"><a href="the-guts-of-the-disprity-package.html#subsets"><i class="fa fa-check"></i><b>7.3.3</b> <code>$subsets</code></a></li>
<li class="chapter" data-level="7.3.4" data-path="the-guts-of-the-disprity-package.html"><a href="the-guts-of-the-disprity-package.html#disparity"><i class="fa fa-check"></i><b>7.3.4</b> <code>$disparity</code></a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="8" data-path="ecology-demo.html"><a href="ecology-demo.html"><i class="fa fa-check"></i><b>8</b> Ecology demo</a><ul>
<li class="chapter" data-level="8.1" data-path="ecology-demo.html"><a href="ecology-demo.html#data"><i class="fa fa-check"></i><b>8.1</b> Data</a></li>
<li class="chapter" data-level="8.2" data-path="ecology-demo.html"><a href="ecology-demo.html#classic-analysis"><i class="fa fa-check"></i><b>8.2</b> Classic analysis</a></li>
<li class="chapter" data-level="8.3" data-path="ecology-demo.html"><a href="ecology-demo.html#a-multidimensional-approach-with-disprity"><i class="fa fa-check"></i><b>8.3</b> A multidimensional approach with <code>dispRity</code></a><ul>
<li class="chapter" data-level="8.3.1" data-path="ecology-demo.html"><a href="ecology-demo.html#bootstrapping-the-data"><i class="fa fa-check"></i><b>8.3.1</b> Bootstrapping the data</a></li>
<li class="chapter" data-level="8.3.2" data-path="ecology-demo.html"><a href="ecology-demo.html#calculating-disparity"><i class="fa fa-check"></i><b>8.3.2</b> Calculating disparity</a></li>
<li class="chapter" data-level="8.3.3" data-path="ecology-demo.html"><a href="ecology-demo.html#summarising-the-results-plot"><i class="fa fa-check"></i><b>8.3.3</b> Summarising the results (plot)</a></li>
<li class="chapter" data-level="8.3.4" data-path="ecology-demo.html"><a href="ecology-demo.html#testing-hypothesis"><i class="fa fa-check"></i><b>8.3.4</b> Testing hypothesis</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="9" data-path="palaeobiology-demo-disparity-through-time-and-within-groups.html"><a href="palaeobiology-demo-disparity-through-time-and-within-groups.html"><i class="fa fa-check"></i><b>9</b> Palaeobiology demo: disparity-through-time and within groups</a><ul>
<li class="chapter" data-level="9.1" data-path="palaeobiology-demo-disparity-through-time-and-within-groups.html"><a href="palaeobiology-demo-disparity-through-time-and-within-groups.html#before-starting"><i class="fa fa-check"></i><b>9.1</b> Before starting</a><ul>
<li class="chapter" data-level="9.1.1" data-path="palaeobiology-demo-disparity-through-time-and-within-groups.html"><a href="palaeobiology-demo-disparity-through-time-and-within-groups.html#the-morphospace"><i class="fa fa-check"></i><b>9.1.1</b> The morphospace</a></li>
<li class="chapter" data-level="9.1.2" data-path="palaeobiology-demo-disparity-through-time-and-within-groups.html"><a href="palaeobiology-demo-disparity-through-time-and-within-groups.html#setting-up-your-own-data"><i class="fa fa-check"></i><b>9.1.2</b> Setting up your own data</a></li>
</ul></li>
<li class="chapter" data-level="9.2" data-path="palaeobiology-demo-disparity-through-time-and-within-groups.html"><a href="palaeobiology-demo-disparity-through-time-and-within-groups.html#a-disparity-through-time-analysis"><i class="fa fa-check"></i><b>9.2</b> A disparity-through-time analysis</a><ul>
<li class="chapter" data-level="9.2.1" data-path="palaeobiology-demo-disparity-through-time-and-within-groups.html"><a href="palaeobiology-demo-disparity-through-time-and-within-groups.html#splitting-the-morphospace-through-time"><i class="fa fa-check"></i><b>9.2.1</b> Splitting the morphospace through time</a></li>
<li class="chapter" data-level="9.2.2" data-path="palaeobiology-demo-disparity-through-time-and-within-groups.html"><a href="palaeobiology-demo-disparity-through-time-and-within-groups.html#bootstrapping-the-data-1"><i class="fa fa-check"></i><b>9.2.2</b> Bootstrapping the data</a></li>
<li class="chapter" data-level="9.2.3" data-path="palaeobiology-demo-disparity-through-time-and-within-groups.html"><a href="palaeobiology-demo-disparity-through-time-and-within-groups.html#calculating-disparity-1"><i class="fa fa-check"></i><b>9.2.3</b> Calculating disparity</a></li>
<li class="chapter" data-level="9.2.4" data-path="palaeobiology-demo-disparity-through-time-and-within-groups.html"><a href="palaeobiology-demo-disparity-through-time-and-within-groups.html#plotting-the-results"><i class="fa fa-check"></i><b>9.2.4</b> Plotting the results</a></li>
<li class="chapter" data-level="9.2.5" data-path="palaeobiology-demo-disparity-through-time-and-within-groups.html"><a href="palaeobiology-demo-disparity-through-time-and-within-groups.html#testing-differences"><i class="fa fa-check"></i><b>9.2.5</b> Testing differences</a></li>
</ul></li>
<li class="chapter" data-level="9.3" data-path="palaeobiology-demo-disparity-through-time-and-within-groups.html"><a href="palaeobiology-demo-disparity-through-time-and-within-groups.html#some-more-advanced-stuff"><i class="fa fa-check"></i><b>9.3</b> Some more advanced stuff</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="morphometric-geometric-demo-a-between-group-analysis.html"><a href="morphometric-geometric-demo-a-between-group-analysis.html"><i class="fa fa-check"></i><b>10</b> Morphometric geometric demo: a between group analysis</a><ul>
<li class="chapter" data-level="10.1" data-path="morphometric-geometric-demo-a-between-group-analysis.html"><a href="morphometric-geometric-demo-a-between-group-analysis.html#before-starting-1"><i class="fa fa-check"></i><b>10.1</b> Before starting</a><ul>
<li class="chapter" data-level="10.1.1" data-path="morphometric-geometric-demo-a-between-group-analysis.html"><a href="morphometric-geometric-demo-a-between-group-analysis.html#the-morphospace-1"><i class="fa fa-check"></i><b>10.1.1</b> The morphospace</a></li>
</ul></li>
<li class="chapter" data-level="10.2" data-path="morphometric-geometric-demo-a-between-group-analysis.html"><a href="morphometric-geometric-demo-a-between-group-analysis.html#calculating-disparity-2"><i class="fa fa-check"></i><b>10.2</b> Calculating disparity</a></li>
<li class="chapter" data-level="10.3" data-path="morphometric-geometric-demo-a-between-group-analysis.html"><a href="morphometric-geometric-demo-a-between-group-analysis.html#analyse-the-results"><i class="fa fa-check"></i><b>10.3</b> Analyse the results</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/TGuillerme/dispRity/" target="blank">Project GitHub page</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">dispRity manual</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="details-of-specific-functions" class="section level1">
<h1><span class="header-section-number">4</span> Details of specific functions</h1>
<p>The following section contains information specific to some functions.
If any of your questions are not covered in these sections, please refer to the function help files in <code>R</code>, send me an email (<a href="mailto:guillert@tcd.ie">guillert@tcd.ie</a>), or raise an issue on <a href="https://github.com/TGuillerme/dispRity/issues">GitHub</a>.
The several tutorials below describe specific functionalities of certain functions; please always refer to the function help files for the full function documentation!</p>
<p>Before each section, make sure you loaded the <span class="citation">Beck and Lee (<a href="#ref-beckancient2014">2014</a>)</span> data (see <a href="getting-started-with-disprity.html#example-data">example data</a> for more details).</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="co">## Loading the data</span></a>
<a class="sourceLine" id="cb42-2" data-line-number="2"><span class="kw">data</span>(BeckLee_mat50)</a>
<a class="sourceLine" id="cb42-3" data-line-number="3"><span class="kw">data</span>(BeckLee_mat99)</a>
<a class="sourceLine" id="cb42-4" data-line-number="4"><span class="kw">data</span>(BeckLee_tree)</a>
<a class="sourceLine" id="cb42-5" data-line-number="5"><span class="kw">data</span>(BeckLee_ages)</a></code></pre></div>
<div id="chrono-subsets" class="section level2">
<h2><span class="header-section-number">4.1</span> Time slicing</h2>
<p>The function <code>chrono.subsets</code> allows users to divide the matrix into different time subsets or slices given a dated phylogeny that contains all the elements (i.e. taxa) from the matrix.
Each subset generated by this function will then contain all the elements present at a specific point in time or during a specific period in time.</p>
<p>Two types of time subsets can be performed by using the <code>method</code> option:</p>
<ul>
<li>Discrete time subsets (or time-binning) using <code>method = discrete</code></li>
<li>Continuous time subsets (or time-slicing) using <code>method = continuous</code></li>
</ul>
<p>For the time-slicing method details see <span class="citation">Guillerme and Cooper (<a href="#ref-time-slice">2018</a>)</span>.
For both methods, the function takes the <code>time</code> argument which can be a vector of <code>numeric</code> values for:</p>
<ul>
<li>Defining the boundaries of the time bins (when <code>method = discrete</code>)</li>
<li>Defining the time slices (when <code>method = continuous</code>)</li>
</ul>
<p>Otherwise, the <code>time</code> argument can be set as a single <code>numeric</code> value for automatically generating a given number of equidistant time-bins/slices.
Additionally, it is also possible to input a dataframe containing the first and last occurrence data (FAD/LAD) for taxa that span over a longer time than the given tips/nodes age, so taxa can appear in more than one time bin/slice.</p>
<div id="time-binning" class="section level3">
<h3><span class="header-section-number">4.1.1</span> Time-binning</h3>
<p>Here is an example for the time binning method (<code>method = discrete</code>):</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="co">## Generating three time bins containing the taxa present every 40 Ma</span></a>
<a class="sourceLine" id="cb43-2" data-line-number="2"><span class="kw">chrono.subsets</span>(<span class="dt">data =</span> BeckLee_mat50, <span class="dt">tree =</span> BeckLee_tree,</a>
<a class="sourceLine" id="cb43-3" data-line-number="3">               <span class="dt">method =</span> <span class="st">&quot;discrete&quot;</span>,</a>
<a class="sourceLine" id="cb43-4" data-line-number="4">               <span class="dt">time =</span> <span class="kw">c</span>(<span class="dv">120</span>, <span class="dv">80</span>, <span class="dv">40</span>, <span class="dv">0</span>))</a></code></pre></div>
<pre><code>##  ---- dispRity object ---- 
## 3 discrete time subsets for 50 elements in one matrix with 1 phylogenetic tree
##     120 - 80, 80 - 40, 40 - 0.</code></pre>
<p>Note that we can also generate equivalent results by just telling the function that we want three time-bins as follow:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="co">## Automatically generate three equal length bins:</span></a>
<a class="sourceLine" id="cb45-2" data-line-number="2"><span class="kw">chrono.subsets</span>(<span class="dt">data =</span> BeckLee_mat50, <span class="dt">tree =</span> BeckLee_tree,</a>
<a class="sourceLine" id="cb45-3" data-line-number="3">               <span class="dt">method =</span> <span class="st">&quot;discrete&quot;</span>,</a>
<a class="sourceLine" id="cb45-4" data-line-number="4">               <span class="dt">time =</span> <span class="dv">3</span>)</a></code></pre></div>
<pre><code>##  ---- dispRity object ---- 
## 3 discrete time subsets for 50 elements in one matrix with 1 phylogenetic tree
##     133.51 - 89.01, 89.01 - 44.5, 44.5 - 0.</code></pre>
<p>In this example, the taxa were split inside each time-bin according to their age.
However, the taxa here are considered as single points in time.
It is totally possible that some taxa could have had longer longevity and that they exist in multiple time bins.
In this case, it is possible to include them in more than one bin by providing a table of first and last occurrence dates (FAD/LAD).
This table should have the taxa names as row names and two columns for respectively the first and last occurrence age:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="co">## Displaying the table of first and last occurrence dates</span></a>
<a class="sourceLine" id="cb47-2" data-line-number="2"><span class="co">## for each taxa</span></a>
<a class="sourceLine" id="cb47-3" data-line-number="3"><span class="kw">head</span>(BeckLee_ages)</a></code></pre></div>
<pre><code>##             FAD  LAD
## Adapis     37.2 36.8
## Asioryctes 83.6 72.1
## Leptictis  33.9 33.3
## Miacis     49.0 46.7
## Mimotona   61.6 59.2
## Notharctus 50.2 47.0</code></pre>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="co">## Generating time bins including taxa that might span between them</span></a>
<a class="sourceLine" id="cb49-2" data-line-number="2"><span class="kw">chrono.subsets</span>(<span class="dt">data =</span> BeckLee_mat50, <span class="dt">tree =</span> BeckLee_tree,</a>
<a class="sourceLine" id="cb49-3" data-line-number="3">               <span class="dt">method =</span> <span class="st">&quot;discrete&quot;</span>,</a>
<a class="sourceLine" id="cb49-4" data-line-number="4">               <span class="dt">time =</span> <span class="kw">c</span>(<span class="dv">120</span>, <span class="dv">80</span>, <span class="dv">40</span>, <span class="dv">0</span>), <span class="dt">FADLAD =</span> BeckLee_ages)</a></code></pre></div>
<pre><code>##  ---- dispRity object ---- 
## 3 discrete time subsets for 50 elements in one matrix with 1 phylogenetic tree
##     120 - 80, 80 - 40, 40 - 0.</code></pre>
<p>When using this method, the oldest boundary of the first bin (or the first slice, see below) is automatically generated as the root age plus 1% of the tree length, as long as at least three elements/taxa are present at that point in time.
The algorithm adds an extra 1% tree length until reaching the required minimum of three elements.
It is also possible to include nodes in each bin by using <code>inc.nodes = TRUE</code> and providing a matrix that contains the ordinated distance among tips <em>and</em> nodes.</p>
<p>If you want to generate time subsets based on stratigraphy, the package proposes a useful functions to do it for you: <code>get.bin.ages</code> (check out the function’s manual in <code>R</code>)!</p>
</div>
<div id="time-slicing" class="section level3">
<h3><span class="header-section-number">4.1.2</span> Time-slicing</h3>
<p>For the time-slicing method (<code>method = continuous</code>), the idea is fairly similar.
This option, however, requires a matrix that contains the ordinated distance among taxa <em>and</em> nodes and an extra argument describing the assumed evolutionary model (via the <code>model</code> argument).
This model argument is used when the time slice occurs along a branch of the tree rather than on a tip or a node, meaning that a decision must be made about what the value for the branch should be.
The model can be one of the following:</p>
<ul>
<li><strong>Punctuated models</strong>
<ul>
<li><code>acctran</code> where the data chosen along the branch is always the one of the descendant</li>
<li><code>deltran</code> where the data chosen along the branch is always the one of the ancestor</li>
<li><code>random</code> where the data chosen along the branch is randomly chosen between the descendant or the ancestor</li>
<li><code>proximity</code> where the data chosen along the branch is either the descendant or the ancestor depending on branch length</li>
</ul></li>
<li><strong>Gradual models</strong>
<ul>
<li><code>equal.split</code> where the data chosen along the branch is both the descendant and the ancestor with an even probability</li>
<li><code>gradual.split</code> where the data chosen along the branch is both the descendant and the ancestor with a probability depending on branch length</li>
</ul></li>
</ul>
<blockquote>
<p>Note that the four first models are a proxy for punctuated evolution: the selected data is always either the one of the descendant or the ancestor.
In other words, changes along the branches always occur at either ends of it.
The two last models are a proxy for gradual evolution: the data from both the descendant and the ancestor is used with an associate probability.
These later models perform better when bootstrapped, effectively approximating the “intermediate” state between and the ancestor and the descendants.</p>
</blockquote>
<p>More details about the differences between these methods can be found in <span class="citation">Guillerme and Cooper (<a href="#ref-time-slice">2018</a>)</span>.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb51-1" data-line-number="1"><span class="co">## Generating four time slices every 40 million years</span></a>
<a class="sourceLine" id="cb51-2" data-line-number="2"><span class="co">## under a model of proximity evolution</span></a>
<a class="sourceLine" id="cb51-3" data-line-number="3"><span class="kw">chrono.subsets</span>(<span class="dt">data =</span> BeckLee_mat99, <span class="dt">tree =</span> BeckLee_tree, </a>
<a class="sourceLine" id="cb51-4" data-line-number="4">               <span class="dt">method =</span> <span class="st">&quot;continuous&quot;</span>, <span class="dt">model =</span> <span class="st">&quot;proximity&quot;</span>,</a>
<a class="sourceLine" id="cb51-5" data-line-number="5">               <span class="dt">time =</span> <span class="kw">c</span>(<span class="dv">120</span>, <span class="dv">80</span>, <span class="dv">40</span>, <span class="dv">0</span>),</a>
<a class="sourceLine" id="cb51-6" data-line-number="6">               <span class="dt">FADLAD =</span> BeckLee_ages)</a></code></pre></div>
<pre><code>##  ---- dispRity object ---- 
## 4 continuous (proximity) time subsets for 99 elements in one matrix with 1 phylogenetic tree
##     120, 80, 40, 0.</code></pre>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb53-1" data-line-number="1"><span class="co">## Generating four time slices automatically</span></a>
<a class="sourceLine" id="cb53-2" data-line-number="2"><span class="kw">chrono.subsets</span>(<span class="dt">data =</span> BeckLee_mat99, <span class="dt">tree =</span> BeckLee_tree,</a>
<a class="sourceLine" id="cb53-3" data-line-number="3">               <span class="dt">method =</span> <span class="st">&quot;continuous&quot;</span>, <span class="dt">model =</span> <span class="st">&quot;proximity&quot;</span>,</a>
<a class="sourceLine" id="cb53-4" data-line-number="4">               <span class="dt">time =</span> <span class="dv">4</span>, <span class="dt">FADLAD =</span> BeckLee_ages)</a></code></pre></div>
<pre><code>##  ---- dispRity object ---- 
## 4 continuous (proximity) time subsets for 99 elements in one matrix with 1 phylogenetic tree
##     133.51, 89.01, 44.5, 0.</code></pre>
</div>
</div>
<div id="custom-subsets" class="section level2">
<h2><span class="header-section-number">4.2</span> Customised subsets</h2>
<p>Another way of separating elements into different categories is to use customised subsets as briefly explained <a href="getting-started-with-disprity.html#disparity-among-groups">above</a>.
This function simply takes the list of elements to put in each group (whether they are the actual element names or their position in the matrix).</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb55-1" data-line-number="1"><span class="co">## Creating the two groups (crown and stems)</span></a>
<a class="sourceLine" id="cb55-2" data-line-number="2">mammal_groups &lt;-<span class="st"> </span><span class="kw">crown.stem</span>(BeckLee_tree, <span class="dt">inc.nodes =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb55-3" data-line-number="3"></a>
<a class="sourceLine" id="cb55-4" data-line-number="4"><span class="co">## Separating the dataset into two different groups</span></a>
<a class="sourceLine" id="cb55-5" data-line-number="5"><span class="kw">custom.subsets</span>(BeckLee_mat50, <span class="dt">group =</span> mammal_groups)</a></code></pre></div>
<pre><code>##  ---- dispRity object ---- 
## 2 customised subsets for 50 elements in one matrix:
##     crown, stem.</code></pre>
<p>Like in this example, you can use the utility function <code>crown.stem</code> that allows to automatically separate the crown and stems taxa given a phylogenetic tree.
Also, elements can easily be assigned to different groups if necessary!</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb57-1" data-line-number="1"><span class="co">## Creating the three groups as a list</span></a>
<a class="sourceLine" id="cb57-2" data-line-number="2">weird_groups &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="st">&quot;even&quot;</span> =<span class="st"> </span><span class="kw">seq</span>(<span class="dt">from =</span> <span class="dv">1</span>, <span class="dt">to =</span> <span class="dv">49</span>, <span class="dt">by =</span> <span class="dv">2</span>),</a>
<a class="sourceLine" id="cb57-3" data-line-number="3">                      <span class="st">&quot;odd&quot;</span> =<span class="st"> </span><span class="kw">seq</span>(<span class="dt">from =</span> <span class="dv">2</span>, <span class="dt">to =</span> <span class="dv">50</span>, <span class="dt">by =</span> <span class="dv">2</span>),</a>
<a class="sourceLine" id="cb57-4" data-line-number="4">                      <span class="st">&quot;all&quot;</span> =<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">50</span>))</a></code></pre></div>
<p>The <code>custom.subsets</code> function can also take a phylogeny (as a <code>phylo</code> object) as an argument to create groups as clades:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb58-1" data-line-number="1"><span class="co">## Creating groups as clades</span></a>
<a class="sourceLine" id="cb58-2" data-line-number="2"><span class="kw">custom.subsets</span>(BeckLee_mat50, <span class="dt">group =</span> BeckLee_tree)</a></code></pre></div>
<p>This automatically creates 49 (the number of nodes) groups containing between two and 50 (the number of tips) elements.</p>
</div>
<div id="bootstraps-and-rarefactions" class="section level2">
<h2><span class="header-section-number">4.3</span> Bootstraps and rarefactions</h2>
<p>One important step in analysing ordinated matrices is to pseudo-replicate the data to see how robust the results are, and how sensitive they are to outliers in the dataset.
This can be achieved using the function <code>boot.matrix</code> to bootstrap and/or rarefy the data.
The default options will bootstrap the matrix 100 times without rarefaction using the “full” bootstrap method (see below):</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb59-1" data-line-number="1"><span class="co">## Default bootstrapping</span></a>
<a class="sourceLine" id="cb59-2" data-line-number="2"><span class="kw">boot.matrix</span>(<span class="dt">data =</span> BeckLee_mat50)</a></code></pre></div>
<pre><code>##  ---- dispRity object ---- 
## 50 elements in one matrix with 48 dimensions.
## Data was bootstrapped 100 times (method:&quot;full&quot;).</code></pre>
<p>The number of bootstrap replicates can be defined using the <code>bootstraps</code> option.
The method can be modified by controlling which bootstrap algorithm to use through the <code>boot.type</code> argument.
Currently two algorithms are implemented:</p>
<ul>
<li><code>full</code> where the bootstrapping is entirely stochastic (<em>n</em> elements are replaced by any <em>m</em> elements drawn from the data)</li>
<li><code>single</code> where only one random element is replaced by one other random element for each pseudo-replicate</li>
</ul>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb61-1" data-line-number="1"><span class="co">## Bootstrapping with the single bootstrap method</span></a>
<a class="sourceLine" id="cb61-2" data-line-number="2"><span class="kw">boot.matrix</span>(BeckLee_mat50, <span class="dt">boot.type =</span> <span class="st">&quot;single&quot;</span>)</a></code></pre></div>
<pre><code>##  ---- dispRity object ---- 
## 50 elements in one matrix with 48 dimensions.
## Data was bootstrapped 100 times (method:&quot;single&quot;).</code></pre>
<p>This function also allows users to rarefy the data using the <code>rarefaction</code> argument.
Rarefaction allows users to limit the number of elements to be drawn at each bootstrap replication.
This is useful if, for example, one is interested in looking at the effect of reducing the number of elements on the results of an analysis.</p>
<p>This can be achieved by using the <code>rarefaction</code> option that draws only <em>n-x</em> at each bootstrap replicate (where <em>x</em> is the number of elements not sampled).
The default argument is <code>FALSE</code> but it can be set to <code>TRUE</code> to fully rarefy the data (i.e. remove <em>x</em> elements for the number of pseudo-replicates, where <em>x</em> varies from the maximum number of elements present in each subset to a minimum of three elements).
It can also be set to one or more <code>numeric</code> values to only rarefy to the corresponding number of elements.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb63-1" data-line-number="1"><span class="co">## Bootstrapping with the full rarefaction</span></a>
<a class="sourceLine" id="cb63-2" data-line-number="2"><span class="kw">boot.matrix</span>(BeckLee_mat50, <span class="dt">bootstraps =</span> <span class="dv">20</span>,</a>
<a class="sourceLine" id="cb63-3" data-line-number="3">            <span class="dt">rarefaction =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<pre><code>##  ---- dispRity object ---- 
## 50 elements in one matrix with 48 dimensions.
## Data was bootstrapped 20 times (method:&quot;full&quot;) and fully rarefied.</code></pre>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb65-1" data-line-number="1"><span class="co">## Or with a set number of rarefaction levels</span></a>
<a class="sourceLine" id="cb65-2" data-line-number="2"><span class="kw">boot.matrix</span>(BeckLee_mat50, <span class="dt">bootstraps =</span> <span class="dv">20</span>,</a>
<a class="sourceLine" id="cb65-3" data-line-number="3">            <span class="dt">rarefaction =</span> <span class="kw">c</span>(<span class="dv">6</span><span class="op">:</span><span class="dv">8</span>, <span class="dv">3</span>))</a></code></pre></div>
<pre><code>##  ---- dispRity object ---- 
## 50 elements in one matrix with 48 dimensions.
## Data was bootstrapped 20 times (method:&quot;full&quot;) and rarefied to 6, 7, 8, 3 elements.</code></pre>
<blockquote>
<p>Note that using the <code>rarefaction</code> argument also bootstraps the data. In these examples, the function bootstraps the data (without rarefaction) AND also bootstraps the data with the different rarefaction levels.</p>
</blockquote>
<p>One other argument is <code>dimensions</code> that specifies how many dimensions from the matrix should be used for further analysis.
When missing, all dimensions from the ordinated matrix are used.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb67-1" data-line-number="1"><span class="co">## Using the first 50% of the dimensions</span></a>
<a class="sourceLine" id="cb67-2" data-line-number="2"><span class="kw">boot.matrix</span>(BeckLee_mat50, <span class="dt">dimensions =</span> <span class="fl">0.5</span>)</a></code></pre></div>
<pre><code>##  ---- dispRity object ---- 
## 50 elements in one matrix with 24 dimensions.
## Data was bootstrapped 100 times (method:&quot;full&quot;).</code></pre>
<div class="sourceCode" id="cb69"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb69-1" data-line-number="1"><span class="co">## Using the first 10 dimensions</span></a>
<a class="sourceLine" id="cb69-2" data-line-number="2"><span class="kw">boot.matrix</span>(BeckLee_mat50, <span class="dt">dimensions =</span> <span class="dv">10</span>)</a></code></pre></div>
<pre><code>##  ---- dispRity object ---- 
## 50 elements in one matrix with 1 dimensions.
## Data was bootstrapped 100 times (method:&quot;full&quot;).</code></pre>
<p>It is also possible to specify the sampling probability in the bootstrap for each elements.
This can be useful for weighting analysis for example (i.e. giving more importance to specific elements).
These probabilities can be passed to the <code>prob</code> argument individually with a vector with the elements names or with a matrix with the rownames as elements names.
The elements with no specified probability will be assigned a probability of 1 (or 1/maximum weight if the argument is weights rather than probabilities).</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb71-1" data-line-number="1"><span class="co">## Attributing a weight of 0 to Cimolestes and 10 to Maelestes</span></a>
<a class="sourceLine" id="cb71-2" data-line-number="2"><span class="kw">boot.matrix</span>(BeckLee_mat50,</a>
<a class="sourceLine" id="cb71-3" data-line-number="3">            <span class="dt">prob =</span> <span class="kw">c</span>(<span class="st">&quot;Cimolestes&quot;</span> =<span class="st"> </span><span class="dv">0</span>, <span class="st">&quot;Maelestes&quot;</span> =<span class="st"> </span><span class="dv">10</span>))</a></code></pre></div>
<pre><code>##  ---- dispRity object ---- 
## 50 elements in one matrix with 48 dimensions.
## Data was bootstrapped 100 times (method:&quot;full&quot;).</code></pre>
<p>Of course, one could directly supply the subsets generated above (using <code>chrono.subsets</code> or <code>custom.subsets</code>) to this function.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb73-1" data-line-number="1"><span class="co">## Creating subsets of crown and stem mammals</span></a>
<a class="sourceLine" id="cb73-2" data-line-number="2">crown_stem &lt;-<span class="st"> </span><span class="kw">custom.subsets</span>(BeckLee_mat50,</a>
<a class="sourceLine" id="cb73-3" data-line-number="3">                             <span class="dt">group =</span> <span class="kw">crown.stem</span>(BeckLee_tree,</a>
<a class="sourceLine" id="cb73-4" data-line-number="4">                                                <span class="dt">inc.nodes =</span> <span class="ot">FALSE</span>))</a>
<a class="sourceLine" id="cb73-5" data-line-number="5"><span class="co">## Bootstrapping and rarefying these groups</span></a>
<a class="sourceLine" id="cb73-6" data-line-number="6"><span class="kw">boot.matrix</span>(crown_stem, <span class="dt">bootstraps =</span> <span class="dv">200</span>, <span class="dt">rarefaction =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<pre><code>##  ---- dispRity object ---- 
## 2 customised subsets for 50 elements in one matrix with 48 dimensions:
##     crown, stem.
## Data was bootstrapped 200 times (method:&quot;full&quot;) and fully rarefied.</code></pre>
<div class="sourceCode" id="cb75"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb75-1" data-line-number="1"><span class="co">## Creating time slice subsets</span></a>
<a class="sourceLine" id="cb75-2" data-line-number="2">time_slices &lt;-<span class="st"> </span><span class="kw">chrono.subsets</span>(<span class="dt">data =</span> BeckLee_mat99,</a>
<a class="sourceLine" id="cb75-3" data-line-number="3">                              <span class="dt">tree =</span> BeckLee_tree, </a>
<a class="sourceLine" id="cb75-4" data-line-number="4">                              <span class="dt">method =</span> <span class="st">&quot;continuous&quot;</span>,</a>
<a class="sourceLine" id="cb75-5" data-line-number="5">                              <span class="dt">model =</span> <span class="st">&quot;proximity&quot;</span>, </a>
<a class="sourceLine" id="cb75-6" data-line-number="6">                              <span class="dt">time =</span> <span class="kw">c</span>(<span class="dv">120</span>, <span class="dv">80</span>, <span class="dv">40</span>, <span class="dv">0</span>),</a>
<a class="sourceLine" id="cb75-7" data-line-number="7">                              <span class="dt">FADLAD =</span> BeckLee_ages)</a>
<a class="sourceLine" id="cb75-8" data-line-number="8"></a>
<a class="sourceLine" id="cb75-9" data-line-number="9"><span class="co">## Bootstrapping the time slice subsets</span></a>
<a class="sourceLine" id="cb75-10" data-line-number="10"><span class="kw">boot.matrix</span>(time_slices, <span class="dt">bootstraps =</span> <span class="dv">100</span>)</a></code></pre></div>
<pre><code>##  ---- dispRity object ---- 
## 4 continuous (proximity) time subsets for 99 elements in one matrix with 97 dimensions with 1 phylogenetic tree
##     120, 80, 40, 0.
## Data was bootstrapped 100 times (method:&quot;full&quot;).</code></pre>
</div>
<div id="disparity-metrics" class="section level2">
<h2><span class="header-section-number">4.4</span> Disparity metrics</h2>
<p>There are many ways of measuring disparity!
In brief, disparity is a summary metric that will represent an aspect of an ordinated space (e.g. a MDS, PCA, PCO, PCoA).
For example, one can look at ellipsoid hyper-volume of the ordinated space (Donohue <em>et al.</em> 2013), the sum and the product of the ranges and variances (Wills <em>et al.</em> 1994) or the median position of the elements relative to their centroid (Wills <em>et al.</em> 1994).
Of course, there are many more examples of metrics one can use for describing some aspect of the ordinated space, with some performing better than other ones at particular descriptive tasks, and some being more generalist.
Check out this pre-print on selecting the best metric for your specific question on <a href="https://www.biorxiv.org/content/10.1101/801571v1">biorXiv</a>.
<!-- biorXiv preprint -->
You can also use the <a href="https://tguillerme.shinyapps.io/moms/"><code>moms</code> shiny app</a> to test which metric captures which aspect of traitspace occupancy regarding your specific space and your specific question.</p>
<p>Regardless, and because of this great diversity of metrics, the package <code>dispRity</code> does not have one way to measure disparity but rather proposes to facilitate users in defining their own disparity metric that will best suit their particular analysis.
In fact, the core function of the package, <code>dispRity</code>, allows the user to define any metric with the <code>metric</code> argument.
However the <code>metric</code> argument has to follow certain rules:</p>
<ol style="list-style-type: decimal">
<li>It must be composed from one to three <code>function</code> objects;</li>
<li>The function(s) must take as a first argument a <code>matrix</code> or a <code>vector</code>;</li>
<li>The function(s) must be of one of the three dimension-levels described below;</li>
<li>At least one of the functions must be of dimension-level 1 or 2 (see below).</li>
</ol>
<div id="the-function-dimension-levels" class="section level3">
<h3><span class="header-section-number">4.4.1</span> The function dimension-levels</h3>
<p>The metric function dimension-levels determine the “dimensionality of decomposition” of the input matrix.
In other words, each dimension-level designates the dimensions of the output, i.e. either three (a <code>matrix</code>); two (a <code>vector</code>); or one (a single <code>numeric</code> value) dimension.</p>
<div class="figure">
<img src="dispRity_fun.png" alt="Illustration of the different dimension-levels of functions with an input matrix" />
<p class="caption">Illustration of the different dimension-levels of functions with an input <code>matrix</code></p>
</div>
<div id="dimension-level-1-functions" class="section level4">
<h4><span class="header-section-number">4.4.1.1</span> Dimension-level 1 functions</h4>
<p>A dimension-level 1 function will decompose a <code>matrix</code> or a <code>vector</code> into a single value:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb77-1" data-line-number="1"><span class="co">## Creating a dummy matrix</span></a>
<a class="sourceLine" id="cb77-2" data-line-number="2">dummy_matrix &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">12</span>), <span class="dv">4</span>, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb77-3" data-line-number="3"></a>
<a class="sourceLine" id="cb77-4" data-line-number="4"><span class="co">## Example of dimension-level 1 functions</span></a>
<a class="sourceLine" id="cb77-5" data-line-number="5"><span class="kw">mean</span>(dummy_matrix)</a></code></pre></div>
<pre><code>## [1] 0.1012674</code></pre>
<div class="sourceCode" id="cb79"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb79-1" data-line-number="1"><span class="kw">median</span>(dummy_matrix)</a></code></pre></div>
<pre><code>## [1] 0.3345108</code></pre>
<p>Any summary metric such as mean or median are good examples of dimension-level 1 functions as they reduce the matrix to a single dimension (i.e. one value).</p>
</div>
<div id="dimension-level-2-functions" class="section level4">
<h4><span class="header-section-number">4.4.1.2</span> Dimension-level 2 functions</h4>
<p>A dimension-level 2 function will decompose a <code>matrix</code> into a <code>vector</code>.</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb81-1" data-line-number="1"><span class="co">## Defining the function as the product of rows</span></a>
<a class="sourceLine" id="cb81-2" data-line-number="2">prod.rows &lt;-<span class="st"> </span><span class="cf">function</span>(matrix) <span class="kw">apply</span>(matrix, <span class="dv">1</span>, prod)</a>
<a class="sourceLine" id="cb81-3" data-line-number="3"></a>
<a class="sourceLine" id="cb81-4" data-line-number="4"><span class="co">## A dimension-level 2 metric</span></a>
<a class="sourceLine" id="cb81-5" data-line-number="5"><span class="kw">prod.rows</span>(dummy_matrix)</a></code></pre></div>
<pre><code>## [1]  0.72217818  2.48612354 -0.08986575  0.58266449</code></pre>
<p>Several dimension-level 2 functions are implemented in <code>dispRity</code> (see <code>?dispRity.metric</code>) such as the <code>variances</code> or <code>ranges</code> functions that calculate the variance or the range of each dimension of the ordinated matrix respectively.</p>
</div>
<div id="dimension-level-3-functions" class="section level4">
<h4><span class="header-section-number">4.4.1.3</span> Dimension-level 3 functions</h4>
<p>Finally a dimension-level 3 function will transform the matrix into another matrix.
Note that the dimension of the output matrix doesn’t need to match the the input matrix:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb83-1" data-line-number="1"><span class="co">## A dimension-level 3 metric</span></a>
<a class="sourceLine" id="cb83-2" data-line-number="2"><span class="kw">var</span>(dummy_matrix)</a></code></pre></div>
<pre><code>##            [,1]       [,2]       [,3]
## [1,]  1.8570383  0.7417569 -0.5131686
## [2,]  0.7417569  1.3194330 -1.5344429
## [3,] -0.5131686 -1.5344429  2.8070556</code></pre>
<div class="sourceCode" id="cb85"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb85-1" data-line-number="1"><span class="co">## A dimension-level 3 metric with a forced matrix output</span></a>
<a class="sourceLine" id="cb85-2" data-line-number="2"><span class="kw">as.matrix</span>(<span class="kw">dist</span>(dummy_matrix))</a></code></pre></div>
<pre><code>##          1        2        3        4
## 1 0.000000 4.794738 3.382990 3.297110
## 2 4.794738 0.000000 2.400321 3.993864
## 3 3.382990 2.400321 0.000000 2.187412
## 4 3.297110 3.993864 2.187412 0.000000</code></pre>
</div>
</div>
<div id="betweengroupmetricsexplain" class="section level3">
<h3><span class="header-section-number">4.4.2</span> Between groups metrics</h3>
<p>One specific category of metrics in the <code>dispRity</code> package is the between groups metrics.
As the name suggest, these metrics can be used to calculate the disparity between groups rather than within the groups.
These metrics follow the same classifications as the “normal” (within group) metrics with dimension-level 1, 2 and 3 between groups metrics.
However, at the difference of the “normal” metrics, their input arguments must be <code>matrix</code> and <code>matrix2</code> (and of course any other additional arguments).
For example, this metric measures the difference in mean between two matrices:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb87-1" data-line-number="1"><span class="co">## A simple example</span></a>
<a class="sourceLine" id="cb87-2" data-line-number="2">mean.difference &lt;-<span class="st"> </span><span class="cf">function</span>(matrix, matrix2) {</a>
<a class="sourceLine" id="cb87-3" data-line-number="3">  <span class="kw">mean</span>(matrix) <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(matrix2)</a>
<a class="sourceLine" id="cb87-4" data-line-number="4">}</a></code></pre></div>
<p>You can find the list of implemented between groups metric <a href="details-of-specific-functions.html#betweengroupmetricslist">here</a> or design them yourself for your specific needs (potentially using <a href="details-of-specific-functions.html#makemetric"><code>make.metric</code></a> for help).</p>
<p>The function works by simply using the two available matrices, with no restriction in terms of dimensions (although you’d probably want both matrices to have the same number of dimensions)</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb88-1" data-line-number="1"><span class="co">## A second matrix</span></a>
<a class="sourceLine" id="cb88-2" data-line-number="2">dummy_matrix2 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">runif</span>(<span class="dv">12</span>), <span class="dv">4</span>, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb88-3" data-line-number="3"></a>
<a class="sourceLine" id="cb88-4" data-line-number="4"><span class="co">## The difference between groups</span></a>
<a class="sourceLine" id="cb88-5" data-line-number="5"><span class="kw">mean.difference</span>(dummy_matrix, dummy_matrix2)</a></code></pre></div>
<pre><code>## [1] -0.3194556</code></pre>
<p>Beyond this super simple example, it might probably be interesting to use this metric on <code>dispRity</code> objects, especially the ones from <a href="details-of-specific-functions.html#custom-subsets"><code>custom.subsets</code></a> and <a href="details-of-specific-functions.html#chrono-subsets"><code>chrono.subsets</code></a>.
In fact, the <code>dispRity</code> function allows to apply the between groups metric directly to the <code>dispRity</code> objects using the <code>between.groups = TRUE</code> option.
For example:</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb90-1" data-line-number="1"><span class="co">## Combining both matrices</span></a>
<a class="sourceLine" id="cb90-2" data-line-number="2">big_matrix &lt;-<span class="st"> </span><span class="kw">rbind</span>(dummy_matrix, dummy_matrix2)</a>
<a class="sourceLine" id="cb90-3" data-line-number="3"><span class="kw">rownames</span>(big_matrix) &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">8</span></a>
<a class="sourceLine" id="cb90-4" data-line-number="4"></a>
<a class="sourceLine" id="cb90-5" data-line-number="5"><span class="co">## Making a dispRity object with both groups</span></a>
<a class="sourceLine" id="cb90-6" data-line-number="6">grouped_matrix &lt;-<span class="st"> </span><span class="kw">custom.subsets</span>(big_matrix,</a>
<a class="sourceLine" id="cb90-7" data-line-number="7">                                 <span class="dt">group =</span> <span class="kw">c</span>(<span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>), <span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>)))</a>
<a class="sourceLine" id="cb90-8" data-line-number="8"></a>
<a class="sourceLine" id="cb90-9" data-line-number="9"><span class="co">## Calculating the mean difference between groups</span></a>
<a class="sourceLine" id="cb90-10" data-line-number="10">(mean_differences &lt;-<span class="st"> </span><span class="kw">dispRity</span>(grouped_matrix,</a>
<a class="sourceLine" id="cb90-11" data-line-number="11">                              <span class="dt">metric =</span> mean.difference,</a>
<a class="sourceLine" id="cb90-12" data-line-number="12">                              <span class="dt">between.groups =</span> <span class="ot">TRUE</span>))</a></code></pre></div>
<pre><code>##  ---- dispRity object ---- 
## 2 customised subsets for 8 elements in one matrix with 3 dimensions:
##     1, 2.
## Disparity was calculated as: mean.difference between groups.</code></pre>
<div class="sourceCode" id="cb92"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb92-1" data-line-number="1"><span class="co">## Summarising the object</span></a>
<a class="sourceLine" id="cb92-2" data-line-number="2"><span class="kw">summary</span>(mean_differences)</a></code></pre></div>
<pre><code>##   subsets n_1 n_2 obs
## 1     1:2   4   4   0</code></pre>
<div class="sourceCode" id="cb94"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb94-1" data-line-number="1"><span class="co">## Note how the summary table now indicates</span></a>
<a class="sourceLine" id="cb94-2" data-line-number="2"><span class="co">## the number of elements for each group</span></a></code></pre></div>
<p>For <code>dispRity</code> objects generated by <code>custom.subsets</code>, the <code>dispRity</code> function will by default apply the metric on the groups in a pairwise fashion.
For example, if the object contains multiple groups, all groups will be compared to each other:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb95-1" data-line-number="1"><span class="co">## A dispRity object with multiple groups</span></a>
<a class="sourceLine" id="cb95-2" data-line-number="2">grouped_matrix &lt;-<span class="st"> </span><span class="kw">custom.subsets</span>(big_matrix,</a>
<a class="sourceLine" id="cb95-3" data-line-number="3">                                 <span class="dt">group =</span> <span class="kw">c</span>(<span class="st">&quot;A&quot;</span> =<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>),</a>
<a class="sourceLine" id="cb95-4" data-line-number="4">                                           <span class="st">&quot;B&quot;</span> =<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>),</a>
<a class="sourceLine" id="cb95-5" data-line-number="5">                                           <span class="st">&quot;C&quot;</span> =<span class="st"> </span><span class="kw">list</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">6</span>), </a>
<a class="sourceLine" id="cb95-6" data-line-number="6">                                           <span class="st">&quot;D&quot;</span> =<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">8</span>)))</a>
<a class="sourceLine" id="cb95-7" data-line-number="7"></a>
<a class="sourceLine" id="cb95-8" data-line-number="8"><span class="co">## Measuring disparity between all groups</span></a>
<a class="sourceLine" id="cb95-9" data-line-number="9"><span class="kw">summary</span>(<span class="kw">dispRity</span>(grouped_matrix, <span class="dt">metric =</span> mean.difference,</a>
<a class="sourceLine" id="cb95-10" data-line-number="10">                 <span class="dt">between.groups =</span> <span class="ot">TRUE</span>))</a></code></pre></div>
<pre><code>##   subsets n_1 n_2    obs
## 1     A:B   4   4  0.000
## 2     A:C   4   5 -0.172
## 3     A:D   4   8 -0.160
## 4     B:C   4   5 -0.172
## 5     B:D   4   8 -0.160
## 6     C:D   5   8  0.012</code></pre>
<p>For <code>dispRity</code> objects generated by <code>chrono.subsets</code> (not shown here), the <code>dispRity</code> function will by default apply the metric on the groups in a serial way (group 1 vs. group 2, group 2 vs. group 3, group 3 vs. group 4, etc…).
However, in both cases (for objects from <code>custom.subsets</code> or <code>chrono.subsets</code>) it is possible to manually specific the list of pairs of comparisons through their ID numbers:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb97-1" data-line-number="1"><span class="co">## Measuring disparity between specific groups</span></a>
<a class="sourceLine" id="cb97-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(grouped_matrix, <span class="dt">metric =</span> mean.difference,</a>
<a class="sourceLine" id="cb97-3" data-line-number="3">                 <span class="dt">between.groups =</span> <span class="kw">list</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">3</span>), <span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">4</span>,<span class="dv">1</span>))))</a></code></pre></div>
<pre><code>##   subsets n_1 n_2    obs
## 1     A:C   4   5 -0.172
## 2     C:A   5   4  0.172
## 3     D:A   8   4  0.160</code></pre>
<p>Note that in any case, the order of the comparison can matter.
In our example, it is obvious that <code>mean(matrix) - mean(matrix2)</code> is not the same as <code>mean(matrix2) - mean(matrix)</code>.</p>
</div>
<div id="makemetric" class="section level3">
<h3><span class="header-section-number">4.4.3</span> <code>make.metric</code></h3>
<p>Of course, functions can be more complex and involve multiple operations such as the <code>centroids</code> function (see <code>?dispRity.metric</code>) that calculates the Euclidean distance between each element and the centroid of the ordinated space.
The <code>make.metric</code> function implemented in <code>dispRity</code> is designed to help test and find the dimension-level of the functions.
This function tests:</p>
<ol style="list-style-type: decimal">
<li>If your function can deal with a <code>matrix</code> or a <code>vector</code> as an input;</li>
<li>Your function’s dimension-level according to its output (dimension-level 1, 2 or 3, see above);</li>
<li>Whether the function can be implemented in the <code>dispRity</code> function (the function is fed into a <code>lapply</code> loop).</li>
</ol>
<p>For example, let’s see if the functions described above are the right dimension-levels:</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb99-1" data-line-number="1"><span class="co">## Which dimension-level is the mean function?</span></a>
<a class="sourceLine" id="cb99-2" data-line-number="2"><span class="co">## And can it be used in dispRity?</span></a>
<a class="sourceLine" id="cb99-3" data-line-number="3"><span class="kw">make.metric</span>(mean)</a></code></pre></div>
<pre><code>## mean outputs a single value.
## mean is detected as being a dimension-level 1 function.</code></pre>
<div class="sourceCode" id="cb101"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb101-1" data-line-number="1"><span class="co">## Which dimension-level is the prod.rows function?</span></a>
<a class="sourceLine" id="cb101-2" data-line-number="2"><span class="co">## And can it be used in dispRity?</span></a>
<a class="sourceLine" id="cb101-3" data-line-number="3"><span class="kw">make.metric</span>(prod.rows)</a></code></pre></div>
<pre><code>## prod.rows outputs a matrix object.
## prod.rows is detected as being a dimension-level 2 function.</code></pre>
<div class="sourceCode" id="cb103"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb103-1" data-line-number="1"><span class="co">## Which dimension-level is the var function?</span></a>
<a class="sourceLine" id="cb103-2" data-line-number="2"><span class="co">## And can it be used in dispRity?</span></a>
<a class="sourceLine" id="cb103-3" data-line-number="3"><span class="kw">make.metric</span>(var)</a></code></pre></div>
<pre><code>## var outputs a matrix object.
## var is detected as being a dimension-level 3 function.
## Additional dimension-level 2 and/or 1 function(s) will be needed.</code></pre>
<p>A non verbose version of the function is also available.
This can be done using the option <code>silent = TRUE</code> and will simply output the dimension-level of the metric.</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb105-1" data-line-number="1"><span class="co">## Testing whether mean is dimension-level 1</span></a>
<a class="sourceLine" id="cb105-2" data-line-number="2"><span class="cf">if</span>(<span class="kw">make.metric</span>(mean, <span class="dt">silent =</span> <span class="ot">TRUE</span>) <span class="op">!=</span><span class="st"> &quot;level1&quot;</span>) {</a>
<a class="sourceLine" id="cb105-3" data-line-number="3">    <span class="kw">message</span>(<span class="st">&quot;The metric is not dimension-level 1.&quot;</span>)</a>
<a class="sourceLine" id="cb105-4" data-line-number="4">}</a></code></pre></div>
<pre><code>## Warning in if (make.metric(mean, silent = TRUE) != &quot;level1&quot;) {: the condition
## has length &gt; 1 and only the first element will be used</code></pre>
<div class="sourceCode" id="cb107"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb107-1" data-line-number="1"><span class="co">## Testing whether var is dimension-level 1</span></a>
<a class="sourceLine" id="cb107-2" data-line-number="2"><span class="cf">if</span>(<span class="kw">make.metric</span>(var, <span class="dt">silent =</span> <span class="ot">TRUE</span>) <span class="op">!=</span><span class="st"> &quot;level1&quot;</span>) {</a>
<a class="sourceLine" id="cb107-3" data-line-number="3">    <span class="kw">message</span>(<span class="st">&quot;The metric is not dimension-level 1.&quot;</span>)</a>
<a class="sourceLine" id="cb107-4" data-line-number="4">}</a></code></pre></div>
<pre><code>## Warning in if (make.metric(var, silent = TRUE) != &quot;level1&quot;) {: the condition has
## length &gt; 1 and only the first element will be used</code></pre>
<pre><code>## The metric is not dimension-level 1.</code></pre>
</div>
<div id="metrics-in-the-disprity-function" class="section level3">
<h3><span class="header-section-number">4.4.4</span> Metrics in the <code>dispRity</code> function</h3>
<p>Using this metric structure, we can easily use any disparity metric in the <code>dispRity</code> function as follows:</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb110-1" data-line-number="1"><span class="co">## Measuring disparity as the standard deviation</span></a>
<a class="sourceLine" id="cb110-2" data-line-number="2"><span class="co">## of all the values of the</span></a>
<a class="sourceLine" id="cb110-3" data-line-number="3"><span class="co">## ordinated matrix (dimension-level 1 function).</span></a>
<a class="sourceLine" id="cb110-4" data-line-number="4"><span class="kw">summary</span>(<span class="kw">dispRity</span>(BeckLee_mat50, <span class="dt">metric =</span> sd))</a></code></pre></div>
<pre><code>##   subsets  n   obs
## 1       1 50 0.227</code></pre>
<div class="sourceCode" id="cb112"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb112-1" data-line-number="1"><span class="co">## Measuring disparity as the standard deviation</span></a>
<a class="sourceLine" id="cb112-2" data-line-number="2"><span class="co">## of the variance of each axis of</span></a>
<a class="sourceLine" id="cb112-3" data-line-number="3"><span class="co">## the ordinated matrix (dimension-level 1 and 2 functions).</span></a>
<a class="sourceLine" id="cb112-4" data-line-number="4"><span class="kw">summary</span>(<span class="kw">dispRity</span>(BeckLee_mat50, <span class="dt">metric =</span> <span class="kw">c</span>(sd, variances)))</a></code></pre></div>
<pre><code>##   subsets  n   obs
## 1       1 50 0.032</code></pre>
<div class="sourceCode" id="cb114"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb114-1" data-line-number="1"><span class="co">## Measuring disparity as the standard deviation</span></a>
<a class="sourceLine" id="cb114-2" data-line-number="2"><span class="co">## of the variance of each axis of</span></a>
<a class="sourceLine" id="cb114-3" data-line-number="3"><span class="co">## the variance covariance matrix (dimension-level 1, 2 and 3 functions).</span></a>
<a class="sourceLine" id="cb114-4" data-line-number="4"><span class="kw">summary</span>(<span class="kw">dispRity</span>(BeckLee_mat50, <span class="dt">metric =</span> <span class="kw">c</span>(sd, variances, var)), <span class="dt">round =</span> <span class="dv">10</span>)</a></code></pre></div>
<pre><code>##   subsets  n obs
## 1       1 50   0</code></pre>
<p>Note that the order of each function in the metric argument does not matter, the <code>dispRity</code> function will automatically detect the function dimension-levels (using <code>make.metric</code>) and apply them to the data in decreasing order (dimension-level 3 &gt; 2 &gt; 1).</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb116-1" data-line-number="1"><span class="co">## Disparity as the standard deviation of the variance of each axis of the</span></a>
<a class="sourceLine" id="cb116-2" data-line-number="2"><span class="co">## variance covariance matrix:</span></a>
<a class="sourceLine" id="cb116-3" data-line-number="3">disparity1 &lt;-<span class="st"> </span><span class="kw">summary</span>(<span class="kw">dispRity</span>(BeckLee_mat50,</a>
<a class="sourceLine" id="cb116-4" data-line-number="4">                               <span class="dt">metric =</span> <span class="kw">c</span>(sd, variances, var)),</a>
<a class="sourceLine" id="cb116-5" data-line-number="5">                      <span class="dt">round =</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb116-6" data-line-number="6"></a>
<a class="sourceLine" id="cb116-7" data-line-number="7"><span class="co">## Same as above but using a different function order for the metric argument</span></a>
<a class="sourceLine" id="cb116-8" data-line-number="8">disparity2 &lt;-<span class="st"> </span><span class="kw">summary</span>(<span class="kw">dispRity</span>(BeckLee_mat50,</a>
<a class="sourceLine" id="cb116-9" data-line-number="9">                               <span class="dt">metric =</span> <span class="kw">c</span>(variances, sd, var)),</a>
<a class="sourceLine" id="cb116-10" data-line-number="10">                      <span class="dt">round =</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb116-11" data-line-number="11"></a>
<a class="sourceLine" id="cb116-12" data-line-number="12"><span class="co">## Both ways output the same disparity values:</span></a>
<a class="sourceLine" id="cb116-13" data-line-number="13">disparity1 <span class="op">==</span><span class="st"> </span>disparity2</a></code></pre></div>
<pre><code>##      subsets    n  obs
## [1,]    TRUE TRUE TRUE</code></pre>
<p>In these examples, we considered disparity to be a single value.
For example, in the previous example, we defined disparity as the standard deviation of the variances of each column of the variance/covariance matrix (<code>metric = c(variances, sd, var)</code>).
It is, however, possible to calculate <a href="#disparity-as-a-distribution">disparity as a distribution</a>.</p>
</div>
<div id="metrics-implemented-in-disprity" class="section level3">
<h3><span class="header-section-number">4.4.5</span> Metrics implemented in <code>dispRity</code></h3>
<!-- TODO: Sort by group of metrics -->
<p>Several disparity metrics are implemented in the <code>dispRity</code> package.
The detailed list can be found in <code>?dispRity.metric</code> along with some description of each metric.</p>
<table>
<colgroup>
<col width="8%" />
<col width="8%" />
<col width="71%" />
<col width="11%" />
</colgroup>
<thead>
<tr class="header">
<th>Level</th>
<th>Name</th>
<th>Description</th>
<th>Source</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td><code>ancestral.dist</code></td>
<td>The distance between an element and its ancestor</td>
<td><code>dispRity</code></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>angles</code></td>
<td>The angle of main variation of each dimensions</td>
<td><code>dispRity</code></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>centroids</code><sup>1</sup></td>
<td>The distance between each element and the centroid of the ordinated space</td>
<td><code>dispRity</code></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>convhull.surface</code></td>
<td>The surface of the convex hull formed by all the elements</td>
<td><a href="https://cran.r-project.org/web/packages/geometry/index.html"><code>geometry</code></a><code>::convhulln$area</code></td>
</tr>
<tr class="odd">
<td>1</td>
<td><code>convhull.volume</code></td>
<td>The volume of the convex hull formed by all the elements</td>
<td><a href="https://cran.r-project.org/web/packages/geometry/index.html"><code>geometry</code></a><code>::convhulln$vol</code></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>deviations</code></td>
<td>The minimal distance between each element and a hyperplane</td>
<td><code>dispRity</code></td>
</tr>
<tr class="odd">
<td>1</td>
<td><code>diagonal</code></td>
<td>The longest distance in the ordinated space (like the diagonal in two dimensions)</td>
<td><code>dispRity</code></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>displacements</code></td>
<td>The ratio between the distance from a reference and the distance from the centroid</td>
<td><code>dispRity</code></td>
</tr>
<tr class="odd">
<td>1</td>
<td><code>edge.length.tree</code></td>
<td>The edge lengths of the elements on a tree</td>
<td><code>ape</code></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>ellipse.volume</code><sup>1</sup></td>
<td>The volume of the ellipsoid of the space</td>
<td>Donohue <em>et al.</em> (2013)</td>
</tr>
<tr class="odd">
<td>1</td>
<td><code>func.div</code></td>
<td>The functional divergence (the ratio of deviation from the centroid)</td>
<td><code>dispRity</code> (similar to <a href="https://cran.r-project.org/web/packages/FD/index.html"><code>FD</code></a><code>::dbFD$FDiv</code> but without abundance)</td>
</tr>
<tr class="even">
<td>1</td>
<td><code>func.eve</code></td>
<td>The functional evenness (the minimal spanning tree distances evenness)</td>
<td><code>dispRity</code> (similar to <a href="https://cran.r-project.org/web/packages/FD/index.html"><code>FD</code></a><code>::dbFD$FEve</code> but without abundance)</td>
</tr>
<tr class="odd">
<td>1</td>
<td><code>group.dist</code></td>
<td>The distance between two groups</td>
<td><code>dispRity</code></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>mode.val</code></td>
<td>The modal value</td>
<td><code>dispRity</code></td>
</tr>
<tr class="odd">
<td>1</td>
<td><code>n.ball.volume</code></td>
<td>The hyper-spherical (<em>n</em>-ball) volume</td>
<td><code>dispRity</code></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>neighbours</code></td>
<td>The distance to specific neighbours (e.g. the nearest neighbours - by default)</td>
<td><code>dispRity</code></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>pairwise.dist</code></td>
<td>The pairwise distances between elements</td>
<td><a href="https://cran.r-project.org/web/packages/vegan/index.html"><code>vegan</code></a><code>::vegist</code></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>point.dist</code></td>
<td>The distance between one group and the point of another group</td>
<td><code>dispRity</code></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>projections.tree</code></td>
<td>The <code>projections</code> metric but where the vector can be based on a tree</td>
<td><code>dispRity</code></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>projections</code></td>
<td>The distance <em>on</em> (projection) or <em>from</em> (rejection) an arbitrary vector</td>
<td><code>dispRity</code></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>quantiles</code></td>
<td>The <em>n</em>th quantile range per axis</td>
<td><code>dispRity</code></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>radius</code></td>
<td>The radius of each dimensions</td>
<td><code>dispRity</code></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>ranges</code></td>
<td>The range of each dimension</td>
<td><code>dispRity</code></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>span.tree.length</code></td>
<td>The minimal spanning tree length</td>
<td><a href="https://cran.r-project.org/web/packages/vegan/index.html"><code>ape</code></a> (but see also <a href="https://cran.r-project.org/web/packages/vegan/index.html"><code>vegan</code></a><code>::spantree</code>)</td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>variances</code></td>
<td>The variance of each dimension</td>
<td><code>dispRity</code></td>
</tr>
</tbody>
</table>
<p>1: Note that by default, the centroid is the centroid of the elements.
It can, however, be fixed to a different value by using the <code>centroid</code> argument <code>centroids(space, centroid = rep(0, ncol(space)))</code>, for example the origin of the ordinated space.</p>
<p>2: This function uses an estimation of the eigenvalue that only works for MDS or PCoA ordinations (<em>not</em> PCA).</p>
<p>You can find more informations on the vast variety of metrics that you can use in your analysis in this <a href="https://www.biorxiv.org/content/10.1101/801571v1">preprint</a>.
<!-- biorXiv preprint --></p>
</div>
<div id="equations-and-implementations" class="section level3">
<h3><span class="header-section-number">4.4.6</span> Equations and implementations</h3>
<p>Some of the functions described below are implemented in the <code>dispRity</code> package and do not require any other packages to calculate (<a href="https://github.com/TGuillerme/dispRity/blob/master/R/dispRity.metric.R">see implementation here</a>).</p>
<p><span class="math display">\[\begin{equation}
    ancestral.dist = \sqrt{\sum_{i=1}^{n}{({d}_{n}-Ancestor_{n})^2}}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
    centroids = \sqrt{\sum_{i=1}^{n}{({d}_{n}-Centroid_{d})^2}}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
    diagonal = \sqrt{\sum_{i=1}^{d}|max(d_i) - min(k_i)|}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
    deviations = \frac{|Ax + By + ... + Nm + Intercept|}{\sqrt{A^2 + B^2 + ... + N^2}}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
    displacements = \frac{\sqrt{\sum_{i=1}^{n}{({d}_{n}-Reference_{d})^2}}}{\sqrt{\sum_{i=1}^{n}{({d}_{n}-Centroid_{k})^2}}}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
    ellipse.volume = \frac{\pi^{d/2}}{\Gamma(\frac{d}{2}+1)}\displaystyle\prod_{i=1}^{d} (\lambda_{i}^{0.5})
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
    n.ball.volume = \frac{\pi^{d/2}}{\Gamma(\frac{d}{2}+1)}\displaystyle\prod_{i=1}^{d} R
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
    projection_{on} = \| \overrightarrow{i} \cdot \overrightarrow{b} \|
\end{equation}\]</span>
<span class="math display">\[\begin{equation}
    projection_{from} = \| \overrightarrow{i} - \overrightarrow{i} \cdot \overrightarrow{b} \|
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
    radius = |\frac{\sum_{i=1}^{n}d_i}{n} - f(\mathbf{v}d)|
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
    ranges = |max(d_i) - min(d_i)|
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
    variances = \sigma^{2}{d_i}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
    span.tree.length = \mathrm{branch\ length}
\end{equation}\]</span></p>
<p>Where <em>d</em> is the number of dimensions,
<em>n</em> the number of elements,
<span class="math inline">\(\Gamma\)</span> is the Gamma distribution,
<span class="math inline">\(\lambda_i\)</span> is the eigenvalue of each dimensions,
<span class="math inline">\(\sigma^{2}\)</span> is their variance and
<span class="math inline">\(Centroid_{k}\)</span> is their mean,
<span class="math inline">\(Ancestor_{n}\)</span> is the coordinates of the ancestor of element <span class="math inline">\(n\)</span>,
<span class="math inline">\(f(\mathbf{v}k)\)</span> is function to select one value from the vector <span class="math inline">\(\mathbf{v}\)</span> of the dimension <span class="math inline">\(k\)</span> (e.g. it’s maximum, minimum, mean, etc.),
<em>R</em> is the radius of the sphere or the product of the radii of each dimensions (<span class="math inline">\(\displaystyle\prod_{i=1}^{k}R_{i}\)</span> - for a hyper-ellipsoid),
<span class="math inline">\(Reference_{k}\)</span> is an arbitrary point’s coordinates (usually 0),
<span class="math inline">\(\overrightarrow{b}\)</span> is the vector defined by (<code>(point1, point2)</code>),
and <span class="math inline">\(\overrightarrow{i}\)</span> is the vector defined by (<code>(point1, i)</code> where <code>i</code> is any row of the matrix).</p>
</div>
<div id="using-the-different-disparity-metrics" class="section level3">
<h3><span class="header-section-number">4.4.7</span> Using the different disparity metrics</h3>
<p>Here is a brief demonstration of the main metrics implemented in <code>dispRity</code>.
First, we will create a dummy/simulated ordinated space using the <code>space.maker</code> utility function (more about that <a href="#space.maker">here</a>:</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb118-1" data-line-number="1"><span class="co">## Creating a 10*5 normal space</span></a>
<a class="sourceLine" id="cb118-2" data-line-number="2"><span class="kw">set.seed</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb118-3" data-line-number="3">dummy_space &lt;-<span class="st"> </span><span class="kw">space.maker</span>(<span class="dv">10</span>, <span class="dv">5</span>, rnorm)</a>
<a class="sourceLine" id="cb118-4" data-line-number="4"><span class="kw">rownames</span>(dummy_space) &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span></a></code></pre></div>
<p>We will use this simulated space to demonstrate the different metrics.</p>
<div id="volumes-and-surface-metrics" class="section level4">
<h4><span class="header-section-number">4.4.7.1</span> Volumes and surface metrics</h4>
<p>The functions <code>ellipse.volume</code>, <code>convhull.surface</code>, <code>convhull.volume</code> and <code>n.ball.volume</code> all measure the surface or the volume of the ordinated space occupied:</p>
<p>Because there is only one subset (i.e. one matrix) in the dispRity object, the operations below are the equivalent of <code>metric(dummy_space)</code> (with rounding).</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb119-1" data-line-number="1"><span class="co">## Calculating the ellipsoid volume</span></a>
<a class="sourceLine" id="cb119-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> ellipse.volume))</a></code></pre></div>
<pre><code>##   subsets  n   obs
## 1       1 10 1.061</code></pre>
<blockquote>
<p>WARNING: in such dummy space, this gives the estimation of the ellipsoid volume, not the real ellipsoid volume! See the cautionary note in <code>?ellipse.volume</code>.</p>
</blockquote>
<div class="sourceCode" id="cb121"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb121-1" data-line-number="1"><span class="co">## Calculating the convex hull surface</span></a>
<a class="sourceLine" id="cb121-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> convhull.surface))</a></code></pre></div>
<pre><code>##   subsets  n   obs
## 1       1 10 11.91</code></pre>
<div class="sourceCode" id="cb123"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb123-1" data-line-number="1"><span class="co">## Calculating the convex hull volume</span></a>
<a class="sourceLine" id="cb123-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> convhull.volume))</a></code></pre></div>
<pre><code>##   subsets  n   obs
## 1       1 10 1.031</code></pre>
<div class="sourceCode" id="cb125"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb125-1" data-line-number="1"><span class="co">## Calculating the convex hull volume</span></a>
<a class="sourceLine" id="cb125-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> n.ball.volume))</a></code></pre></div>
<pre><code>##   subsets  n  obs
## 1       1 10 4.43</code></pre>
<p>The convex hull based functions are a call to the <code>geometry::convhulln</code> function with the <code>&quot;FA&quot;</code> option (computes total area and volume).
Also note that they are really sensitive to the size of the dataset.</p>
<blockquote>
<p>Cautionary note: measuring volumes in a high number of dimensions can be strongly affected by the <a href="https://en.wikipedia.org/wiki/Curse_of_dimensionality">curse of dimensionality</a> that often results in near 0 disparity values. I strongly recommend reading <a href="https://beta.observablehq.com/@tophtucker/theres-plenty-of-room-in-the-corners">this really intuitive explanation</a> from <a href="https://github.com/tophtucker">Toph Tucker</a>.</p>
</blockquote>
</div>
<div id="ranges-variances-quantiles-radius-pairwise-distance-neighbours-modal-value-and-diagonal" class="section level4">
<h4><span class="header-section-number">4.4.7.2</span> Ranges, variances, quantiles, radius, pairwise distance, neighbours, modal value and diagonal</h4>
<p>The functions <code>ranges</code>, <code>variances</code> <code>radius</code>, <code>pairwise.dist</code>, <code>mode.val</code> and <code>diagonal</code> all measure properties of the ordinated space based on its dimensional properties (they are also less affected by the “curse of dimensionality”):</p>
<p><code>ranges</code>, <code>variances</code> <code>quantiles</code> and <code>radius</code> work on the same principle and measure the range/variance/radius of each dimension:</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb127-1" data-line-number="1"><span class="co">## Calculating the ranges of each dimension in the ordinated space</span></a>
<a class="sourceLine" id="cb127-2" data-line-number="2"><span class="kw">ranges</span>(dummy_space)</a></code></pre></div>
<pre><code>## [1] 2.430909 3.726481 2.908329 2.735739 1.588603</code></pre>
<div class="sourceCode" id="cb129"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb129-1" data-line-number="1"><span class="co">## Calculating disparity as the distribution of these ranges</span></a>
<a class="sourceLine" id="cb129-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> ranges))</a></code></pre></div>
<pre><code>##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10      2.736 1.673 2.431 2.908 3.645</code></pre>
<div class="sourceCode" id="cb131"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb131-1" data-line-number="1"><span class="co">## Calculating disparity as the sum and the product of these ranges</span></a>
<a class="sourceLine" id="cb131-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> <span class="kw">c</span>(sum, ranges)))</a></code></pre></div>
<pre><code>##   subsets  n   obs
## 1       1 10 13.39</code></pre>
<div class="sourceCode" id="cb133"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb133-1" data-line-number="1"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> <span class="kw">c</span>(prod, ranges)))</a></code></pre></div>
<pre><code>##   subsets  n   obs
## 1       1 10 114.5</code></pre>
<div class="sourceCode" id="cb135"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb135-1" data-line-number="1"><span class="co">## Calculating the variances of each dimension in the</span></a>
<a class="sourceLine" id="cb135-2" data-line-number="2"><span class="co">## ordinated space</span></a>
<a class="sourceLine" id="cb135-3" data-line-number="3"><span class="kw">variances</span>(dummy_space)</a></code></pre></div>
<pre><code>## [1] 0.6093144 1.1438620 0.9131859 0.6537768 0.3549372</code></pre>
<div class="sourceCode" id="cb137"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb137-1" data-line-number="1"><span class="co">## Calculating disparity as the distribution of these variances</span></a>
<a class="sourceLine" id="cb137-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> variances))</a></code></pre></div>
<pre><code>##   subsets  n obs.median 2.5%   25%   75% 97.5%
## 1       1 10      0.654 0.38 0.609 0.913 1.121</code></pre>
<div class="sourceCode" id="cb139"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb139-1" data-line-number="1"><span class="co">## Calculating disparity as the sum and</span></a>
<a class="sourceLine" id="cb139-2" data-line-number="2"><span class="co">## the product of these variances</span></a>
<a class="sourceLine" id="cb139-3" data-line-number="3"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> <span class="kw">c</span>(sum, variances)))</a></code></pre></div>
<pre><code>##   subsets  n   obs
## 1       1 10 3.675</code></pre>
<div class="sourceCode" id="cb141"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb141-1" data-line-number="1"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> <span class="kw">c</span>(prod, variances)))</a></code></pre></div>
<pre><code>##   subsets  n   obs
## 1       1 10 0.148</code></pre>
<div class="sourceCode" id="cb143"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb143-1" data-line-number="1"><span class="co">## Calculating the quantiles of each dimension</span></a>
<a class="sourceLine" id="cb143-2" data-line-number="2"><span class="co">## in the ordinated space</span></a>
<a class="sourceLine" id="cb143-3" data-line-number="3"><span class="kw">quantiles</span>(dummy_space)</a></code></pre></div>
<pre><code>## [1] 2.234683 3.280911 2.760855 2.461077 1.559057</code></pre>
<div class="sourceCode" id="cb145"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb145-1" data-line-number="1"><span class="co">## Calculating disparity as the distribution of these variances</span></a>
<a class="sourceLine" id="cb145-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> quantiles))</a></code></pre></div>
<pre><code>##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10      2.461 1.627 2.235 2.761 3.229</code></pre>
<div class="sourceCode" id="cb147"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb147-1" data-line-number="1"><span class="co">## By default, the quantile calculated is the 95%</span></a>
<a class="sourceLine" id="cb147-2" data-line-number="2"><span class="co">## (i.e. 95% of the data on each axis)</span></a>
<a class="sourceLine" id="cb147-3" data-line-number="3"><span class="co">## this can be changed using the option quantile:</span></a>
<a class="sourceLine" id="cb147-4" data-line-number="4"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> quantiles, <span class="dt">quantile =</span> <span class="dv">50</span>))</a></code></pre></div>
<pre><code>##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10      0.967 0.899 0.951 0.991 1.089</code></pre>
<div class="sourceCode" id="cb149"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb149-1" data-line-number="1"><span class="co">## Calculating the radius of each dimension in the ordinated space</span></a>
<a class="sourceLine" id="cb149-2" data-line-number="2"><span class="kw">radius</span>(dummy_space)</a></code></pre></div>
<pre><code>## [1] 1.4630780 2.4635449 1.8556785 1.4977898 0.8416318</code></pre>
<div class="sourceCode" id="cb151"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb151-1" data-line-number="1"><span class="co">## By default the radius is the maximum distance from the centre of</span></a>
<a class="sourceLine" id="cb151-2" data-line-number="2"><span class="co">## the dimension. It can however be changed to any function:</span></a>
<a class="sourceLine" id="cb151-3" data-line-number="3"><span class="kw">radius</span>(dummy_space, <span class="dt">type =</span> min)</a></code></pre></div>
<pre><code>## [1] 0.05144054 0.14099827 0.02212226 0.17453525 0.23044528</code></pre>
<div class="sourceCode" id="cb153"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb153-1" data-line-number="1"><span class="kw">radius</span>(dummy_space, <span class="dt">type =</span> mean)</a></code></pre></div>
<pre><code>## [1] 0.6233501 0.7784888 0.7118713 0.6253263 0.5194332</code></pre>
<div class="sourceCode" id="cb155"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb155-1" data-line-number="1"><span class="co">## Calculating disparity as the mean average radius</span></a>
<a class="sourceLine" id="cb155-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space,</a>
<a class="sourceLine" id="cb155-3" data-line-number="3">                 <span class="dt">metric =</span> <span class="kw">c</span>(mean, radius),</a>
<a class="sourceLine" id="cb155-4" data-line-number="4">                 <span class="dt">type =</span> mean))</a></code></pre></div>
<pre><code>##   subsets  n   obs
## 1       1 10 0.652</code></pre>
<p>The pairwise distances and the neighbours distances uses the function <code>vegan::vegdist</code> and can take the normal <code>vegdist</code> options:</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb157-1" data-line-number="1"><span class="co">## The average pairwise euclidean distance</span></a>
<a class="sourceLine" id="cb157-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> <span class="kw">c</span>(mean, pairwise.dist)))</a></code></pre></div>
<pre><code>##   subsets  n   obs
## 1       1 10 2.539</code></pre>
<div class="sourceCode" id="cb159"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb159-1" data-line-number="1"><span class="co">## The distribution of the Manhattan distances</span></a>
<a class="sourceLine" id="cb159-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> pairwise.dist,</a>
<a class="sourceLine" id="cb159-3" data-line-number="3">                 <span class="dt">method =</span> <span class="st">&quot;manhattan&quot;</span>))</a></code></pre></div>
<pre><code>##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10      4.427 2.566 3.335 5.672  9.63</code></pre>
<div class="sourceCode" id="cb161"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb161-1" data-line-number="1"><span class="co">## The average nearest neighbour distances</span></a>
<a class="sourceLine" id="cb161-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> neighbours))</a></code></pre></div>
<pre><code>##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10      1.517 1.266 1.432 1.646 2.787</code></pre>
<div class="sourceCode" id="cb163"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb163-1" data-line-number="1"><span class="co">## The average furthest neighbour manhattan distances</span></a>
<a class="sourceLine" id="cb163-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> neighbours,</a>
<a class="sourceLine" id="cb163-3" data-line-number="3">                 <span class="dt">which =</span> max, <span class="dt">method =</span> <span class="st">&quot;manhattan&quot;</span>))</a></code></pre></div>
<pre><code>##   subsets  n obs.median 2.5%   25%   75% 97.5%
## 1       1 10      7.895 6.15 6.852 9.402 10.99</code></pre>
<p>Note that this function is a direct call to <code>vegan::vegdist(matrix, method = method, diag = FALSE, upper = FALSE, ...)</code>.</p>
<p>The <code>diagonal</code> function measures the multidimensional diagonal of the whole space (i.e. in our case the longest Euclidean distance in our five dimensional space).
The <code>mode.val</code> function measures the modal value of the matrix:</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb165-1" data-line-number="1"><span class="co">## Calculating the ordinated space&#39;s diagonal</span></a>
<a class="sourceLine" id="cb165-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> diagonal))</a></code></pre></div>
<pre><code>##   subsets  n   obs
## 1       1 10 3.659</code></pre>
<div class="sourceCode" id="cb167"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb167-1" data-line-number="1"><span class="co">## Calculating the modal value of the matrix</span></a>
<a class="sourceLine" id="cb167-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> mode.val))</a></code></pre></div>
<pre><code>##   subsets  n   obs
## 1       1 10 -2.21</code></pre>
<blockquote>
<p>This metric is only a Euclidean diagonal (mathematically valid) if the dimensions within the space are all orthogonal!</p>
</blockquote>
</div>
<div id="centroids" class="section level4">
<h4><span class="header-section-number">4.4.7.3</span> Centroids, displacements and ancestral distances metrics</h4>
<p>The <code>centroids</code> metric allows users to measure the position of the different elements compared to a fixed point in the ordinated space.
By default, this function measures the distance between each element and their centroid (centre point):</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb169-1" data-line-number="1"><span class="co">## The distribution of the distances between each element and their centroid</span></a>
<a class="sourceLine" id="cb169-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> centroids))</a></code></pre></div>
<pre><code>##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10      1.435 0.788 1.267 1.993 3.167</code></pre>
<div class="sourceCode" id="cb171"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb171-1" data-line-number="1"><span class="co">## Disparity as the median value of these distances</span></a>
<a class="sourceLine" id="cb171-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> <span class="kw">c</span>(median, centroids)))</a></code></pre></div>
<pre><code>##   subsets  n   obs
## 1       1 10 1.435</code></pre>
<p>It is however possible to fix the coordinates of the centroid to a specific point in the ordinated space, as long as it has the correct number of dimensions:</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb173-1" data-line-number="1"><span class="co">## The distance between each element and the origin</span></a>
<a class="sourceLine" id="cb173-2" data-line-number="2"><span class="co">## of the ordinated space</span></a>
<a class="sourceLine" id="cb173-3" data-line-number="3"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> centroids, <span class="dt">centroid =</span> <span class="dv">0</span>))</a></code></pre></div>
<pre><code>##   subsets  n obs.median  2.5% 25%   75% 97.5%
## 1       1 10      1.487 0.785 1.2 2.044 3.176</code></pre>
<div class="sourceCode" id="cb175"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb175-1" data-line-number="1"><span class="co">## Disparity as the distance between each element</span></a>
<a class="sourceLine" id="cb175-2" data-line-number="2"><span class="co">## and a specific point in space</span></a>
<a class="sourceLine" id="cb175-3" data-line-number="3"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> centroids,</a>
<a class="sourceLine" id="cb175-4" data-line-number="4">                 <span class="dt">centroid =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>)))</a></code></pre></div>
<pre><code>##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10      5.489 4.293 5.032 6.155 6.957</code></pre>
<p>If you have subsets in your <code>dispRity</code> object, you can also use the <code>matrix.dispRity</code> (see <a href="the-guts-of-the-disprity-package.html#utilities">utilities</a>) and <code>colMeans</code> to get the centre of a specific subgroup.
For example</p>
<div class="sourceCode" id="cb177"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb177-1" data-line-number="1"><span class="co">## Create a custom subsets object</span></a>
<a class="sourceLine" id="cb177-2" data-line-number="2">dummy_groups &lt;-<span class="st"> </span><span class="kw">custom.subsets</span>(dummy_space,</a>
<a class="sourceLine" id="cb177-3" data-line-number="3">                               <span class="dt">group =</span> <span class="kw">list</span>(<span class="st">&quot;group1&quot;</span> =<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">5</span>,</a>
<a class="sourceLine" id="cb177-4" data-line-number="4">                                            <span class="st">&quot;group2&quot;</span> =<span class="st"> </span><span class="dv">6</span><span class="op">:</span><span class="dv">10</span>))</a>
<a class="sourceLine" id="cb177-5" data-line-number="5"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_groups, <span class="dt">metric =</span> centroids,</a>
<a class="sourceLine" id="cb177-6" data-line-number="6">    <span class="dt">centroid =</span> <span class="kw">colMeans</span>(<span class="kw">matrix.dispRity</span>(dummy_groups, <span class="st">&quot;group1&quot;</span>))))</a></code></pre></div>
<pre><code>##   subsets n obs.median  2.5%   25%   75% 97.5%
## 1  group1 5      2.011 0.902 1.389 2.284 3.320
## 2  group2 5      1.362 0.760 1.296 1.505 1.985</code></pre>
<p>The <code>displacements</code> distance is the ratio between the <code>centroids</code> distance and the <code>centroids</code> distance with <code>centroid = 0</code>.
Note that it is possible to measure a ratio from another point than <code>0</code> using the <code>reference</code> argument.
It gives indication of the relative displacement of elements in the multidimensional space: a score &gt;1 signifies a displacement <em>away</em> from the reference. A score of &gt;1 signifies a displacement <em>towards</em> the reference.</p>
<div class="sourceCode" id="cb179"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb179-1" data-line-number="1"><span class="co">## The relative displacement of the group in space to the centre</span></a>
<a class="sourceLine" id="cb179-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> displacements))</a></code></pre></div>
<pre><code>##   subsets  n obs.median  2.5%   25% 75% 97.5%
## 1       1 10      1.014 0.841 0.925 1.1 1.205</code></pre>
<div class="sourceCode" id="cb181"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb181-1" data-line-number="1"><span class="co">## The relative displacement of the group to an arbitrary point</span></a>
<a class="sourceLine" id="cb181-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> displacements,</a>
<a class="sourceLine" id="cb181-3" data-line-number="3">                 <span class="dt">reference =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>)))</a></code></pre></div>
<pre><code>##   subsets  n obs.median  2.5%  25%   75% 97.5%
## 1       1 10      3.368 2.066 3.19 4.358 7.166</code></pre>
<p>The <code>ancestral.dist</code> metric works on a similar principle as the <code>centroids</code> function but changes the centroid to be the coordinates of each element’s ancestor (if <code>to.root = FALSE</code>; default) or to the root of the tree (<code>to.root = TRUE</code>).
Therefore this function needs a matrix that contains tips and nodes and a tree as additional argument.</p>
<div class="sourceCode" id="cb183"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb183-1" data-line-number="1"><span class="co">## A generating a random tree with node labels</span></a>
<a class="sourceLine" id="cb183-2" data-line-number="2">my_tree &lt;-<span class="st"> </span><span class="kw">makeNodeLabel</span>(<span class="kw">rtree</span>(<span class="dv">5</span>), <span class="dt">prefix =</span> <span class="st">&quot;n&quot;</span>)</a>
<a class="sourceLine" id="cb183-3" data-line-number="3"><span class="co">## Adding the tip and node names to the matrix</span></a>
<a class="sourceLine" id="cb183-4" data-line-number="4">dummy_space2 &lt;-<span class="st"> </span>dummy_space[<span class="op">-</span><span class="dv">1</span>,]</a>
<a class="sourceLine" id="cb183-5" data-line-number="5"><span class="kw">rownames</span>(dummy_space2) &lt;-<span class="st"> </span><span class="kw">c</span>(my_tree<span class="op">$</span>tip.label,</a>
<a class="sourceLine" id="cb183-6" data-line-number="6">                            my_tree<span class="op">$</span>node.label)</a>
<a class="sourceLine" id="cb183-7" data-line-number="7"></a>
<a class="sourceLine" id="cb183-8" data-line-number="8"><span class="co">## Calculating the distances from the ancestral nodes</span></a>
<a class="sourceLine" id="cb183-9" data-line-number="9">ancestral_dist &lt;-<span class="st"> </span><span class="kw">dispRity</span>(dummy_space2, <span class="dt">metric =</span> ancestral.dist,</a>
<a class="sourceLine" id="cb183-10" data-line-number="10">                           <span class="dt">tree =</span> my_tree)</a>
<a class="sourceLine" id="cb183-11" data-line-number="11"></a>
<a class="sourceLine" id="cb183-12" data-line-number="12"><span class="co">## The ancestral distances distributions</span></a>
<a class="sourceLine" id="cb183-13" data-line-number="13"><span class="kw">summary</span>(ancestral_dist)</a></code></pre></div>
<pre><code>##   subsets n obs.median  2.5%   25%   75% 97.5%
## 1       1 9      1.729 0.286 1.653 1.843 3.981</code></pre>
<div class="sourceCode" id="cb185"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb185-1" data-line-number="1"><span class="co">## Calculating disparity as the sum of the distances from all the ancestral nodes</span></a>
<a class="sourceLine" id="cb185-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(ancestral_dist, <span class="dt">metric =</span> sum))</a></code></pre></div>
<pre><code>##   subsets n   obs
## 1       1 9 17.28</code></pre>
</div>
<div id="minimal-spanning-tree-length" class="section level4">
<h4><span class="header-section-number">4.4.7.4</span> Minimal spanning tree length</h4>
<p>The <code>span.tree.length</code> uses the <code>vegan::spantree</code> function to heuristically calculate the minimum spanning tree (the shortest multidimensional tree connecting each elements) and calculates its length as the sum of every branch lengths.</p>
<div class="sourceCode" id="cb187"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb187-1" data-line-number="1"><span class="co">## The length of the minimal spanning tree</span></a>
<a class="sourceLine" id="cb187-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> <span class="kw">c</span>(sum, span.tree.length)))</a></code></pre></div>
<pre><code>##   subsets  n  obs
## 1       1 10 15.4</code></pre>
<p>Note that because the solution is heuristic, this metric can take a long time to compute for big matrices.</p>
</div>
<div id="functional-divergence-and-evenness" class="section level4">
<h4><span class="header-section-number">4.4.7.5</span> Functional divergence and evenness</h4>
<p>The <code>func.div</code> and <code>func.eve</code> functions are based on the <code>FD::dpFD</code> package.
They are the equivalent to <code>FD::dpFD(matrix)$FDiv</code> and <code>FD::dpFD(matrix)$FEve</code> but a bit faster (since they don’t deal with abundance data).
They are pretty straightforward to use:</p>
<div class="sourceCode" id="cb189"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb189-1" data-line-number="1"><span class="co">## The ratio of deviation from the centroid </span></a>
<a class="sourceLine" id="cb189-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> func.div))</a></code></pre></div>
<pre><code>##   subsets  n   obs
## 1       1 10 0.747</code></pre>
<div class="sourceCode" id="cb191"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb191-1" data-line-number="1"><span class="co">## The minimal spanning tree distances evenness</span></a>
<a class="sourceLine" id="cb191-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> func.eve))</a></code></pre></div>
<pre><code>##   subsets  n   obs
## 1       1 10 0.898</code></pre>
<div class="sourceCode" id="cb193"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb193-1" data-line-number="1"><span class="co">## The minimal spanning tree manhanttan distances evenness</span></a>
<a class="sourceLine" id="cb193-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> func.eve,</a>
<a class="sourceLine" id="cb193-3" data-line-number="3">                 <span class="dt">method =</span> <span class="st">&quot;manhattan&quot;</span>))</a></code></pre></div>
<pre><code>##   subsets  n   obs
## 1       1 10 0.913</code></pre>
</div>
<div id="orientation-angles-and-deviations" class="section level4">
<h4><span class="header-section-number">4.4.7.6</span> Orientation: angles and deviations</h4>
<p>The <code>angles</code> performs a least square regression (via the <code>lm</code> function) and returns slope of the main axis of variation for each dimension. This slope can be converted into different units, <code>&quot;slope&quot;</code>, <code>&quot;degree&quot;</code> (the default) and <code>&quot;radian&quot;</code>. This can be changed through the <code>unit</code> argument.
By default, the angle is measured from the slope 0 (the horizontal line in a 2D plot) but this can be changed through the <code>base</code> argument (using the defined <code>unit</code>):</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb195-1" data-line-number="1"><span class="co">## The distribution of each angles in degrees for each</span></a>
<a class="sourceLine" id="cb195-2" data-line-number="2"><span class="co">## main axis in the matrix</span></a>
<a class="sourceLine" id="cb195-3" data-line-number="3"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> angles))</a></code></pre></div>
<pre><code>##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10      21.26 -39.8 3.723 39.47    56</code></pre>
<div class="sourceCode" id="cb197"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb197-1" data-line-number="1"><span class="co">## The distribution of slopes deviating from the 1:1 slope:</span></a>
<a class="sourceLine" id="cb197-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> angles, <span class="dt">unit =</span> <span class="st">&quot;slope&quot;</span>,</a>
<a class="sourceLine" id="cb197-3" data-line-number="3">                 <span class="dt">base =</span> <span class="dv">1</span>))</a></code></pre></div>
<pre><code>##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10      1.389 0.118 1.065 1.823 2.514</code></pre>
<p>The <code>deviations</code> function is based on a similar algorithm as above but measures the deviation from the main axis (or hyperplane) of variation.
In other words, it finds the least square line (for a 2D dataset), plane (for a 3D dataset) or hyperplane (for a &gt;3D dataset) and measures the shortest distances between every points and the line/plane/hyperplane.
By default, the hyperplane is fitted using the least square algorithm from <code>stats::glm</code>:</p>
<div class="sourceCode" id="cb199"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb199-1" data-line-number="1"><span class="co">## The distribution of the deviation of each point</span></a>
<a class="sourceLine" id="cb199-2" data-line-number="2"><span class="co">## from the least square hyperplane</span></a>
<a class="sourceLine" id="cb199-3" data-line-number="3"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> deviations))</a></code></pre></div>
<pre><code>##   subsets  n obs.median 2.5%   25%   75% 97.5%
## 1       1 10      0.274 0.02 0.236 0.453 0.776</code></pre>
<p>It is also possible to specify the hyperplane equation through the <code>hyperplane</code> equation. The equation must contain the intercept first and then all the slopes and is interpreted as <span class="math inline">\(intercept + Ax + By + ... + Nd = 0\)</span>. For example, a 2 line defined as beta + intercept (e.g. <span class="math inline">\(y = 2x + 1\)</span>) should be defined as <code>hyperplane = c(1, 2, 1)</code> (<span class="math inline">\(2x - y + 1 = 0\)</span>).</p>
<div class="sourceCode" id="cb201"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb201-1" data-line-number="1"><span class="co">## The distribution of the deviation of each point</span></a>
<a class="sourceLine" id="cb201-2" data-line-number="2"><span class="co">## from a slope (with only the two first dimensions)</span></a>
<a class="sourceLine" id="cb201-3" data-line-number="3"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space[, <span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>)], <span class="dt">metric =</span> deviations,</a>
<a class="sourceLine" id="cb201-4" data-line-number="4">                 <span class="dt">hyperplane =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">-1</span>)))</a></code></pre></div>
<pre><code>##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10      0.516 0.038 0.246 0.763  2.42</code></pre>
<p>Since both the functions <code>angles</code> and <code>deviations</code> effectively run a <code>lm</code> or <code>glm</code> to estimate slopes or hyperplanes, it is possible to use the option <code>significant = TRUE</code> to only consider slopes or intercepts that have a slope significantly different than zero using an <code>aov</code> with a significant threshold of <span class="math inline">\(p = 0.05\)</span>.
Note that depending on your dataset, using and <code>aov</code> could be completely inappropriate!
In doubt, it’s probably better to enter your <code>base</code> (for <code>angles</code>) or your <code>hyperplane</code> (for <code>deviations</code>) manually so you’re sure you know what the function is measuring.</p>
</div>
<div id="projections-and-phylo-projections-elaboration-and-exploration" class="section level4">
<h4><span class="header-section-number">4.4.7.7</span> Projections and phylo projections: elaboration and exploration</h4>
<p>The <code>projections</code> metric calculates the geometric projection and corresponding rejection of all the rows in a matrix on an arbitrary vector (respectively the distance <em>on</em> and the distance <em>from</em> that vector). The function is based on <span class="citation">Aguilera and Pérez-Aguila (<a href="#ref-aguilera2004">2004</a>)</span>’s n-dimensional rotation algorithm to use linear algebra in mutidimensional spaces. The projection or rejection can be seen as respectively the elaboration and exploration scores on a trajectory (<em>sensu</em> <span class="citation">Endler et al. (<a href="#ref-endler2005">2005</a>)</span>).</p>
<p>By default, the vector (e.g. a trajectory, an axis), on which the data is projected is the one going from the centre of the space (coordinates 0,0, …) and the centroid of the matrix.
However, we advice you do define this axis to something more meaningful using the <code>point1</code> and <code>point2</code> options, to create the vector (the vector’s norm will be <code>dist(point1, point2)</code> and its direction will be from <code>point1</code> towards <code>point2</code>).</p>
<div class="sourceCode" id="cb203"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb203-1" data-line-number="1"><span class="co">## The elaboration on the axis defined by the first and</span></a>
<a class="sourceLine" id="cb203-2" data-line-number="2"><span class="co">## second row in the dummy_space</span></a>
<a class="sourceLine" id="cb203-3" data-line-number="3"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> projections,</a>
<a class="sourceLine" id="cb203-4" data-line-number="4">                              <span class="dt">point1 =</span> dummy_space[<span class="dv">1</span>,],</a>
<a class="sourceLine" id="cb203-5" data-line-number="5">                              <span class="dt">point2 =</span> dummy_space[<span class="dv">2</span>,]))</a></code></pre></div>
<pre><code>##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10      0.998 0.118 0.651 1.238 1.885</code></pre>
<div class="sourceCode" id="cb205"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb205-1" data-line-number="1"><span class="co">## The exploration on the same axis</span></a>
<a class="sourceLine" id="cb205-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> projections,</a>
<a class="sourceLine" id="cb205-3" data-line-number="3">                              <span class="dt">point1 =</span> dummy_space[<span class="dv">1</span>,],</a>
<a class="sourceLine" id="cb205-4" data-line-number="4">                              <span class="dt">point2 =</span> dummy_space[<span class="dv">2</span>,],</a>
<a class="sourceLine" id="cb205-5" data-line-number="5">                              <span class="dt">measure =</span> <span class="st">&quot;distance&quot;</span>))</a></code></pre></div>
<pre><code>##   subsets  n obs.median 2.5%   25%   75% 97.5%
## 1       1 10      0.719    0 0.568 0.912  1.65</code></pre>
<p>By default, the vector <code>(point1, point2)</code> is used as unit vector of the projections (i.e. the Euclidean distance between <code>(point1, point2)</code> is set to 1) meaning that a projection value (<code>&quot;distance&quot;</code> or <code>&quot;position&quot;</code>) of <em>X</em> means <em>X</em> times the distance between <code>point1</code> and <code>point2</code>.
If you want use the unit vector of the input matrix or are using a space where Euclidean distances are non-sensical, you can remove this option using <code>scale = FALSE</code>:</p>
<div class="sourceCode" id="cb207"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb207-1" data-line-number="1"><span class="co">## The elaboration on the same axis using the dummy_space&#39;s</span></a>
<a class="sourceLine" id="cb207-2" data-line-number="2"><span class="co">## unit vector</span></a>
<a class="sourceLine" id="cb207-3" data-line-number="3"><span class="kw">summary</span>(<span class="kw">dispRity</span>(dummy_space, <span class="dt">metric =</span> projections,</a>
<a class="sourceLine" id="cb207-4" data-line-number="4">                              <span class="dt">point1 =</span> dummy_space[<span class="dv">1</span>,],</a>
<a class="sourceLine" id="cb207-5" data-line-number="5">                              <span class="dt">point2 =</span> dummy_space[<span class="dv">2</span>,],</a>
<a class="sourceLine" id="cb207-6" data-line-number="6">                              <span class="dt">scale =</span> <span class="ot">FALSE</span>))</a></code></pre></div>
<pre><code>##   subsets  n obs.median  2.5%   25%  75% 97.5%
## 1       1 10      4.068 0.481 2.655 5.05 7.685</code></pre>
<p>The <code>projections.tree</code> is the same as the <code>projections</code> metric but allows to determine the vector (<code>(point1, point2)</code>) using a tree rather than manually entering these points.
The function intakes the exact same options as the <code>projections</code> function described above at the exception of <code>point1</code> and <code>point2</code>.
Instead it takes a the argument <code>type</code> that designates the type of vector to draw from the data based on a phylogenetic tree <code>phy</code>.
The argument <code>type</code> can be a pair of any of the following inputs:</p>
<ul>
<li><code>&quot;root&quot;</code>: to automatically use the coordinates of the root of the tree (the first element in <code>phy$node.label</code>);</li>
<li><code>&quot;ancestor&quot;</code>: to automatically use the coordinates of the elements’ (i.e. any row in the matrix) most recent ancestor;</li>
<li><code>&quot;tips&quot;</code>: to automatically use the coordinates from the centroid of all tips;</li>
<li><code>&quot;nodes&quot;</code>: to automatically use the coordinates from the centroid of all nodes;</li>
<li><code>&quot;livings&quot;</code>: to automatically use the coordinates from the centroid of all “living” tips (i.e. the tips that are the furthest away from the root);</li>
<li><code>&quot;fossils&quot;</code>: to automatically use the coordinates from the centroid of all “fossil” tips and nodes (i.e. not the “living” ones);</li>
<li>any numeric values that can be interpreted as <code>point1</code> and <code>point2</code> in <code>projections</code> (e.g. <code>0</code>, <code>c(0, 1.2, 3/4)</code>, etc.);</li>
<li>or a user defined function that with the inputs <code>matrix</code> and <code>phy</code> and <code>row</code> (the element’s ID, i.e. the row number in <code>matrix</code>).</li>
</ul>
<p>For example, if you want to measure the projection of each element in the matrix (tips and nodes) on the axis from the root of the tree to each element’s most recent ancestor, you can define the vector as <code>type = c(&quot;root&quot;, &quot;ancestor&quot;)</code>.</p>
<div class="sourceCode" id="cb209"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb209-1" data-line-number="1"><span class="co">## Adding a extra row to dummy matrix (to match dummy_tree)</span></a>
<a class="sourceLine" id="cb209-2" data-line-number="2">tree_space &lt;-<span class="st"> </span><span class="kw">rbind</span>(dummy_space, <span class="dt">root =</span> <span class="kw">rnorm</span>(<span class="dv">5</span>))</a>
<a class="sourceLine" id="cb209-3" data-line-number="3"><span class="co">## Creating a random dummy tree (with labels matching the ones from tree_space)</span></a>
<a class="sourceLine" id="cb209-4" data-line-number="4">dummy_tree &lt;-<span class="st"> </span><span class="kw">rtree</span>(<span class="dv">6</span>)</a>
<a class="sourceLine" id="cb209-5" data-line-number="5">dummy_tree<span class="op">$</span>tip.label &lt;-<span class="st"> </span><span class="kw">rownames</span>(tree_space)[<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>]</a>
<a class="sourceLine" id="cb209-6" data-line-number="6">dummy_tree<span class="op">$</span>node.label &lt;-<span class="st"> </span><span class="kw">rownames</span>(tree_space)[<span class="kw">rev</span>(<span class="dv">7</span><span class="op">:</span><span class="dv">11</span>)]</a>
<a class="sourceLine" id="cb209-7" data-line-number="7"></a>
<a class="sourceLine" id="cb209-8" data-line-number="8"><span class="co">## Measuring the disparity as the projection of each element</span></a>
<a class="sourceLine" id="cb209-9" data-line-number="9"><span class="co">## on its root-ancestor vector</span></a>
<a class="sourceLine" id="cb209-10" data-line-number="10"><span class="kw">summary</span>(<span class="kw">dispRity</span>(tree_space, <span class="dt">metric =</span> projections.tree,</a>
<a class="sourceLine" id="cb209-11" data-line-number="11">                             <span class="dt">tree   =</span> dummy_tree,</a>
<a class="sourceLine" id="cb209-12" data-line-number="12">                             <span class="dt">type   =</span> <span class="kw">c</span>(<span class="st">&quot;root&quot;</span>, <span class="st">&quot;ancestor&quot;</span>)))</a></code></pre></div>
<pre><code>## Warning in max(nchar(round(column)), na.rm = TRUE): no non-missing arguments to
## max; returning -Inf

## Warning in max(nchar(round(column)), na.rm = TRUE): no non-missing arguments to
## max; returning -Inf</code></pre>
<pre><code>##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 11         NA 0.229 0.416 0.712 1.016</code></pre>
<p>Of course you can also use any other options from the projections function:</p>
<div class="sourceCode" id="cb212"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb212-1" data-line-number="1"><span class="co">## A user defined function that&#39;s returns the centroid of</span></a>
<a class="sourceLine" id="cb212-2" data-line-number="2"><span class="co">## the first three nodes</span></a>
<a class="sourceLine" id="cb212-3" data-line-number="3">fun.root &lt;-<span class="st"> </span><span class="cf">function</span>(matrix, tree, <span class="dt">row =</span> <span class="ot">NULL</span>) {</a>
<a class="sourceLine" id="cb212-4" data-line-number="4">  <span class="kw">return</span>(<span class="kw">colMeans</span>(matrix[tree<span class="op">$</span>node.label[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>], ]))</a>
<a class="sourceLine" id="cb212-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb212-6" data-line-number="6"><span class="co">## Measuring the unscaled rejection from the vector from the</span></a>
<a class="sourceLine" id="cb212-7" data-line-number="7"><span class="co">## centroid of the three first nodes</span></a>
<a class="sourceLine" id="cb212-8" data-line-number="8"><span class="co">## to the coordinates of the first tip</span></a>
<a class="sourceLine" id="cb212-9" data-line-number="9"><span class="kw">summary</span>(<span class="kw">dispRity</span>(tree_space, <span class="dt">metric  =</span> projections.tree,</a>
<a class="sourceLine" id="cb212-10" data-line-number="10">                             <span class="dt">tree    =</span> dummy_tree,</a>
<a class="sourceLine" id="cb212-11" data-line-number="11">                             <span class="dt">measure =</span> <span class="st">&quot;distance&quot;</span>,</a>
<a class="sourceLine" id="cb212-12" data-line-number="12">                             <span class="dt">type    =</span> <span class="kw">list</span>(fun.root,</a>
<a class="sourceLine" id="cb212-13" data-line-number="13">                                            tree_space[<span class="dv">1</span>, ])))</a></code></pre></div>
<pre><code>##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 11      0.606 0.064 0.462 0.733 0.999</code></pre>
</div>
<div id="betweengroupmetricslist" class="section level4">
<h4><span class="header-section-number">4.4.7.8</span> Between group metrics</h4>
<p>You can find detailed explanation on how between group metrics work <a href="details-of-specific-functions.html#betweengroupmetricsexplain">here</a>.</p>
<div id="group.dist" class="section level5">
<h5><span class="header-section-number">4.4.7.8.1</span> <code>group.dist</code></h5>
<p>The <code>group.dist</code> metric allows to measure the distance between two groups in the multidimensional space.
This function needs to intake several groups and use the option <code>between.groups = TRUE</code> in the <code>dispRity</code> function.
It calculates the vector normal distance (euclidean) between two groups and returns 0 if that distance is negative.
Note that it is possible to set up which quantiles to consider for calculating the distances between groups.
For example, one might be interested in only considering the 95% CI for each group.
This can be done through the option <code>probs = c(0.025, 0.975)</code> that is passed to the <code>quantile</code> function.
It is also possible to use this function to measure the distance between the groups centroids by calculating the 50% quantile (<code>probs = c(0.5)</code>).</p>
<div class="sourceCode" id="cb214"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb214-1" data-line-number="1"><span class="co">## Creating a dispRity object with two groups</span></a>
<a class="sourceLine" id="cb214-2" data-line-number="2">grouped_space &lt;-<span class="st"> </span><span class="kw">custom.subsets</span>(dummy_space,</a>
<a class="sourceLine" id="cb214-3" data-line-number="3">                      <span class="dt">group =</span> <span class="kw">list</span>(<span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>), <span class="kw">c</span>(<span class="dv">6</span><span class="op">:</span><span class="dv">10</span>)))</a>
<a class="sourceLine" id="cb214-4" data-line-number="4"></a>
<a class="sourceLine" id="cb214-5" data-line-number="5"><span class="co">## Measuring the minimum distance between both groups</span></a>
<a class="sourceLine" id="cb214-6" data-line-number="6"><span class="kw">summary</span>(<span class="kw">dispRity</span>(grouped_space, <span class="dt">metric =</span> group.dist,</a>
<a class="sourceLine" id="cb214-7" data-line-number="7">                 <span class="dt">between.groups =</span> <span class="ot">TRUE</span>))</a></code></pre></div>
<pre><code>##   subsets n_1 n_2 obs
## 1     1:2   5   5   0</code></pre>
<div class="sourceCode" id="cb216"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb216-1" data-line-number="1"><span class="co">## Measuring the centroid distance between both groups</span></a>
<a class="sourceLine" id="cb216-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(grouped_space, <span class="dt">metric =</span> group.dist,</a>
<a class="sourceLine" id="cb216-3" data-line-number="3">                 <span class="dt">between.groups =</span> <span class="ot">TRUE</span>, <span class="dt">probs =</span> <span class="fl">0.5</span>))</a></code></pre></div>
<pre><code>##   subsets n_1 n_2   obs
## 1     1:2   5   5 0.708</code></pre>
<div class="sourceCode" id="cb218"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb218-1" data-line-number="1"><span class="co">## Measuring the distance between both group&#39;s 75% CI</span></a>
<a class="sourceLine" id="cb218-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(grouped_space, <span class="dt">metric =</span> group.dist,</a>
<a class="sourceLine" id="cb218-3" data-line-number="3">                 <span class="dt">between.groups =</span> <span class="ot">TRUE</span>, <span class="dt">probs =</span> <span class="kw">c</span>(<span class="fl">0.25</span>, <span class="fl">0.75</span>)))</a></code></pre></div>
<pre><code>##   subsets n_1 n_2   obs
## 1     1:2   5   5 0.059</code></pre>
</div>
<div id="point.dist" class="section level5">
<h5><span class="header-section-number">4.4.7.8.2</span> <code>point.dist</code></h5>
<p>The metric measures the distance between the elements in one group (<code>matrix</code>) and a point calculated from a second group (<code>matrix2</code>).
By default this point is the centroid but can be any point defined by a function passed to the <code>point</code> argument.
For example, the centroid of <code>matrix2</code> is the mean of each column of that matrix so <code>point = colMeans</code> (default).
This function also takes the <code>method</code> argument like previous one described above to measure either the <code>&quot;euclidean&quot;</code> (default) or the <code>&quot;manhattan&quot;</code> distances:</p>
<div class="sourceCode" id="cb220"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb220-1" data-line-number="1"><span class="co">## Measuring the distance between the elements of the first group</span></a>
<a class="sourceLine" id="cb220-2" data-line-number="2"><span class="co">## and the centroid of the second group</span></a>
<a class="sourceLine" id="cb220-3" data-line-number="3"><span class="kw">summary</span>(<span class="kw">dispRity</span>(grouped_space, <span class="dt">metric =</span> point.dist,</a>
<a class="sourceLine" id="cb220-4" data-line-number="4">                 <span class="dt">between.groups =</span> <span class="ot">TRUE</span>))</a></code></pre></div>
<pre><code>##   subsets n_1 n_2 obs.median  2.5%   25%   75% 97.5%
## 1     1:2   5   5      2.182 1.304 1.592 2.191 3.355</code></pre>
<div class="sourceCode" id="cb222"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb222-1" data-line-number="1"><span class="co">## Measuring the distance between the elements of the second group</span></a>
<a class="sourceLine" id="cb222-2" data-line-number="2"><span class="co">## and the centroid of the first group</span></a>
<a class="sourceLine" id="cb222-3" data-line-number="3"><span class="kw">summary</span>(<span class="kw">dispRity</span>(grouped_space, <span class="dt">metric =</span> point.dist,</a>
<a class="sourceLine" id="cb222-4" data-line-number="4">                 <span class="dt">between.groups =</span> <span class="kw">list</span>(<span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">1</span>))))</a></code></pre></div>
<pre><code>##   subsets n_1 n_2 obs.median 2.5%   25%   75% 97.5%
## 1     2:1   5   5      1.362 0.76 1.296 1.505 1.985</code></pre>
<div class="sourceCode" id="cb224"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb224-1" data-line-number="1"><span class="co">## Measuring the distance between the elements of the first group</span></a>
<a class="sourceLine" id="cb224-2" data-line-number="2"><span class="co">## a point defined as the standard deviation of each column</span></a>
<a class="sourceLine" id="cb224-3" data-line-number="3"><span class="co">## in the second group</span></a>
<a class="sourceLine" id="cb224-4" data-line-number="4">sd.point &lt;-<span class="st"> </span><span class="cf">function</span>(matrix2) {<span class="kw">apply</span>(matrix2, <span class="dv">2</span>, sd)}</a>
<a class="sourceLine" id="cb224-5" data-line-number="5"><span class="kw">summary</span>(<span class="kw">dispRity</span>(grouped_space, <span class="dt">metric =</span> point.dist,</a>
<a class="sourceLine" id="cb224-6" data-line-number="6">                 <span class="dt">point =</span> sd.point, <span class="dt">method =</span> <span class="st">&quot;manhattan&quot;</span>,</a>
<a class="sourceLine" id="cb224-7" data-line-number="7">                 <span class="dt">between.groups =</span> <span class="ot">TRUE</span>))</a></code></pre></div>
<pre><code>##   subsets n_1 n_2 obs.median  2.5%   25%   75% 97.5%
## 1     1:2   5   5      4.043 2.467 3.567 4.501 6.884</code></pre>
</div>
</div>
</div>
<div id="which-disparity-metric-to-choose" class="section level3">
<h3><span class="header-section-number">4.4.8</span> Which disparity metric to choose?</h3>
<p>The disparity metric that gives the most consistent results is the following one:</p>
<div class="sourceCode" id="cb226"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb226-1" data-line-number="1">best.metric &lt;-<span class="st"> </span><span class="cf">function</span>() <span class="kw">return</span>(<span class="dv">42</span>)</a></code></pre></div>
<p>Joke aside, this is a legitimate question that has no simple answer: <strong>it depends on the dataset and question at hand</strong>.
Thoughts on which metric to choose can be find in <span class="citation">Thomas Guillerme, Puttick, et al. (<a href="#ref-moms">2020</a>)</span> and <span class="citation">Thomas Guillerme, Cooper, et al. (<a href="#ref-Guillerme2020">2020</a>)</span> but again, will ultimately depend on the question and dataset.
The question should help figuring out which type of metric is desired: for example, in the question “does the extinction released niches for mammals to evolve”, the metric in interest should probably pick up a change in size in the trait space (the release could result in some expansion of the mammalian morphospace); or if the question is “does group X compete with group Y”, maybe the metric of interested should pick up changes in position (group X can be displaced by group Y).</p>
<p>In order to visualise what signal different disparity metrics are picking, you can use the <a href="https://tguillerme.shinyapps.io/moms/"><code>moms</code></a> that come with a detailed <a href="https://rawcdn.githack.com/TGuillerme/moms/master/inst/moms_vignette.html">manual</a> on how to use it.</p>
<p>Alternatively, you can use the <code>test.metric</code> function:</p>
<div id="test-metric" class="section level4">
<h4><span class="header-section-number">4.4.8.1</span> <code>test.metric</code></h4>
<p>This function allows to test whether a metric picks different changes in disparity. It intakes the space on which to test the metric, the disparity metric and the type of changes to apply gradually to the space.
Basically this is a type of biased data rarefaction (or non-biased for <code>&quot;random&quot;</code>) to see how the metric reacts to specific changes in trait space.</p>
<div class="sourceCode" id="cb227"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb227-1" data-line-number="1"><span class="co"># Creating a 2D uniform space</span></a>
<a class="sourceLine" id="cb227-2" data-line-number="2">example_space &lt;-<span class="st"> </span><span class="kw">space.maker</span>(<span class="dv">300</span>, <span class="dv">2</span>, runif)</a>
<a class="sourceLine" id="cb227-3" data-line-number="3"></a>
<a class="sourceLine" id="cb227-4" data-line-number="4"><span class="co">## Testing the product of ranges metric on the example space</span></a>
<a class="sourceLine" id="cb227-5" data-line-number="5">example_test &lt;-<span class="st"> </span><span class="kw">test.metric</span>(example_space, <span class="dt">metric =</span> <span class="kw">c</span>(prod, ranges),</a>
<a class="sourceLine" id="cb227-6" data-line-number="6">                           <span class="dt">shifts =</span> <span class="kw">c</span>(<span class="st">&quot;random&quot;</span>, <span class="st">&quot;size&quot;</span>)) </a></code></pre></div>
<p>By default, the test runs three replicates of space reduction as described in <span class="citation">Thomas Guillerme, Puttick, et al. (<a href="#ref-moms">2020</a>)</span> by gradually removing 10% of the data points following the different algorithms from <span class="citation">Thomas Guillerme, Puttick, et al. (<a href="#ref-moms">2020</a>)</span> (here the <code>&quot;random&quot;</code> reduction and the <code>&quot;size&quot;</code>) reduction, resulting in a <code>dispRity</code> object that can be summarised or plotted.
The number of replicates can be changed using the <code>replicates</code> option.
Still by default, the function then runs a linear model on the simulated data to measure some potential trend in the changes in disparity.
The model can be changed using the <code>model</code> option.
Finally, the function runs 10 reductions by default from keeping 10% of the data (removing 90%) and way up to keeping 100% of the data (removing 0%).
This can be changed using the <code>steps</code> option.
A good disparity metric for your dataset will typically have no trend in the <code>&quot;random&quot;</code> reduction (the metric is ideally not affected by sample size) but should have a trend for the reduction of interest.</p>
<div class="sourceCode" id="cb228"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb228-1" data-line-number="1"><span class="co">## The results as a dispRity object</span></a>
<a class="sourceLine" id="cb228-2" data-line-number="2">example_test</a></code></pre></div>
<pre><code>## Metric testing:
## The following metric was tested: c(prod, ranges).
## The test was run on the random, size shifts for 3 replicates using the following model:
## lm(disparity ~ reduction, data = data)
## Use summary(x) or plot(x) for more details.</code></pre>
<div class="sourceCode" id="cb230"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb230-1" data-line-number="1"><span class="co">## Summarising these results</span></a>
<a class="sourceLine" id="cb230-2" data-line-number="2"><span class="kw">summary</span>(example_test)</a></code></pre></div>
<pre><code>## Warning in summary.lm(model): essentially perfect fit: summary may be unreliable

## Warning in summary.lm(model): essentially perfect fit: summary may be unreliable

## Warning in summary.lm(model): essentially perfect fit: summary may be unreliable</code></pre>
<pre><code>##             10%  20%  30%  40%  50%  60%  70%  80%  90% 100%         slope
## random     0.91 0.90 0.96 0.98 0.97 0.97 0.98 0.98 0.98 0.98  8.149128e-04
## size.inner 0.09 0.22 0.31 0.44 0.59 0.67 0.79 0.93 0.97 0.98  1.057142e-02
## size.outer 0.98 0.98 0.98 0.98 0.98 0.98 0.98 0.98 0.98 0.98 -4.422503e-18
##                 p_value  R^2(adj)
## random     4.530491e-05 0.4340055
## size.inner 2.353746e-25 0.9793579
## size.outer 1.188240e-01 0.4780089</code></pre>
<div class="sourceCode" id="cb233"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb233-1" data-line-number="1"><span class="co">## Or visualising them</span></a>
<a class="sourceLine" id="cb233-2" data-line-number="2"><span class="kw">plot</span>(example_test)</a></code></pre></div>
<pre><code>## Warning in summary.lm(model): essentially perfect fit: summary may be unreliable

## Warning in summary.lm(model): essentially perfect fit: summary may be unreliable</code></pre>
<p><img src="dispRity_manual_files/figure-html/unnamed-chunk-69-1.png" width="576" /></p>
</div>
</div>
</div>
<div id="summarising-disprity-data-plots" class="section level2">
<h2><span class="header-section-number">4.5</span> Summarising dispRity data (plots)</h2>
<p>Because of its architecture, printing <code>dispRity</code> objects only summarises their content but does not print the disparity value measured or associated analysis (more about this <a href="#manipulating-dispRity-objects">here</a>).
To actually see what is in a dispRity object, one can either use the <code>summary</code> function for visualising the data in a table or <code>plot</code> to have a graphical representation of the results.</p>
<div id="summarising-disprity-data" class="section level3">
<h3><span class="header-section-number">4.5.1</span> Summarising <code>dispRity</code> data</h3>
<p>This function is an S3 function (<code>summary.dispRity</code>) allowing users to summarise the content of <code>dispRity</code> objects that contain disparity calculations.</p>
<div class="sourceCode" id="cb235"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb235-1" data-line-number="1"><span class="co">## Example data from previous sections</span></a>
<a class="sourceLine" id="cb235-2" data-line-number="2">crown_stem &lt;-<span class="st"> </span><span class="kw">custom.subsets</span>(BeckLee_mat50,</a>
<a class="sourceLine" id="cb235-3" data-line-number="3">                             <span class="dt">group =</span> <span class="kw">crown.stem</span>(BeckLee_tree,</a>
<a class="sourceLine" id="cb235-4" data-line-number="4">                             <span class="dt">inc.nodes =</span> <span class="ot">FALSE</span>))</a>
<a class="sourceLine" id="cb235-5" data-line-number="5"><span class="co">## Bootstrapping and rarefying these groups</span></a>
<a class="sourceLine" id="cb235-6" data-line-number="6">boot_crown_stem &lt;-<span class="st"> </span><span class="kw">boot.matrix</span>(crown_stem, <span class="dt">bootstraps =</span> <span class="dv">100</span>,</a>
<a class="sourceLine" id="cb235-7" data-line-number="7">                               <span class="dt">rarefaction =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb235-8" data-line-number="8"><span class="co">## Calculate disparity</span></a>
<a class="sourceLine" id="cb235-9" data-line-number="9">disparity_crown_stem &lt;-<span class="st"> </span><span class="kw">dispRity</span>(boot_crown_stem,</a>
<a class="sourceLine" id="cb235-10" data-line-number="10">                                 <span class="dt">metric =</span> <span class="kw">c</span>(sum, variances))</a>
<a class="sourceLine" id="cb235-11" data-line-number="11"></a>
<a class="sourceLine" id="cb235-12" data-line-number="12"><span class="co">## Creating time slice subsets</span></a>
<a class="sourceLine" id="cb235-13" data-line-number="13">time_slices &lt;-<span class="st"> </span><span class="kw">chrono.subsets</span>(<span class="dt">data =</span> BeckLee_mat99,</a>
<a class="sourceLine" id="cb235-14" data-line-number="14">                              <span class="dt">tree =</span> BeckLee_tree,</a>
<a class="sourceLine" id="cb235-15" data-line-number="15">                              <span class="dt">method =</span> <span class="st">&quot;continuous&quot;</span>,</a>
<a class="sourceLine" id="cb235-16" data-line-number="16">                              <span class="dt">model =</span> <span class="st">&quot;proximity&quot;</span>,</a>
<a class="sourceLine" id="cb235-17" data-line-number="17">                              <span class="dt">time =</span> <span class="kw">c</span>(<span class="dv">120</span>, <span class="dv">80</span>, <span class="dv">40</span>, <span class="dv">0</span>),</a>
<a class="sourceLine" id="cb235-18" data-line-number="18">                              <span class="dt">FADLAD =</span> BeckLee_ages)</a>
<a class="sourceLine" id="cb235-19" data-line-number="19"><span class="co">## Bootstrapping the time slice subsets</span></a>
<a class="sourceLine" id="cb235-20" data-line-number="20">boot_time_slices &lt;-<span class="st"> </span><span class="kw">boot.matrix</span>(time_slices, <span class="dt">bootstraps =</span> <span class="dv">100</span>)</a>
<a class="sourceLine" id="cb235-21" data-line-number="21"><span class="co">## Calculate disparity</span></a>
<a class="sourceLine" id="cb235-22" data-line-number="22">disparity_time_slices &lt;-<span class="st"> </span><span class="kw">dispRity</span>(boot_time_slices,</a>
<a class="sourceLine" id="cb235-23" data-line-number="23">                                  <span class="dt">metric =</span> <span class="kw">c</span>(sum, variances))</a>
<a class="sourceLine" id="cb235-24" data-line-number="24"></a>
<a class="sourceLine" id="cb235-25" data-line-number="25"><span class="co">## Creating time bin subsets</span></a>
<a class="sourceLine" id="cb235-26" data-line-number="26">time_bins &lt;-<span class="st"> </span><span class="kw">chrono.subsets</span>(<span class="dt">data =</span> BeckLee_mat99,</a>
<a class="sourceLine" id="cb235-27" data-line-number="27">                            <span class="dt">tree =</span> BeckLee_tree, </a>
<a class="sourceLine" id="cb235-28" data-line-number="28">                            <span class="dt">method =</span> <span class="st">&quot;discrete&quot;</span>,</a>
<a class="sourceLine" id="cb235-29" data-line-number="29">                            <span class="dt">time =</span> <span class="kw">c</span>(<span class="dv">120</span>, <span class="dv">80</span>, <span class="dv">40</span>, <span class="dv">0</span>),</a>
<a class="sourceLine" id="cb235-30" data-line-number="30">                            <span class="dt">FADLAD =</span> BeckLee_ages,</a>
<a class="sourceLine" id="cb235-31" data-line-number="31">                            <span class="dt">inc.nodes =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb235-32" data-line-number="32"><span class="co">## Bootstrapping the time bin subsets</span></a>
<a class="sourceLine" id="cb235-33" data-line-number="33">boot_time_bins &lt;-<span class="st"> </span><span class="kw">boot.matrix</span>(time_bins, <span class="dt">bootstraps =</span> <span class="dv">100</span>)</a>
<a class="sourceLine" id="cb235-34" data-line-number="34"><span class="co">## Calculate disparity</span></a>
<a class="sourceLine" id="cb235-35" data-line-number="35">disparity_time_bins &lt;-<span class="st"> </span><span class="kw">dispRity</span>(boot_time_bins,</a>
<a class="sourceLine" id="cb235-36" data-line-number="36">                                <span class="dt">metric =</span> <span class="kw">c</span>(sum, variances))</a></code></pre></div>
<p>These objects are easy to summarise as follows:</p>
<div class="sourceCode" id="cb236"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb236-1" data-line-number="1"><span class="co">## Default summary</span></a>
<a class="sourceLine" id="cb236-2" data-line-number="2"><span class="kw">summary</span>(disparity_time_slices)</a></code></pre></div>
<pre><code>##   subsets  n   obs bs.median  2.5%   25%   75% 97.5%
## 1     120  5 3.258     2.666 1.800 2.447 2.893 3.075
## 2      80 19 3.491     3.314 3.162 3.263 3.369 3.439
## 3      40 15 3.677     3.433 3.171 3.328 3.512 3.672
## 4       0 10 4.092     3.710 3.203 3.560 3.846 4.014</code></pre>
<p>Information about the number of elements in each subset and the observed (i.e. non-bootstrapped) disparity are also calculated.
This is specifically handy when rarefying the data for example:</p>
<div class="sourceCode" id="cb238"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb238-1" data-line-number="1"><span class="kw">head</span>(<span class="kw">summary</span>(disparity_crown_stem))</a></code></pre></div>
<pre><code>##   subsets  n   obs bs.median  2.5%   25%   75% 97.5%
## 1   crown 30 2.526     2.442 2.374 2.418 2.462 2.488
## 2   crown 29    NA     2.444 2.357 2.420 2.468 2.497
## 3   crown 28    NA     2.443 2.381 2.420 2.463 2.493
## 4   crown 27    NA     2.444 2.365 2.419 2.467 2.495
## 5   crown 26    NA     2.441 2.369 2.418 2.469 2.506
## 6   crown 25    NA     2.442 2.357 2.414 2.461 2.496</code></pre>
<p>The summary functions can also take various options such as:</p>
<ul>
<li><code>quantiles</code> values for the confidence interval levels (by default, the 50 and 95 quantiles are calculated)</li>
<li><code>cent.tend</code> for the central tendency to use for summarising the results (default is <code>median</code>)</li>
<li>digits<code>option corresponding to the number of decimal places to print (default is</code>2`)</li>
<li><code>recall</code> option for printing the call of the <code>dispRity</code> object as well (default is <code>FALSE</code>)</li>
</ul>
<p>These options can easily be changed from the defaults as follows:</p>
<div class="sourceCode" id="cb240"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb240-1" data-line-number="1"><span class="co">## Same as above but using the 88th quantile and the standard deviation as the summary </span></a>
<a class="sourceLine" id="cb240-2" data-line-number="2"><span class="kw">summary</span>(disparity_time_slices, <span class="dt">quantiles =</span> <span class="dv">88</span>, <span class="dt">cent.tend =</span> sd)</a></code></pre></div>
<pre><code>##   subsets  n   obs bs.sd    6%   94%
## 1     120  5 3.258 0.381 1.852 3.000
## 2      80 19 3.491 0.074 3.195 3.422
## 3      40 15 3.677 0.133 3.223 3.647
## 4       0 10 4.092 0.215 3.318 3.974</code></pre>
<div class="sourceCode" id="cb242"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb242-1" data-line-number="1"><span class="co">## Printing the details of the object and digits the values to the 5th decimal place</span></a>
<a class="sourceLine" id="cb242-2" data-line-number="2"><span class="kw">summary</span>(disparity_time_slices, <span class="dt">recall =</span> <span class="ot">TRUE</span>, <span class="dt">digits =</span> <span class="dv">5</span>)</a></code></pre></div>
<pre><code>##  ---- dispRity object ---- 
## 4 continuous (proximity) time subsets for 99 elements in one matrix with 97 dimensions with 1 phylogenetic tree
##     120, 80, 40, 0.
## Data was bootstrapped 100 times (method:&quot;full&quot;).
## Disparity was calculated as: c(sum, variances).</code></pre>
<pre><code>##   subsets  n     obs bs.median    2.5%     25%     75%   97.5%
## 1     120  5 3.25815   2.66615 1.79981 2.44681 2.89284 3.07467
## 2      80 19 3.49145   3.31422 3.16207 3.26324 3.36872 3.43851
## 3      40 15 3.67702   3.43316 3.17105 3.32817 3.51160 3.67212
## 4       0 10 4.09234   3.70971 3.20321 3.56007 3.84566 4.01394</code></pre>
<p>Note that the summary table is a <code>data.frame</code>, hence it is as easy to modify as any dataframe using <code>dplyr</code>.
You can also export it in <code>csv</code> format using <code>write.csv</code> or <code>write_csv</code> or even directly export into <code>LaTeX</code> format using the following;</p>
<div class="sourceCode" id="cb245"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb245-1" data-line-number="1"><span class="co">## Loading the xtable package</span></a>
<a class="sourceLine" id="cb245-2" data-line-number="2"><span class="kw">require</span>(xtable)</a>
<a class="sourceLine" id="cb245-3" data-line-number="3"><span class="co">## Converting the table in LaTeX</span></a>
<a class="sourceLine" id="cb245-4" data-line-number="4"><span class="kw">xtable</span>(<span class="kw">summary</span>(disparity_time_slices))</a></code></pre></div>
</div>
<div id="plotting-disprity-data" class="section level3">
<h3><span class="header-section-number">4.5.2</span> Plotting <code>dispRity</code> data</h3>
<p>An alternative (and more fun!) way to display the calculated disparity is to plot the results using the S3 method <code>plot.dispRity</code>.
This function takes the same options as <code>summary.dispRity</code> along with various graphical options described in the function help files (see <code>?plot.dispRity</code>).</p>
<p>The plots can be of five different types:</p>
<ul>
<li><code>preview</code> for a 2d preview of the trait-space.</li>
<li><code>continuous</code> for displaying continuous disparity curves</li>
<li><code>box</code>, <code>lines</code>, and <code>polygons</code> to display discrete disparity results in respectively a boxplot, confidence interval lines, and confidence interval polygons.</li>
</ul>
<blockquote>
<p>This argument can be left empty. In this case, the algorithm will automatically detect the type of subsets from the <code>dispRity</code> object and plot accordingly.</p>
</blockquote>
<p>It is also possible to display the number of elements in each subset (as a horizontal dotted line) using the option <code>elements = TRUE</code>.
Additionally, when the data is rarefied, one can indicate which level of rarefaction to display (i.e. only display the results for a certain number of elements) by using the <code>rarefaction</code> argument.</p>
<div class="sourceCode" id="cb246"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb246-1" data-line-number="1"><span class="co">## Graphical parameters</span></a>
<a class="sourceLine" id="cb246-2" data-line-number="2">op &lt;-<span class="st"> </span><span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="dt">bty =</span> <span class="st">&quot;n&quot;</span>)</a>
<a class="sourceLine" id="cb246-3" data-line-number="3"></a>
<a class="sourceLine" id="cb246-4" data-line-number="4"><span class="co">## Plotting continuous disparity results</span></a>
<a class="sourceLine" id="cb246-5" data-line-number="5"><span class="kw">plot</span>(disparity_time_slices, <span class="dt">type =</span> <span class="st">&quot;continuous&quot;</span>)</a>
<a class="sourceLine" id="cb246-6" data-line-number="6"></a>
<a class="sourceLine" id="cb246-7" data-line-number="7"><span class="co">## Plotting discrete disparity results</span></a>
<a class="sourceLine" id="cb246-8" data-line-number="8"><span class="kw">plot</span>(disparity_crown_stem, <span class="dt">type =</span> <span class="st">&quot;box&quot;</span>)</a>
<a class="sourceLine" id="cb246-9" data-line-number="9"></a>
<a class="sourceLine" id="cb246-10" data-line-number="10"><span class="co">## As above but using lines for the rarefaction level of 20 elements only</span></a>
<a class="sourceLine" id="cb246-11" data-line-number="11"><span class="kw">plot</span>(disparity_crown_stem, <span class="dt">type =</span> <span class="st">&quot;line&quot;</span>, <span class="dt">rarefaction =</span> <span class="dv">20</span>)</a>
<a class="sourceLine" id="cb246-12" data-line-number="12"></a>
<a class="sourceLine" id="cb246-13" data-line-number="13"><span class="co">## As above but using polygons while also displaying the number of elements</span></a>
<a class="sourceLine" id="cb246-14" data-line-number="14"><span class="kw">plot</span>(disparity_crown_stem, <span class="dt">type =</span> <span class="st">&quot;polygon&quot;</span>, <span class="dt">elements =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<p><img src="dispRity_manual_files/figure-html/unnamed-chunk-75-1.png" width="768" /></p>
<div class="sourceCode" id="cb247"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb247-1" data-line-number="1"><span class="co">## Resetting graphical parameters</span></a>
<a class="sourceLine" id="cb247-2" data-line-number="2"><span class="kw">par</span>(op)</a></code></pre></div>
<p>Since <code>plot.dispRity</code> uses the arguments from the generic <code>plot</code> method, it is of course possible to change pretty much everything using the regular plot arguments:</p>
<div class="sourceCode" id="cb248"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb248-1" data-line-number="1"><span class="co">## Graphical options</span></a>
<a class="sourceLine" id="cb248-2" data-line-number="2">op &lt;-<span class="st"> </span><span class="kw">par</span>(<span class="dt">bty =</span> <span class="st">&quot;n&quot;</span>)</a>
<a class="sourceLine" id="cb248-3" data-line-number="3"></a>
<a class="sourceLine" id="cb248-4" data-line-number="4"><span class="co">## Plotting the results with some classic options from plot</span></a>
<a class="sourceLine" id="cb248-5" data-line-number="5"><span class="kw">plot</span>(disparity_time_slices, <span class="dt">col =</span> <span class="kw">c</span>(<span class="st">&quot;blue&quot;</span>, <span class="st">&quot;orange&quot;</span>, <span class="st">&quot;green&quot;</span>),</a>
<a class="sourceLine" id="cb248-6" data-line-number="6">    <span class="dt">ylab =</span> <span class="kw">c</span>(<span class="st">&quot;Some measurement&quot;</span>), <span class="dt">xlab =</span> <span class="st">&quot;Some other measurement&quot;</span>,</a>
<a class="sourceLine" id="cb248-7" data-line-number="7">    <span class="dt">main =</span> <span class="st">&quot;Many options...&quot;</span>, <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">10</span>, <span class="dv">0</span>), <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb248-8" data-line-number="8"></a>
<a class="sourceLine" id="cb248-9" data-line-number="9"><span class="co">## Adding a legend</span></a>
<a class="sourceLine" id="cb248-10" data-line-number="10"><span class="kw">legend</span>(<span class="st">&quot;topleft&quot;</span>, <span class="dt">legend =</span> <span class="kw">c</span>(<span class="st">&quot;Central tendency&quot;</span>,</a>
<a class="sourceLine" id="cb248-11" data-line-number="11">                             <span class="st">&quot;Confidence interval 1&quot;</span>,</a>
<a class="sourceLine" id="cb248-12" data-line-number="12">                             <span class="st">&quot;Confidence interval 2&quot;</span>),</a>
<a class="sourceLine" id="cb248-13" data-line-number="13">      <span class="dt">col =</span> <span class="kw">c</span>(<span class="st">&quot;blue&quot;</span>, <span class="st">&quot;orange&quot;</span>, <span class="st">&quot;green&quot;</span>), <span class="dt">pch =</span> <span class="dv">19</span>)</a></code></pre></div>
<p><img src="dispRity_manual_files/figure-html/unnamed-chunk-76-1.png" width="768" /></p>
<div class="sourceCode" id="cb249"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb249-1" data-line-number="1"><span class="co">## Resetting graphical parameters</span></a>
<a class="sourceLine" id="cb249-2" data-line-number="2"><span class="kw">par</span>(op)</a></code></pre></div>
<p>In addition to the classic <code>plot</code> arguments, the function can also take arguments that are specific to <code>plot.dispRity</code> like adding the number of elements or rarefaction level (as described above), and also changing the values of the quantiles to plot as well as the central tendency.</p>
<div class="sourceCode" id="cb250"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb250-1" data-line-number="1"><span class="co">## Graphical options</span></a>
<a class="sourceLine" id="cb250-2" data-line-number="2">op &lt;-<span class="st"> </span><span class="kw">par</span>(<span class="dt">bty =</span> <span class="st">&quot;n&quot;</span>)</a>
<a class="sourceLine" id="cb250-3" data-line-number="3"></a>
<a class="sourceLine" id="cb250-4" data-line-number="4"><span class="co">## Plotting the results with some plot.dispRity arguments</span></a>
<a class="sourceLine" id="cb250-5" data-line-number="5"><span class="kw">plot</span>(disparity_time_slices,</a>
<a class="sourceLine" id="cb250-6" data-line-number="6">    <span class="dt">quantiles =</span> <span class="kw">c</span>(<span class="kw">seq</span>(<span class="dt">from =</span> <span class="dv">10</span>, <span class="dt">to =</span> <span class="dv">100</span>, <span class="dt">by =</span> <span class="dv">10</span>)),</a>
<a class="sourceLine" id="cb250-7" data-line-number="7">    <span class="dt">cent.tend =</span> sd, <span class="dt">type =</span> <span class="st">&quot;c&quot;</span>, <span class="dt">elements =</span> <span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb250-8" data-line-number="8">    <span class="dt">col =</span> <span class="kw">c</span>(<span class="st">&quot;black&quot;</span>, <span class="kw">rainbow</span>(<span class="dv">10</span>)),</a>
<a class="sourceLine" id="cb250-9" data-line-number="9">    <span class="dt">ylab =</span> <span class="kw">c</span>(<span class="st">&quot;Disparity&quot;</span>, <span class="st">&quot;Diversity&quot;</span>),</a>
<a class="sourceLine" id="cb250-10" data-line-number="10">    <span class="dt">xlab =</span> <span class="st">&quot;Time (in in units from past to present)&quot;</span>,</a>
<a class="sourceLine" id="cb250-11" data-line-number="11">    <span class="dt">observed =</span> <span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb250-12" data-line-number="12">    <span class="dt">main =</span> <span class="st">&quot;Many more options...&quot;</span>)</a></code></pre></div>
<p><img src="dispRity_manual_files/figure-html/unnamed-chunk-77-1.png" width="768" /></p>
<div class="sourceCode" id="cb251"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb251-1" data-line-number="1"><span class="co">## Resetting graphical parameters</span></a>
<a class="sourceLine" id="cb251-2" data-line-number="2"><span class="kw">par</span>(op)</a></code></pre></div>
<blockquote>
<p>Note that the argument <code>observed = TRUE</code> allows to plot the disparity values calculated from the non-bootstrapped data as crosses on the plot.</p>
</blockquote>
<p>For comparing results, it is also possible to add a plot to the existent plot by using <code>add = TRUE</code>:</p>
<div class="sourceCode" id="cb252"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb252-1" data-line-number="1"><span class="co">## Graphical options</span></a>
<a class="sourceLine" id="cb252-2" data-line-number="2">op &lt;-<span class="st"> </span><span class="kw">par</span>(<span class="dt">bty =</span> <span class="st">&quot;n&quot;</span>)</a>
<a class="sourceLine" id="cb252-3" data-line-number="3"></a>
<a class="sourceLine" id="cb252-4" data-line-number="4"><span class="co">## Plotting the continuous disparity with a fixed y axis</span></a>
<a class="sourceLine" id="cb252-5" data-line-number="5"><span class="kw">plot</span>(disparity_time_slices, <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">9</span>))</a>
<a class="sourceLine" id="cb252-6" data-line-number="6"><span class="co">## Adding the discrete data</span></a>
<a class="sourceLine" id="cb252-7" data-line-number="7"><span class="kw">plot</span>(disparity_time_bins, <span class="dt">type =</span> <span class="st">&quot;line&quot;</span>, <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">9</span>),</a>
<a class="sourceLine" id="cb252-8" data-line-number="8">     <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">add =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<p><img src="dispRity_manual_files/figure-html/unnamed-chunk-78-1.png" width="768" /></p>
<div class="sourceCode" id="cb253"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb253-1" data-line-number="1"><span class="co">## Resetting graphical parameters</span></a>
<a class="sourceLine" id="cb253-2" data-line-number="2"><span class="kw">par</span>(op)</a></code></pre></div>
<p>Finally, if your data has been fully rarefied, it is also possible to easily look at rarefaction curves by using the <code>rarefaction = TRUE</code> argument:</p>
<div class="sourceCode" id="cb254"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb254-1" data-line-number="1"><span class="co">## Graphical options</span></a>
<a class="sourceLine" id="cb254-2" data-line-number="2">op &lt;-<span class="st"> </span><span class="kw">par</span>(<span class="dt">bty =</span> <span class="st">&quot;n&quot;</span>)</a>
<a class="sourceLine" id="cb254-3" data-line-number="3"></a>
<a class="sourceLine" id="cb254-4" data-line-number="4"><span class="co">## Plotting the rarefaction curves</span></a>
<a class="sourceLine" id="cb254-5" data-line-number="5"><span class="kw">plot</span>(disparity_crown_stem, <span class="dt">rarefaction =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<p><img src="dispRity_manual_files/figure-html/unnamed-chunk-79-1.png" width="768" /></p>
<div class="sourceCode" id="cb255"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb255-1" data-line-number="1"><span class="co">## Resetting graphical parameters</span></a>
<a class="sourceLine" id="cb255-2" data-line-number="2"><span class="kw">par</span>(op)</a></code></pre></div>
</div>
<div id="type-preview" class="section level3">
<h3><span class="header-section-number">4.5.3</span> <code>type = preview</code></h3>
<p>Note that all the options above are plotting disparity objects for which a disparity metric <em>has been calculated</em>.
This makes totally sense for <code>dispRity</code> objects but sometimes it might be interesting to look at what the trait-space looks like before measuring the disparity.
This can be done by plotting <code>dispRity</code> objects with no calculated disparity!</p>
<p>For example, we might be interested in looking at how the distribution of elements change as a function of the distributions of different sub-settings.
For example custom subsets <em>vs.</em> time subsets:</p>
<div class="sourceCode" id="cb256"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb256-1" data-line-number="1"><span class="co">## Making the different subsets</span></a>
<a class="sourceLine" id="cb256-2" data-line-number="2">cust_subsets &lt;-<span class="st"> </span><span class="kw">custom.subsets</span>(BeckLee_mat99,</a>
<a class="sourceLine" id="cb256-3" data-line-number="3">                               <span class="kw">crown.stem</span>(BeckLee_tree,</a>
<a class="sourceLine" id="cb256-4" data-line-number="4">                                          <span class="dt">inc.nodes =</span> <span class="ot">TRUE</span>))</a>
<a class="sourceLine" id="cb256-5" data-line-number="5">time_subsets &lt;-<span class="st"> </span><span class="kw">chrono.subsets</span>(BeckLee_mat99,</a>
<a class="sourceLine" id="cb256-6" data-line-number="6">                               <span class="dt">tree =</span> BeckLee_tree,</a>
<a class="sourceLine" id="cb256-7" data-line-number="7">                               <span class="dt">method =</span> <span class="st">&quot;discrete&quot;</span>,</a>
<a class="sourceLine" id="cb256-8" data-line-number="8">                               <span class="dt">time =</span> <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb256-9" data-line-number="9"></a>
<a class="sourceLine" id="cb256-10" data-line-number="10"><span class="co">## Note that no disparity has been calculated here:</span></a>
<a class="sourceLine" id="cb256-11" data-line-number="11"><span class="kw">is.null</span>(cust_subsets<span class="op">$</span>disparity)</a></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb258"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb258-1" data-line-number="1"><span class="kw">is.null</span>(time_subsets<span class="op">$</span>disparity)</a></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb260"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb260-1" data-line-number="1"><span class="co">## But we can still plot both spaces by using the default plot functions</span></a>
<a class="sourceLine" id="cb260-2" data-line-number="2"><span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))</a>
<a class="sourceLine" id="cb260-3" data-line-number="3"><span class="co">## Default plotting</span></a>
<a class="sourceLine" id="cb260-4" data-line-number="4"><span class="kw">plot</span>(cust_subsets)</a>
<a class="sourceLine" id="cb260-5" data-line-number="5"><span class="co">## Plotting with more arguments</span></a>
<a class="sourceLine" id="cb260-6" data-line-number="6"><span class="kw">plot</span>(time_subsets, <span class="dt">specific.args =</span> <span class="kw">list</span>(<span class="dt">dimensions =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>)),</a>
<a class="sourceLine" id="cb260-7" data-line-number="7">     <span class="dt">main =</span> <span class="st">&quot;Some </span><span class="ch">\&quot;</span><span class="st">low</span><span class="ch">\&quot;</span><span class="st"> dimensions&quot;</span>)</a></code></pre></div>
<p><img src="dispRity_manual_files/figure-html/unnamed-chunk-80-1.png" width="768" /></p>
<blockquote>
<p>DISCLAIMER: This functionality can be handy for exploring the data (e.g. to visually check whether the subset attribution worked) but it might be misleading on how the data is <em>actually</em> distributed in the multidimensional space!
Groups that don’t overlap on two set dimensions can totally overlap in all other dimensions!</p>
</blockquote>
<p>For <code>dispRity</code> objects that do contain disparity data, the default option is to plot your disparity data.
However you can always force the <code>preview</code> option using the following:</p>
<div class="sourceCode" id="cb261"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb261-1" data-line-number="1"><span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">1</span>))</a>
<a class="sourceLine" id="cb261-2" data-line-number="2"><span class="co">## Default plotting</span></a>
<a class="sourceLine" id="cb261-3" data-line-number="3"><span class="kw">plot</span>(disparity_time_slices, <span class="dt">main =</span> <span class="st">&quot;Disparity through time&quot;</span>)</a>
<a class="sourceLine" id="cb261-4" data-line-number="4"><span class="co">## Plotting with more arguments</span></a>
<a class="sourceLine" id="cb261-5" data-line-number="5"><span class="kw">plot</span>(disparity_time_slices, <span class="dt">type =</span> <span class="st">&quot;preview&quot;</span>,</a>
<a class="sourceLine" id="cb261-6" data-line-number="6">     <span class="dt">main =</span> <span class="st">&quot;Two first dimensions of the trait space&quot;</span>)</a></code></pre></div>
<p><img src="dispRity_manual_files/figure-html/unnamed-chunk-81-1.png" width="768" /></p>
</div>
</div>
<div id="testing-disparity-hypotheses" class="section level2">
<h2><span class="header-section-number">4.6</span> Testing disparity hypotheses</h2>
<p>The <code>dispRity</code> package allows users to apply statistical tests to the calculated disparity to test various hypotheses.
The function <code>test.dispRity</code> works in a similar way to the <code>dispRity</code> function: it takes a <code>dispRity</code> object, a <code>test</code> and a <code>comparisons</code> argument.</p>
<p>The <code>comparisons</code> argument indicates the way the test should be applied to the data:</p>
<ul>
<li><code>pairwise</code> (default): to compare each subset in a pairwise manner</li>
<li><code>referential</code>: to compare each subset to the first subset</li>
<li><code>sequential</code>: to compare each subset to the following subset</li>
<li><code>all</code>: to compare all the subsets together (like in analysis of variance)</li>
</ul>
<p>It is also possible to input a list of pairs of <code>numeric</code> values or <code>characters</code> matching the subset names to create personalised tests.
Some other tests implemented in <code>dispRity</code> such as the <code>dispRity::null.test</code> have a specific way they are applied to the data and therefore ignore the <code>comparisons</code> argument.
<!-- Add sequential test one day! --></p>
<p>The <code>test</code> argument can be any statistical or non-statistical test to apply to the disparity object.
It can be a common statistical test function (e.g. <code>stats::t.test</code>), a function implemented in <code>dispRity</code> (e.g. see <code>?null.test</code>) or any function defined by the user.</p>
<p>This function also allows users to correct for Type I error inflation (false positives) when using multiple comparisons via the <code>correction</code> argument.
This argument can be empty (no correction applied) or can contain one of the corrections from the <code>stats::p.adjust</code> function (see <code>?p.adjust</code>).</p>
<p>Note that the <code>test.dispRity</code> algorithm deals with some classical test outputs (<code>h.test</code>, <code>lm</code> and <code>numeric</code> vector) and summarises the test output.
It is, however, possible to get the full detailed output by using the options <code>details = TRUE</code>.</p>
<p>Here we are using the variables generated in the <a href="#summarising-dispRity-data-plots">section above</a>:</p>
<div class="sourceCode" id="cb262"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb262-1" data-line-number="1"><span class="co">## T-test to test for a difference in disparity between crown and stem mammals</span></a>
<a class="sourceLine" id="cb262-2" data-line-number="2"><span class="kw">test.dispRity</span>(disparity_crown_stem, <span class="dt">test =</span> t.test)</a></code></pre></div>
<pre><code>## [[1]]
##              statistic: t
## crown : stem     50.69093
## 
## [[2]]
##              parameter: df
## crown : stem      159.3761
## 
## [[3]]
##                    p.value
## crown : stem 3.250849e-100
## 
## [[4]]
##                   stderr
## crown : stem 0.006027599</code></pre>
<div class="sourceCode" id="cb264"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb264-1" data-line-number="1"><span class="co">## Performing the same test but with the detailed t.test output</span></a>
<a class="sourceLine" id="cb264-2" data-line-number="2"><span class="kw">test.dispRity</span>(disparity_crown_stem, <span class="dt">test =</span> t.test, <span class="dt">details =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<pre><code>## $`crown : stem`
## $`crown : stem`[[1]]
## 
##  Welch Two Sample t-test
## 
## data:  dots[[1L]][[1L]] and dots[[2L]][[1L]]
## t = 50.691, df = 159.38, p-value &lt; 2.2e-16
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##  0.2936403 0.3174489
## sample estimates:
## mean of x mean of y 
##  2.438778  2.133233</code></pre>
<div class="sourceCode" id="cb266"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb266-1" data-line-number="1"><span class="co">## Wilcoxon test applied to time sliced disparity with sequential comparisons,</span></a>
<a class="sourceLine" id="cb266-2" data-line-number="2"><span class="co">## with Bonferroni correction</span></a>
<a class="sourceLine" id="cb266-3" data-line-number="3"><span class="kw">test.dispRity</span>(disparity_time_slices, <span class="dt">test =</span> wilcox.test,</a>
<a class="sourceLine" id="cb266-4" data-line-number="4">              <span class="dt">comparisons =</span> <span class="st">&quot;sequential&quot;</span>, <span class="dt">correction =</span> <span class="st">&quot;bonferroni&quot;</span>)</a></code></pre></div>
<pre><code>## [[1]]
##          statistic: W
## 120 : 80           21
## 80 : 40          2305
## 40 : 0           1500
## 
## [[2]]
##               p.value
## 120 : 80 1.427461e-33
## 80 : 40  1.376543e-10
## 40 : 0   3.672152e-17</code></pre>
<div class="sourceCode" id="cb268"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb268-1" data-line-number="1"><span class="co">## Measuring the overlap between distributions in the time bins (using the</span></a>
<a class="sourceLine" id="cb268-2" data-line-number="2"><span class="co">## implemented Bhattacharyya Coefficient function - see ?bhatt.coeff)</span></a>
<a class="sourceLine" id="cb268-3" data-line-number="3"><span class="kw">test.dispRity</span>(disparity_time_bins, <span class="dt">test =</span> bhatt.coeff)</a></code></pre></div>
<pre><code>## Warning in test.dispRity(disparity_time_bins, test = bhatt.coeff): Multiple p-values will be calculated without adjustment!
## This can inflate Type I error!</code></pre>
<pre><code>##                    bhatt.coeff
## 120 - 80 : 80 - 40  0.01414214
## 120 - 80 : 40 - 0   0.01414214
## 80 - 40 : 40 - 0    0.36695541</code></pre>
<p>Because of the modular design of the package, tests can always be made by the user (the same way disparity metrics can be user made).
The only condition is that the test can be applied to at least two distributions.
In practice, the <code>test.dispRity</code> function will pass the calculated disparity data (distributions) to the provided function in either pairs of distributions (if the <code>comparisons</code> argument is set to <code>pairwise</code>, <code>referential</code> or <code>sequential</code>) or a table containing all the distributions (<code>comparisons = all</code>; this should be in the same format as data passed to <code>lm</code>-type functions for example).</p>
<div id="adonis" class="section level3">
<h3><span class="header-section-number">4.6.1</span> NPMANOVA in <code>dispRity</code></h3>
<p>One often useful test to apply to multidimensional data is the permutational multivariate analysis of variance based on distance matrices <code>vegan::adonis</code>.
This can be done on <code>dispRity</code> objects using the <code>adonis.dispRity</code> wrapper function.
Basically, this function takes the exact same arguments as <code>adonis</code> and a <code>dispRity</code> object for data and performs a PERMANOVA based on the distance matrix of the multidimensional space (unless the multidimensional space was already defined as a distance matrix).
The <code>adonis.dispRity</code> function uses the information from the <code>dispRity</code> object to generate default formulas:</p>
<ul>
<li>If the object contains customised subsets, it applies the default formula <code>matrix ~ group</code> testing the effect of <code>group</code> as a predictor on <code>matrix</code> (called from the <code>dispRity</code> object as <code>data$matrix</code> see <a href="#The-dispRity-object-content"><code>dispRitu</code> object details</a>)</li>
<li>If the object contains time subsets, it applies the default formula <code>matrix ~ time</code> testing the effect of <code>time</code> as a predictor (were the different levels of <code>time</code> are the different time slices/bins)</li>
</ul>
<div class="sourceCode" id="cb271"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb271-1" data-line-number="1"><span class="kw">set.seed</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb271-2" data-line-number="2"><span class="co">## Generating a random character matrix</span></a>
<a class="sourceLine" id="cb271-3" data-line-number="3">character_matrix &lt;-<span class="st"> </span><span class="kw">sim.morpho</span>(<span class="kw">rtree</span>(<span class="dv">20</span>), <span class="dv">50</span>,</a>
<a class="sourceLine" id="cb271-4" data-line-number="4">                               <span class="dt">rates =</span> <span class="kw">c</span>(rnorm, <span class="dv">1</span>, <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb271-5" data-line-number="5"></a>
<a class="sourceLine" id="cb271-6" data-line-number="6"><span class="co">## Calculating the distance matrix</span></a>
<a class="sourceLine" id="cb271-7" data-line-number="7">distance_matrix &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(<span class="kw">dist</span>(character_matrix))</a>
<a class="sourceLine" id="cb271-8" data-line-number="8"></a>
<a class="sourceLine" id="cb271-9" data-line-number="9"><span class="co">## Creating two groups</span></a>
<a class="sourceLine" id="cb271-10" data-line-number="10">random_groups &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="st">&quot;group1&quot;</span> =<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="st">&quot;group2&quot;</span> =<span class="st"> </span><span class="dv">11</span><span class="op">:</span><span class="dv">20</span>)</a>
<a class="sourceLine" id="cb271-11" data-line-number="11"></a>
<a class="sourceLine" id="cb271-12" data-line-number="12"><span class="co">## Generating a dispRity object</span></a>
<a class="sourceLine" id="cb271-13" data-line-number="13">random_disparity &lt;-<span class="st"> </span><span class="kw">custom.subsets</span>(distance_matrix, random_groups)</a></code></pre></div>
<pre><code>## Warning: custom.subsets is applied on what seems to be a distance matrix.
## The resulting matrices won&#39;t be distance matrices anymore!</code></pre>
<div class="sourceCode" id="cb273"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb273-1" data-line-number="1"><span class="co">## Running a default NPMANOVA</span></a>
<a class="sourceLine" id="cb273-2" data-line-number="2"><span class="kw">adonis.dispRity</span>(random_disparity)</a></code></pre></div>
<pre><code>## 
## Call:
## vegan::adonis(formula = matrix ~ group, data = random_disparity,      method = &quot;euclidean&quot;) 
## 
## Permutation: free
## Number of permutations: 999
## 
## Terms added sequentially (first to last)
## 
##           Df SumsOfSqs MeanSqs F.Model      R2 Pr(&gt;F)
## group      1      14.2  14.200  1.2396 0.06443  0.166
## Residuals 18     206.2  11.456         0.93557       
## Total     19     220.4                 1.00000</code></pre>
<p>Of course, it is possible to pass customised formulas if the disparity object contains more more groups.
In that case the predictors must correspond to the names of the groups explained data must be set as <code>matrix</code>:</p>
<div class="sourceCode" id="cb275"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb275-1" data-line-number="1"><span class="co">## Creating two groups with two states each</span></a>
<a class="sourceLine" id="cb275-2" data-line-number="2">groups &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(<span class="kw">matrix</span>(<span class="dt">data =</span> <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>,<span class="dv">10</span>),</a>
<a class="sourceLine" id="cb275-3" data-line-number="3">                                        <span class="kw">rep</span>(<span class="dv">2</span>,<span class="dv">10</span>),</a>
<a class="sourceLine" id="cb275-4" data-line-number="4">                                        <span class="kw">rep</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>), <span class="dv">10</span>)),</a>
<a class="sourceLine" id="cb275-5" data-line-number="5">                        <span class="dt">nrow =</span> <span class="dv">20</span>, <span class="dt">ncol =</span> <span class="dv">2</span>,</a>
<a class="sourceLine" id="cb275-6" data-line-number="6">                        <span class="dt">dimnames =</span> <span class="kw">list</span>(<span class="kw">paste0</span>(<span class="st">&quot;t&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">20</span>),</a>
<a class="sourceLine" id="cb275-7" data-line-number="7">                                        <span class="kw">c</span>(<span class="st">&quot;g1&quot;</span>, <span class="st">&quot;g2&quot;</span>))))</a>
<a class="sourceLine" id="cb275-8" data-line-number="8"></a>
<a class="sourceLine" id="cb275-9" data-line-number="9"><span class="co">## Creating the dispRity object</span></a>
<a class="sourceLine" id="cb275-10" data-line-number="10">multi_groups &lt;-<span class="st"> </span><span class="kw">custom.subsets</span>(distance_matrix, groups)</a></code></pre></div>
<pre><code>## Warning: custom.subsets is applied on what seems to be a distance matrix.
## The resulting matrices won&#39;t be distance matrices anymore!</code></pre>
<div class="sourceCode" id="cb277"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb277-1" data-line-number="1"><span class="co">## Running the NPMANOVA</span></a>
<a class="sourceLine" id="cb277-2" data-line-number="2"><span class="kw">adonis.dispRity</span>(multi_groups, matrix <span class="op">~</span><span class="st"> </span>g1 <span class="op">+</span><span class="st"> </span>g2)</a></code></pre></div>
<pre><code>## 
## Call:
## vegan::adonis(formula = matrix ~ g1 + g2, data = multi_groups,      method = &quot;euclidean&quot;) 
## 
## Permutation: free
## Number of permutations: 999
## 
## Terms added sequentially (first to last)
## 
##           Df SumsOfSqs MeanSqs F.Model      R2 Pr(&gt;F)
## g1         1      14.2  14.200 1.22042 0.06443  0.174
## g2         1       8.4   8.400 0.72194 0.03811  0.884
## Residuals 17     197.8  11.635         0.89746       
## Total     19     220.4                 1.00000</code></pre>
<p>Finally, it is possible to use objects generated by <code>chrono.subsets</code>.
In this case, <code>adonis.dispRity</code> will applied the <code>matrix ~ time</code> formula by default:</p>
<div class="sourceCode" id="cb279"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb279-1" data-line-number="1"><span class="co">## Creating time series</span></a>
<a class="sourceLine" id="cb279-2" data-line-number="2">time_subsets &lt;-<span class="st"> </span><span class="kw">chrono.subsets</span>(BeckLee_mat50, BeckLee_tree,</a>
<a class="sourceLine" id="cb279-3" data-line-number="3">                               <span class="dt">method =</span> <span class="st">&quot;discrete&quot;</span>,</a>
<a class="sourceLine" id="cb279-4" data-line-number="4">                               <span class="dt">inc.nodes =</span> <span class="ot">FALSE</span>,</a>
<a class="sourceLine" id="cb279-5" data-line-number="5">                               <span class="dt">time =</span> <span class="kw">c</span>(<span class="dv">100</span>, <span class="dv">85</span>, <span class="dv">65</span>, <span class="dv">0</span>),</a>
<a class="sourceLine" id="cb279-6" data-line-number="6">                               <span class="dt">FADLAD =</span> BeckLee_ages)</a>
<a class="sourceLine" id="cb279-7" data-line-number="7"></a>
<a class="sourceLine" id="cb279-8" data-line-number="8"><span class="co">## Running the NPMANOVA with time as a predictor</span></a>
<a class="sourceLine" id="cb279-9" data-line-number="9"><span class="kw">adonis.dispRity</span>(time_subsets)</a></code></pre></div>
<pre><code>## Warning in adonis.dispRity(time_subsets): The input data for adonis.dispRity was not a distance matrix.
## The results are thus based on the distance matrix for the input data (i.e. dist(data$matrix[[1]])).
## Make sure that this is the desired methodological approach!</code></pre>
<pre><code>## 
## Call:
## vegan::adonis(formula = dist(matrix) ~ time, data = time_subsets,      method = &quot;euclidean&quot;) 
## 
## Permutation: free
## Number of permutations: 999
## 
## Terms added sequentially (first to last)
## 
##           Df SumsOfSqs MeanSqs F.Model      R2 Pr(&gt;F)    
## time       2     9.593  4.7966  1.9796 0.07769  0.001 ***
## Residuals 47   113.884  2.4231         0.92231           
## Total     49   123.477                 1.00000           
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>Note that the function warns you that the input data was transformed into a distance matrix.
This is reflected in the Call part of the output (<code>formula = dist(matrix) ~ time</code>).</p>
<p>To use each time subset as a separate predictor, you can use the <code>matrix ~ chrono.subsets</code> formula; this is equivalent to <code>matrix ~ first_time_subset + second_time_subset + ...</code>:</p>
<div class="sourceCode" id="cb282"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb282-1" data-line-number="1"><span class="co">## Running the NPMANOVA with each time bin as a predictor</span></a>
<a class="sourceLine" id="cb282-2" data-line-number="2"><span class="kw">adonis.dispRity</span>(time_subsets, matrix <span class="op">~</span><span class="st"> </span>chrono.subsets)</a></code></pre></div>
<pre><code>## Warning in adonis.dispRity(time_subsets, matrix ~ chrono.subsets): The input data for adonis.dispRity was not a distance matrix.
## The results are thus based on the distance matrix for the input data (i.e. dist(data$matrix[[1]])).
## Make sure that this is the desired methodological approach!</code></pre>
<pre><code>## 
## Call:
## vegan::adonis(formula = dist(matrix) ~ chrono.subsets, data = time_subsets,      method = &quot;euclidean&quot;) 
## 
## Permutation: free
## Number of permutations: 999
## 
## Terms added sequentially (first to last)
## 
##           Df SumsOfSqs MeanSqs F.Model      R2 Pr(&gt;F)    
## t100to85   1     3.714  3.7144  1.5329 0.03008  0.006 ** 
## t85to65    1     5.879  5.8788  2.4262 0.04761  0.001 ***
## Residuals 47   113.884  2.4231         0.92231           
## Total     49   123.477                 1.00000           
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
</div>
<div id="dtt" class="section level3">
<h3><span class="header-section-number">4.6.2</span> <code>geiger::dtt</code> model fitting in <code>dispRity</code></h3>
<p>The <code>dtt</code> function from the <code>geiger</code> package is also often used to compare a trait’s disparity observed in living taxa to the disparity of a simulated trait based on a given phylogeny.
The <code>dispRity</code> package proposes a wrapper function for <code>geiger::dtt</code>, <code>dtt.dispRity</code> that allows the use of any disparity metric.
Unfortunately, this implementation is slower that <code>geiger::dtt</code> (so if you’re using the metrics implemented in <code>geiger</code> prefer the original version) and, as the original function, is limited to ultrametric trees (only living taxa!)…</p>
<div class="sourceCode" id="cb285"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb285-1" data-line-number="1"><span class="kw">require</span>(geiger)</a></code></pre></div>
<pre><code>## Loading required package: geiger</code></pre>
<div class="sourceCode" id="cb287"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb287-1" data-line-number="1">geiger_data &lt;-<span class="st"> </span><span class="kw">get</span>(<span class="kw">data</span>(geospiza))</a>
<a class="sourceLine" id="cb287-2" data-line-number="2"></a>
<a class="sourceLine" id="cb287-3" data-line-number="3"><span class="co">## Calculate the disparity of the dataset using the sum of variance</span></a>
<a class="sourceLine" id="cb287-4" data-line-number="4">dispRity_dtt &lt;-<span class="st"> </span><span class="kw">dtt.dispRity</span>(<span class="dt">data =</span> geiger_data<span class="op">$</span>dat,</a>
<a class="sourceLine" id="cb287-5" data-line-number="5">                             <span class="dt">metric =</span> <span class="kw">c</span>(sum, variances),</a>
<a class="sourceLine" id="cb287-6" data-line-number="6">                             <span class="dt">tree =</span> geiger_data<span class="op">$</span>phy,</a>
<a class="sourceLine" id="cb287-7" data-line-number="7">                             <span class="dt">nsim =</span> <span class="dv">100</span>)</a></code></pre></div>
<pre><code>## Warning in dtt.dispRity(data = geiger_data$dat, metric = c(sum, variances), :
## The following tip(s) was not present in the data: olivacea.</code></pre>
<div class="sourceCode" id="cb289"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb289-1" data-line-number="1"><span class="co">## Plotting the results</span></a>
<a class="sourceLine" id="cb289-2" data-line-number="2"><span class="kw">plot</span>(dispRity_dtt)</a></code></pre></div>
<p><img src="dispRity_manual_files/figure-html/unnamed-chunk-87-1.png" width="672" /></p>
<p>Note that, like in the original <code>dtt</code> function, it is possible to change the evolutionary model (see <code>?geiger::sim.char</code> documentation).</p>
</div>
<div id="null-test" class="section level3">
<h3><span class="header-section-number">4.6.3</span> null morphospace testing with <code>null.test</code></h3>
<p>This test is equivalent to the test performed in <span class="citation">Díaz et al. (<a href="#ref-diaz2016global">2016</a>)</span>.
It compares the disparity measured in the observed space to the disparity measured in a set of simulated spaces.
These simulated spaces can be built with based on the hypothesis assumptions: for example, we can test whether our space is normal.</p>
<div class="sourceCode" id="cb290"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb290-1" data-line-number="1"><span class="kw">set.seed</span>(<span class="dv">123</span>)</a>
<a class="sourceLine" id="cb290-2" data-line-number="2"><span class="co">## A &quot;normal&quot; multidimensional space with 50 dimensions and 10 elements</span></a>
<a class="sourceLine" id="cb290-3" data-line-number="3">normal_space &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">1000</span>), <span class="dt">ncol =</span> <span class="dv">50</span>)</a>
<a class="sourceLine" id="cb290-4" data-line-number="4"></a>
<a class="sourceLine" id="cb290-5" data-line-number="5"><span class="co">## Calculating the disparity as the average pairwise distances</span></a>
<a class="sourceLine" id="cb290-6" data-line-number="6">obs_disparity &lt;-<span class="st"> </span><span class="kw">dispRity</span>(normal_space,</a>
<a class="sourceLine" id="cb290-7" data-line-number="7">                          <span class="dt">metric =</span> <span class="kw">c</span>(mean, pairwise.dist))</a></code></pre></div>
<pre><code>## Warning in check.dispRity.data(data): Row names have been automatically added to
## data.</code></pre>
<div class="sourceCode" id="cb292"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb292-1" data-line-number="1"><span class="co">## Testing against 100 randomly generated normal spaces</span></a>
<a class="sourceLine" id="cb292-2" data-line-number="2">(results &lt;-<span class="st"> </span><span class="kw">null.test</span>(obs_disparity, <span class="dt">replicates =</span> <span class="dv">100</span>,</a>
<a class="sourceLine" id="cb292-3" data-line-number="3">                      <span class="dt">null.distrib =</span> rnorm))</a></code></pre></div>
<pre><code>## Monte-Carlo test
## Call: [1] &quot;dispRity::null.test&quot;
## 
## Observation: 9.910536 
## 
## Based on 100 replicates
## Simulated p-value: 0.00990099 
## Alternative hypothesis: two-sided 
## 
##     Std.Obs Expectation    Variance 
## 49.07674865  1.10038000  0.03222668</code></pre>
<p>Here the results show that disparity measured in our observed space is not significantly different than the one measured in a normal space.
We can then propose that our observed space is normal!</p>
<p>These results have an attributed <code>dispRity</code> and <code>randtest</code> class and can be plotted as <code>randtest</code> objects using the <code>dispRity</code> S3 <code>plot</code> method:</p>
<div class="sourceCode" id="cb294"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb294-1" data-line-number="1"><span class="co">## Plotting the results</span></a>
<a class="sourceLine" id="cb294-2" data-line-number="2"><span class="kw">plot</span>(results, <span class="dt">main =</span> <span class="st">&quot;Is this space normal?&quot;</span>)</a></code></pre></div>
<p><img src="dispRity_manual_files/figure-html/unnamed-chunk-89-1.png" width="768" /></p>
<p>For more details on generating spaces see the <a href="#Simulating-multidimensional-spaces"><code>space.maker</code></a> function tutorial.</p>
</div>
</div>
<div id="model-fitting" class="section level2">
<h2><span class="header-section-number">4.7</span> Fitting modes of evolution to disparity data</h2>
<p>The code used for these models is based on those developed by Gene Hunt <span class="citation">(Hunt <a href="#ref-hunt2006fitting">2006</a>, <a href="#ref-hunt2012measuring">2012</a>; Hunt, Hopkins, and Lidgard <a href="#ref-hunt2015simple">2015</a>)</span>.
So we acknowledge and thank Gene Hunt for developing these models and writing the original R code that served as inspiration for these models.</p>
<blockquote>
<p>DISCLAIMER: this method of analysing disparity has not been published yet and has not been peer reviewed. Caution should be used in interpreting these results: it is unclear what “a disparity curve fitting a Brownian motion” actually means biologically.</p>
</blockquote>
<p>As Malcolm said in Jurassic Park: “although the examples within this chapter all work and produce solid tested results (from an algorithm point of view), that doesn’t mean you should use it” (or something along those lines).</p>
<div id="simple-modes-of-disparity-change-through-time" class="section level3">
<h3><span class="header-section-number">4.7.1</span> Simple modes of disparity change through time</h3>
<div id="model.test" class="section level4">
<h4><span class="header-section-number">4.7.1.1</span> <code>model.test</code></h4>
<p>Changes in disparity-through-time can follow a range of models, such as random walks, stasis, constrained evolution, trends, or an early burst model of evolution.
We will start with by fitting the simplest modes of evolution to our data.
For example we may have a null expectation of time-invariant change in disparity in which values fluctuate with a variance around the mean - this would be best describe by a Stasis model:</p>
<div class="sourceCode" id="cb295"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb295-1" data-line-number="1"><span class="co">## Loading premade disparity data</span></a>
<a class="sourceLine" id="cb295-2" data-line-number="2"><span class="kw">data</span>(BeckLee_disparity)</a>
<a class="sourceLine" id="cb295-3" data-line-number="3">disp_time &lt;-<span class="st"> </span><span class="kw">model.test</span>(<span class="dt">data =</span> BeckLee_disparity, <span class="dt">model =</span> <span class="st">&quot;Stasis&quot;</span>)</a></code></pre></div>
<pre><code>## Evidence of equal variance (Bartlett&#39;s test of equal variances p = 0).
## Variance is not pooled.
## Running Stasis model...Done. Log-likelihood = -18.694</code></pre>
<p>We can see the standard output from <code>model.test</code>.
The first output message tells us it has tested for equal variances in each sample.
The model uses Bartlett’s test of equal variances to assess if variances are equal, so if p &gt; 0.05 then variance is treated as the same for all samples, but if (p &lt; 0.05) then each bin variance is unique.
Here we have p &lt; 0.05, so variance is not pooled between samples.</p>
<p>By default <code>model.test</code> will use Bartlett’s test to assess for homogeneity of variances, and then use this to decide to pool variances or not.
This is ignored if the argument <code>pool.variance</code> in <code>model.test</code> is changed from the default <code>NULL</code> to <code>TRUE</code> or <code>FALSE</code>.
For example, to ignore Bartlett’s test and pool variances manually we would do the following:</p>
<div class="sourceCode" id="cb297"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb297-1" data-line-number="1">disp_time_pooled &lt;-<span class="st"> </span><span class="kw">model.test</span>(<span class="dt">data =</span> BeckLee_disparity,</a>
<a class="sourceLine" id="cb297-2" data-line-number="2">                               <span class="dt">model =</span> <span class="st">&quot;Stasis&quot;</span>,</a>
<a class="sourceLine" id="cb297-3" data-line-number="3">                               <span class="dt">pool.variance =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<pre><code>## Running Stasis model...Done. Log-likelihood = -16.884</code></pre>
<p>However, unless you have good reason to choose otherwise it is recommended to use the default of <code>pool.variance = NULL</code>:</p>
<div class="sourceCode" id="cb299"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb299-1" data-line-number="1">disp_time &lt;-<span class="st"> </span><span class="kw">model.test</span>(<span class="dt">data =</span> BeckLee_disparity,</a>
<a class="sourceLine" id="cb299-2" data-line-number="2">                        <span class="dt">model =</span> <span class="st">&quot;Stasis&quot;</span>,</a>
<a class="sourceLine" id="cb299-3" data-line-number="3">                        <span class="dt">pool.variance =</span> <span class="ot">NULL</span>)</a></code></pre></div>
<pre><code>## Evidence of equal variance (Bartlett&#39;s test of equal variances p = 0).
## Variance is not pooled.
## Running Stasis model...Done. Log-likelihood = -18.694</code></pre>
<div class="sourceCode" id="cb301"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb301-1" data-line-number="1">disp_time</a></code></pre></div>
<pre><code>## Disparity evolution model fitting:
## Call: model.test(data = BeckLee_disparity, model = &quot;Stasis&quot;, pool.variance = NULL) 
## 
##            aicc delta_aicc weight_aicc
## Stasis 41.48967          0           1
## 
## Use x$full.details for displaying the models details
## or summary(x) for summarising them.</code></pre>
<p>The remaining output gives us the log-likelihood of the Stasis model of -18.7 (you may notice this change when we pooled variances above).
The output also gives us the small sample Akaike Information Criterion (AICc), the delta AICc (the distance from the best fitting model), and the AICc weights (~the relative support of this model compared to all models, scaled to one).</p>
<p>These are all metrics of relative fit, so when we test a single model they are not useful.
By using the function summary in <code>dispRity</code> we can see the maximum likelihood estimates of the model parameters:</p>
<div class="sourceCode" id="cb303"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb303-1" data-line-number="1"><span class="kw">summary</span>(disp_time)</a></code></pre></div>
<pre><code>##        aicc delta_aicc weight_aicc log.lik param theta.1 omega
## Stasis 41.5          0           1   -18.7     2     3.6   0.1</code></pre>
<p>So we again see the AICc, delta AICc, AICc weight, and the log-likelihood we saw previously.
We now also see the number of parameters from the model (2: theta and omega), and their estimates so the variance (omega = 0.1) and the mean (theta.1 = 3.6).</p>
<p>The <code>model.test</code> function is designed to test relative model fit, so we need to test more than one model to make relative comparisons.
So let’s compare to the fit of the Stasis model to another model with two parameters: the Brownian motion.
Brownian motion assumes a constant mean that is equal to the ancestral estimate of the sequence, and the variance around this mean increases linearly with time.
The easier way to compare these models is to simply add <code>&quot;BM&quot;</code> to the <code>models</code> vector argument:</p>
<div class="sourceCode" id="cb305"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb305-1" data-line-number="1">disp_time &lt;-<span class="st"> </span><span class="kw">model.test</span>(<span class="dt">data =</span> BeckLee_disparity,</a>
<a class="sourceLine" id="cb305-2" data-line-number="2">                        <span class="dt">model =</span> <span class="kw">c</span>(<span class="st">&quot;Stasis&quot;</span>, <span class="st">&quot;BM&quot;</span>))</a></code></pre></div>
<pre><code>## Evidence of equal variance (Bartlett&#39;s test of equal variances p = 0).
## Variance is not pooled.
## Running Stasis model...Done. Log-likelihood = -18.694
## Running BM model...Done. Log-likelihood = 149.289</code></pre>
<div class="sourceCode" id="cb307"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb307-1" data-line-number="1">disp_time</a></code></pre></div>
<pre><code>## Disparity evolution model fitting:
## Call: model.test(data = BeckLee_disparity, model = c(&quot;Stasis&quot;, &quot;BM&quot;)) 
## 
##              aicc delta_aicc  weight_aicc
## Stasis   41.48967   335.9656 1.111708e-73
## BM     -294.47595     0.0000 1.000000e+00
## 
## Use x$full.details for displaying the models details
## or summary(x) for summarising them.</code></pre>
<p>Et voilà! Here we can see by the log-likelihood, AICc, delta AICc, and AICc weight Brownian motion has a much better relative fit to these data than the Stasis model.
Brownian motion has a relative AICc fit336 units better than Stasis, and has a AICc weight of 1.</p>
<p>We can also all the information about the relative fit of models alongside the maximum likelihood estimates of model parameters using the summary function</p>
<div class="sourceCode" id="cb309"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb309-1" data-line-number="1"><span class="kw">summary</span>(disp_time)</a></code></pre></div>
<pre><code>##        aicc delta_aicc weight_aicc log.lik param theta.1 omega ancestral state
## Stasis   41        336           0   -18.7     2   3.629 0.074              NA
## BM     -294          0           1   149.3     2      NA    NA           3.267
##        sigma squared
## Stasis            NA
## BM             0.001</code></pre>
<p>Not that because the parameters per models differ, the summary includes <code>NA</code> for inapplicable parameters per models (e.g. the theta and omega parameters from the Stasis models are inapplicable for a Brownian motion model).</p>
<p>We can plot the relative fit of our models using the <code>plot</code> function</p>
<div class="sourceCode" id="cb311"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb311-1" data-line-number="1"><span class="kw">plot</span>(disp_time)</a></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:plot1"></span>
<img src="dispRity_manual_files/figure-html/plot1-1.png" alt="relative fit (AICc weight) of Stasis and Brownian models of disparity through time" width="576" />
<p class="caption">
Figure 4.1: relative fit (AICc weight) of Stasis and Brownian models of disparity through time
</p>
</div>
<p>Here we see and overwhelming support for the Brownian motion model.</p>
<p>Alternatively, we could test all available models single modes: Stasis, Brownian motion, Ornstein-Uhlenbeck (evolution constrained to an optima), Trend (increasing or decreasing mean through time), and Early Burst (exponentially decreasing rate through time)</p>
<div class="sourceCode" id="cb312"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb312-1" data-line-number="1">disp_time &lt;-<span class="st"> </span><span class="kw">model.test</span>(<span class="dt">data =</span> BeckLee_disparity,</a>
<a class="sourceLine" id="cb312-2" data-line-number="2">                  <span class="dt">model =</span> <span class="kw">c</span>(<span class="st">&quot;Stasis&quot;</span>, <span class="st">&quot;BM&quot;</span>, <span class="st">&quot;OU&quot;</span>, <span class="st">&quot;Trend&quot;</span>, <span class="st">&quot;EB&quot;</span>))</a></code></pre></div>
<pre><code>## Evidence of equal variance (Bartlett&#39;s test of equal variances p = 0).
## Variance is not pooled.
## Running Stasis model...Done. Log-likelihood = -18.694
## Running BM model...Done. Log-likelihood = 149.289
## Running OU model...Done. Log-likelihood = 152.119
## Running Trend model...Done. Log-likelihood = 152.116
## Running EB model...Done. Log-likelihood = 126.268</code></pre>
<div class="sourceCode" id="cb314"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb314-1" data-line-number="1"><span class="kw">summary</span>(disp_time)</a></code></pre></div>
<pre><code>##        aicc delta_aicc weight_aicc log.lik param theta.1 omega ancestral state
## Stasis   41      339.5       0.000   -18.7     2   3.629 0.074              NA
## BM     -294        3.6       0.112   149.3     2      NA    NA           3.267
## OU     -296        2.1       0.227   152.1     4      NA    NA           3.254
## Trend  -298        0.0       0.661   152.1     3      NA    NA           3.255
## EB     -246       51.7       0.000   126.3     3      NA    NA           4.092
##        sigma squared alpha optima.1 trend     eb
## Stasis            NA    NA       NA    NA     NA
## BM             0.001    NA       NA    NA     NA
## OU             0.001 0.001    12.88    NA     NA
## Trend          0.001    NA       NA 0.007     NA
## EB             0.000    NA       NA    NA -0.032</code></pre>
<p>These models indicate support for a Trend model, and we can plot the relative support of all model AICc weights.</p>
<div class="sourceCode" id="cb316"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb316-1" data-line-number="1"><span class="kw">plot</span>(disp_time)</a></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:plot2"></span>
<img src="dispRity_manual_files/figure-html/plot2-1.png" alt="relative fit (AICc weight) of various modes of evolution" width="576" />
<p class="caption">
Figure 4.2: relative fit (AICc weight) of various modes of evolution
</p>
</div>
<blockquote>
<p>Note that although AIC values are indicator of model best fit, it is also important to look at the parameters themselves.
For example OU can be really well supported but with an alpha parameter really close to 0, making it effectively a BM model <span class="citation">(Cooper et al. <a href="#ref-Cooper2016">2016</a>)</span>.</p>
</blockquote>
<p>Is this a trend of increasing or decreasing disparity through time? One way to find out is to look at the summary function for the Trend model:</p>
<div class="sourceCode" id="cb317"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb317-1" data-line-number="1"><span class="kw">summary</span>(disp_time)[<span class="st">&quot;Trend&quot;</span>,]</a></code></pre></div>
<pre><code>##            aicc      delta_aicc     weight_aicc         log.lik           param 
##        -298.000           0.000           0.661         152.100           3.000 
##         theta.1           omega ancestral state   sigma squared           alpha 
##              NA              NA           3.255           0.001              NA 
##        optima.1           trend              eb 
##              NA           0.007              NA</code></pre>
<p>This show a positive trend (0.007) of increasing disparity through time.</p>
</div>
</div>
<div id="plot-and-run-simulation-tests-in-a-single-step" class="section level3">
<h3><span class="header-section-number">4.7.2</span> Plot and run simulation tests in a single step</h3>
<div id="model.test.wrapper" class="section level4">
<h4><span class="header-section-number">4.7.2.1</span> <code>model.test.wrapper</code></h4>
<p>Patterns of evolution can be fit using <code>model.test</code>, but the <code>model.test.wrapper</code> fits the same models as <code>model.test</code> as well as running predictive tests and plots.</p>
<p>The predictive tests use the maximum likelihood estimates of model parameters to simulate a number of datasets (default = 1000), and analyse whether this is significantly different to the empirical input data using the Rank Envelope test <span class="citation">(Murrell <a href="#ref-murrell2018global">2018</a>)</span>.
Finally we can plot the empirical data, simulated data, and the Rank Envelope test p values.
This can all be done using the function <code>model.test.wrapper</code>, and we will set the argument <code>show.p = TRUE</code> so <em>p</em> values from the Rank Envelope test are printed on the plot:</p>
<div class="sourceCode" id="cb319"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb319-1" data-line-number="1">disp_time &lt;-<span class="st"> </span><span class="kw">model.test.wrapper</span>(<span class="dt">data =</span> BeckLee_disparity,</a>
<a class="sourceLine" id="cb319-2" data-line-number="2">                    <span class="dt">model =</span> <span class="kw">c</span>(<span class="st">&quot;Stasis&quot;</span>, <span class="st">&quot;BM&quot;</span>, <span class="st">&quot;OU&quot;</span>, <span class="st">&quot;Trend&quot;</span>, <span class="st">&quot;EB&quot;</span>),</a>
<a class="sourceLine" id="cb319-3" data-line-number="3">                                <span class="dt">show.p =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<pre><code>## Evidence of equal variance (Bartlett&#39;s test of equal variances p = 0).
## Variance is not pooled.
## Running Stasis model...Done. Log-likelihood = -18.694
## Running BM model...Done. Log-likelihood = 149.289
## Running OU model...Done. Log-likelihood = 152.119
## Running Trend model...Done. Log-likelihood = 152.116
## Running EB model...Done. Log-likelihood = 126.268</code></pre>
<div class="figure" style="text-align: center"><span id="fig:plot3"></span>
<img src="dispRity_manual_files/figure-html/plot3-1.png" alt="Empirical disparity through time (pink), simulate data based on estimated model parameters (grey), delta AICc, and range of p values from the Rank Envelope test for Trend, OU, BM, EB, and Stasis models" width="1152" />
<p class="caption">
Figure 4.3: Empirical disparity through time (pink), simulate data based on estimated model parameters (grey), delta AICc, and range of p values from the Rank Envelope test for Trend, OU, BM, EB, and Stasis models
</p>
</div>
<div class="sourceCode" id="cb321"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb321-1" data-line-number="1">disp_time</a></code></pre></div>
<pre><code>##        aicc delta_aicc weight_aicc log.lik param theta.1 omega ancestral state
## Trend  -298        0.0       0.661   152.1     3      NA    NA           3.255
## OU     -296        2.1       0.227   152.1     4      NA    NA           3.254
## BM     -294        3.6       0.112   149.3     2      NA    NA           3.267
## EB     -246       51.7       0.000   126.3     3      NA    NA           4.092
## Stasis   41      339.5       0.000   -18.7     2   3.629 0.074              NA
##        sigma squared alpha optima.1 trend     eb median p value lower p value
## Trend          0.001    NA       NA 0.007     NA     0.97752248   0.977022977
## OU             0.001 0.001    12.88    NA     NA     0.97802198   0.978021978
## BM             0.001    NA       NA    NA     NA     0.16283716   0.137862138
## EB             0.000    NA       NA    NA -0.032     0.06893107   0.000999001
## Stasis            NA    NA       NA    NA     NA     1.00000000   1.000000000
##        upper p value
## Trend      0.9780220
## OU         0.9780220
## BM         0.1878122
## EB         0.1368631
## Stasis     1.0000000</code></pre>
<p>From this plot we can see the empirical estimates of disparity through time (pink) compared to the predictive data based upon the simulations using the estimated parameters from each model.
There is no significant differences between the empirical data and simulated data, except for the Early Burst model.</p>
<p>Trend is the best-fitting model but the plot suggests the OU model also follows a trend-like pattern.
This is because the optima for the OU model (12.88) is different to the ancestral state (3.254) and outside the observed value.
This is potentially unrealistic, and one way to alleviate this issue is to set the optima of the OU model to equal the ancestral estimate - this is the normal practice for OU models in comparative phylogenetics.
To set the optima to the ancestral value we change the argument <code>fixed.optima = TRUE</code>:</p>
<div class="sourceCode" id="cb323"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb323-1" data-line-number="1">disp_time &lt;-<span class="st"> </span><span class="kw">model.test.wrapper</span>(<span class="dt">data =</span> BeckLee_disparity,</a>
<a class="sourceLine" id="cb323-2" data-line-number="2">                    <span class="dt">model =</span> <span class="kw">c</span>(<span class="st">&quot;Stasis&quot;</span>, <span class="st">&quot;BM&quot;</span>, <span class="st">&quot;OU&quot;</span>, <span class="st">&quot;Trend&quot;</span>, <span class="st">&quot;EB&quot;</span>),</a>
<a class="sourceLine" id="cb323-3" data-line-number="3">                                <span class="dt">show.p =</span> <span class="ot">TRUE</span>, <span class="dt">fixed.optima =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<pre><code>## Evidence of equal variance (Bartlett&#39;s test of equal variances p = 0).
## Variance is not pooled.
## Running Stasis model...Done. Log-likelihood = -18.694
## Running BM model...Done. Log-likelihood = 149.289
## Running OU model...Done. Log-likelihood = 149.289
## Running Trend model...Done. Log-likelihood = 152.116
## Running EB model...Done. Log-likelihood = 126.268</code></pre>
<div class="figure" style="text-align: center"><span id="fig:plot4"></span>
<img src="dispRity_manual_files/figure-html/plot4-1.png" alt="Empirical disparity through time (pink), simulate data based on estimated model parameters (grey), delta AICc, and range of p values from the Rank Envelope test for Trend, OU, BM, EB, and Stasis models with the optima of the OU model set to equal the ancestral value" width="1152" />
<p class="caption">
Figure 4.4: Empirical disparity through time (pink), simulate data based on estimated model parameters (grey), delta AICc, and range of p values from the Rank Envelope test for Trend, OU, BM, EB, and Stasis models with the optima of the OU model set to equal the ancestral value
</p>
</div>
<div class="sourceCode" id="cb325"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb325-1" data-line-number="1">disp_time</a></code></pre></div>
<pre><code>##        aicc delta_aicc weight_aicc log.lik param theta.1 omega ancestral state
## Trend  -298        0.0       0.814   152.1     3      NA    NA           3.255
## BM     -294        3.6       0.138   149.3     2      NA    NA           3.267
## OU     -292        5.7       0.048   149.3     3      NA    NA           3.267
## EB     -246       51.7       0.000   126.3     3      NA    NA           4.092
## Stasis   41      339.5       0.000   -18.7     2   3.629 0.074              NA
##        sigma squared alpha trend     eb median p value lower p value
## Trend          0.001    NA 0.007     NA     0.98351648   0.983016983
## BM             0.001    NA    NA     NA     0.26473526   0.249750250
## OU             0.001     0    NA     NA     0.30469530   0.292707293
## EB             0.000    NA    NA -0.032     0.06943057   0.000999001
## Stasis            NA    NA    NA     NA     0.99900100   0.999000999
##        upper p value
## Trend      0.9840160
## BM         0.2797203
## OU         0.3166833
## EB         0.1378621
## Stasis     0.9990010</code></pre>
<p>The relative fit of the OU model is decreased by constraining the fit of the optima to equal the ancestral state value.
In fact as the OU attraction parameter (alpha) is zero, the model is equal to a Brownian motion model but is penalised by having an extra parameter.
Note that indeed, the plots of the BM model and the OU model look nearly identical.</p>
</div>
</div>
<div id="multiple-modes-of-evolution-time-shifts" class="section level3">
<h3><span class="header-section-number">4.7.3</span> Multiple modes of evolution (time shifts)</h3>
<p>As well as fitting a single model to a sequence of disparity values we can also allow for the mode of evolution to shift at a single or multiple points in time.
The timing of a shift in mode can be based on an a prior expectation, such as a mass extinction event, or the model can test multiple points to allow to find time shift point with the highest likelihood.</p>
<p>Models can be fit using <code>model.test</code> but it can be more convenient to use <code>model.test.wrapper</code>.
Here we will compare the relative fit of Brownian motion, Trend, Ornstein-Uhlenbeck and a multi-mode Ornstein Uhlenbck model in which the optima changes at 66 million years ago, the Cretaceous-Palaeogene boundary.</p>
<p>For example, we could be testing the hypothesis that the extinction of non-avian dinosaurs allowed mammals to go from scurrying in the undergrowth (low optima/low disparity) to dominating all habitats (high optima/high disparity).
We will constrain the optima of OU model in the first time begin (i.e, pre-66 Mya) to equal the ancestral value:</p>
<div class="sourceCode" id="cb327"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb327-1" data-line-number="1">disp_time &lt;-<span class="st"> </span><span class="kw">model.test.wrapper</span>(<span class="dt">data =</span> BeckLee_disparity,</a>
<a class="sourceLine" id="cb327-2" data-line-number="2">                        <span class="dt">model =</span> <span class="kw">c</span>(<span class="st">&quot;BM&quot;</span>, <span class="st">&quot;Trend&quot;</span>, <span class="st">&quot;OU&quot;</span>, <span class="st">&quot;multi.OU&quot;</span>),</a>
<a class="sourceLine" id="cb327-3" data-line-number="3">                                <span class="dt">time.split =</span> <span class="dv">66</span>,</a>
<a class="sourceLine" id="cb327-4" data-line-number="4">                                <span class="dt">pool.variance =</span> <span class="ot">NULL</span>,</a>
<a class="sourceLine" id="cb327-5" data-line-number="5">                                <span class="dt">show.p =</span> <span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb327-6" data-line-number="6">                                <span class="dt">fixed.optima =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<pre><code>## Evidence of equal variance (Bartlett&#39;s test of equal variances p = 0).
## Variance is not pooled.
## Running BM model...Done. Log-likelihood = 149.289
## Running Trend model...Done. Log-likelihood = 152.116
## Running OU model...Done. Log-likelihood = 149.289
## Running multi.OU model...Done. Log-likelihood = 152.116</code></pre>
<div class="figure" style="text-align: center"><span id="fig:plot5"></span>
<img src="dispRity_manual_files/figure-html/plot5-1.png" alt="Empirical disparity through time (pink), simulate data based on estimated model parameters (grey), delta AICc, and range of p values from the Rank Envelope test for BM, Trend, OU, and multi OU models with a shift in optima allowed at 66 Ma" width="1152" />
<p class="caption">
Figure 4.5: Empirical disparity through time (pink), simulate data based on estimated model parameters (grey), delta AICc, and range of p values from the Rank Envelope test for BM, Trend, OU, and multi OU models with a shift in optima allowed at 66 Ma
</p>
</div>
<div class="sourceCode" id="cb329"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb329-1" data-line-number="1">disp_time</a></code></pre></div>
<pre><code>##          aicc delta_aicc weight_aicc log.lik param ancestral state
## Trend    -298      0.000       0.636   152.1     3           3.255
## multi.OU -296      2.139       0.218   152.1     4           3.253
## BM       -294      3.550       0.108   149.3     2           3.267
## OU       -292      5.654       0.038   149.3     3           3.267
##          sigma squared trend alpha optima.2 median p value lower p value
## Trend            0.001 0.007    NA       NA      0.9870130     0.9870130
## multi.OU         0.001    NA 0.002    7.899      0.9730270     0.9710290
## BM               0.001    NA    NA       NA      0.2012987     0.1818182
## OU               0.001    NA 0.000       NA      0.2867133     0.2717283
##          upper p value
## Trend        0.9870130
## multi.OU     0.9750250
## BM           0.2207792
## OU           0.3016983</code></pre>
<p>The multi-OU model shows an increase an optima at the Cretaceous-Palaeogene boundary, indicating a shift in disparity.
However, this model does not fit as well as a model in which there is an increasing trend through time.
We can also fit a model in which the we specify a heterogeneous model but we do not give a <code>time.split</code>.
In this instance the model will test all splits that have at least 10 time slices on either side of the split.
That’s 102 potential time shifts in this example dataset so be warned, the following code will estimate 105 models!</p>
<div class="sourceCode" id="cb331"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb331-1" data-line-number="1"><span class="co">## An example of a time split model in which all potential splits are tested</span></a>
<a class="sourceLine" id="cb331-2" data-line-number="2"><span class="co">## </span><span class="al">WARNING</span><span class="co">: this will take between 20 minutes and half and hour to run!</span></a>
<a class="sourceLine" id="cb331-3" data-line-number="3">disp_time &lt;-<span class="st"> </span><span class="kw">model.test.wrapper</span>(<span class="dt">data =</span> BeckLee_disparity,</a>
<a class="sourceLine" id="cb331-4" data-line-number="4">                        <span class="dt">model =</span> <span class="kw">c</span>(<span class="st">&quot;BM&quot;</span>, <span class="st">&quot;Trend&quot;</span>, <span class="st">&quot;OU&quot;</span>, <span class="st">&quot;multi.OU&quot;</span>),</a>
<a class="sourceLine" id="cb331-5" data-line-number="5">                                <span class="dt">show.p =</span> <span class="ot">TRUE</span>, <span class="dt">fixed.optima =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<p>As well as specifying a multi-OU model we can run any combination of models.
For example we could fit a model at the Cretaceous-Palaeogene boundary that goes from an OU to a BM model, a Trend to an OU model, a Stasis to a Trend model or any combination you want to use.
The only model that can’t be used in combination is a multi-OU model.</p>
<p>These can be introduced by changing the input for the models into a list, and supplying a vector with the two models.
This is easier to see with an example:</p>
<div class="sourceCode" id="cb332"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb332-1" data-line-number="1"><span class="co">## The models to test</span></a>
<a class="sourceLine" id="cb332-2" data-line-number="2">my_models &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">c</span>(<span class="st">&quot;BM&quot;</span>, <span class="st">&quot;OU&quot;</span>),</a>
<a class="sourceLine" id="cb332-3" data-line-number="3">                  <span class="kw">c</span>(<span class="st">&quot;Stasis&quot;</span>, <span class="st">&quot;OU&quot;</span>),</a>
<a class="sourceLine" id="cb332-4" data-line-number="4">                  <span class="kw">c</span>(<span class="st">&quot;BM&quot;</span>, <span class="st">&quot;Stasis&quot;</span>),</a>
<a class="sourceLine" id="cb332-5" data-line-number="5">                  <span class="kw">c</span>(<span class="st">&quot;OU&quot;</span>, <span class="st">&quot;Trend&quot;</span>),</a>
<a class="sourceLine" id="cb332-6" data-line-number="6">                  <span class="kw">c</span>(<span class="st">&quot;Stasis&quot;</span>, <span class="st">&quot;BM&quot;</span>))</a>
<a class="sourceLine" id="cb332-7" data-line-number="7"></a>
<a class="sourceLine" id="cb332-8" data-line-number="8"><span class="co">## Testing the models</span></a>
<a class="sourceLine" id="cb332-9" data-line-number="9">disp_time &lt;-<span class="st"> </span><span class="kw">model.test.wrapper</span>(<span class="dt">data =</span> BeckLee_disparity,</a>
<a class="sourceLine" id="cb332-10" data-line-number="10">                                <span class="dt">model =</span> my_models, <span class="dt">time.split =</span> <span class="dv">66</span>,</a>
<a class="sourceLine" id="cb332-11" data-line-number="11">                                <span class="dt">show.p =</span> <span class="ot">TRUE</span>, <span class="dt">fixed.optima =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<pre><code>## Evidence of equal variance (Bartlett&#39;s test of equal variances p = 0).
## Variance is not pooled.
## Running BM:OU model...Done. Log-likelihood = 144.102
## Running Stasis:OU model...Done. Log-likelihood = 125.066
## Running BM:Stasis model...Done. Log-likelihood = 69.265
## Running OU:Trend model...Done. Log-likelihood = 147.839
## Running Stasis:BM model...Done. Log-likelihood = 125.066</code></pre>
<div class="figure" style="text-align: center"><span id="fig:plot6"></span>
<img src="dispRity_manual_files/figure-html/plot6-1.png" alt="Empirical disparity through time (pink), simulate data based on estimated model parameters (grey), delta AICc, and range of p values from the Rank Envelope test for a variety of models with a shift in optima allowed at 66 Ma" width="1152" />
<p class="caption">
Figure 4.6: Empirical disparity through time (pink), simulate data based on estimated model parameters (grey), delta AICc, and range of p values from the Rank Envelope test for a variety of models with a shift in optima allowed at 66 Ma
</p>
</div>
<div class="sourceCode" id="cb334"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb334-1" data-line-number="1">disp_time</a></code></pre></div>
<pre><code>##           aicc delta_aicc weight_aicc log.lik param ancestral state
## OU:Trend  -287        0.0       0.977   147.8     4           3.352
## BM:OU     -280        7.5       0.023   144.1     4           3.350
## Stasis:BM -244       43.4       0.000   125.1     3              NA
## Stasis:OU -240       47.7       0.000   125.1     5              NA
## BM:Stasis -130      157.1       0.000    69.3     4           3.268
##           sigma squared alpha optima.1 theta.1 omega trend median p value
## OU:Trend          0.001 0.041       NA      NA    NA 0.011      0.3246753
## BM:OU             0.001 0.000    4.092      NA    NA    NA      0.5009990
## Stasis:BM         0.002    NA       NA   3.390 0.004    NA      0.9970030
## Stasis:OU         0.002 0.000    4.092   3.390 0.004    NA      1.0000000
## BM:Stasis         0.000    NA       NA   3.806 0.058    NA      1.0000000
##           lower p value upper p value
## OU:Trend      0.2957043     0.3536464
## BM:OU         0.4885115     0.5134865
## Stasis:BM     0.9970030     0.9970030
## Stasis:OU     1.0000000     1.0000000
## BM:Stasis     1.0000000     1.0000000</code></pre>
</div>
<div id="model.test.sim" class="section level3">
<h3><span class="header-section-number">4.7.4</span> <code>model.test.sim</code></h3>
<p>Note that all the models above where run using the <code>model.test.wrapper</code> function that is a… wrapping function!
In practice, this function runs two main functions from the <code>dispRity</code> package and then plots the results:</p>
<ul>
<li><code>model.test</code> and</li>
<li><code>model.test.sim</code></li>
</ul>
<p>The <code>model.test.sim</code> allows to simulate disparity evolution given a <code>dispRity</code> object input (as in <code>model.test.wrapper</code>) or given a model and its specification.
For example, it is possible to simulate a simple Brownian motion model (or any of the other models or models combination described above):</p>
<div class="sourceCode" id="cb336"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb336-1" data-line-number="1"><span class="co">## A simple BM model</span></a>
<a class="sourceLine" id="cb336-2" data-line-number="2">model_simulation &lt;-<span class="st"> </span><span class="kw">model.test.sim</span>(<span class="dt">sim =</span> <span class="dv">1000</span>, <span class="dt">model =</span> <span class="st">&quot;BM&quot;</span>,</a>
<a class="sourceLine" id="cb336-3" data-line-number="3">                                   <span class="dt">time.span =</span> <span class="dv">50</span>, <span class="dt">variance =</span> <span class="fl">0.1</span>,</a>
<a class="sourceLine" id="cb336-4" data-line-number="4">                                   <span class="dt">sample.size =</span> <span class="dv">100</span>,</a>
<a class="sourceLine" id="cb336-5" data-line-number="5">                                   <span class="dt">parameters =</span> <span class="kw">list</span>(<span class="dt">ancestral.state =</span> <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb336-6" data-line-number="6">model_simulation</a></code></pre></div>
<pre><code>## Disparity evolution model simulation:
## Call: model.test.sim(sim = 1000, model = &quot;BM&quot;, time.span = 50, variance = 0.1, sample.size = 100, parameters = list(ancestral.state = 0)) 
## 
## Model simulated (1000 times):
## [1] &quot;BM&quot;</code></pre>
<p>This will simulate 1000 Brownian motions for 50 units of time with 100 sampled elements, a variance of 0.1 and an ancestral state of 0.
We can also pass multiple models in the same way we did it for <code>model.test</code>
This model can then be summarised and plotted as most <code>dispRity</code> objects:</p>
<div class="sourceCode" id="cb338"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb338-1" data-line-number="1"><span class="co">## Displaying the 5 first rows of the summary</span></a>
<a class="sourceLine" id="cb338-2" data-line-number="2"><span class="kw">head</span>(<span class="kw">summary</span>(model_simulation))</a></code></pre></div>
<pre><code>##   subsets   n var      median      2.5%        25%       75%    97.5%
## 1      50 100 0.1 -0.06195918 -1.963569 -0.7361336 0.5556715 1.806730
## 2      49 100 0.1 -0.09905061 -2.799025 -1.0670018 0.8836605 2.693583
## 3      48 100 0.1 -0.06215828 -3.594213 -1.3070097 1.1349712 3.272569
## 4      47 100 0.1 -0.10602238 -3.949521 -1.4363010 1.2234625 3.931000
## 5      46 100 0.1 -0.09016928 -4.277897 -1.5791755 1.3889584 4.507491
## 6      45 100 0.1 -0.13183180 -5.115647 -1.7791878 1.6270527 5.144023</code></pre>
<div class="sourceCode" id="cb340"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb340-1" data-line-number="1"><span class="co">## Plotting the simulations</span></a>
<a class="sourceLine" id="cb340-2" data-line-number="2"><span class="kw">plot</span>(model_simulation)</a></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:plot7"></span>
<img src="dispRity_manual_files/figure-html/plot7-1.png" alt="A simulated Brownian motion" width="576" />
<p class="caption">
Figure 4.7: A simulated Brownian motion
</p>
</div>
<p>Note that these functions can take all the arguments that can be passed to <code>plot</code>, <code>summary</code>, <code>plot.dispRity</code> and <code>summary.dispRity</code>.</p>
<div id="simulating-tested-models" class="section level4">
<h4><span class="header-section-number">4.7.4.1</span> Simulating tested models</h4>
<p>Maybe more interestingly though, it is possible to pass the output of <code>model.test</code> directly to <code>model.test.sim</code> to simulate the models that fits the data the best and calculate the Rank Envelope test <em>p</em> value.
Let’s see that using the simple example from the start:</p>
<div class="sourceCode" id="cb341"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb341-1" data-line-number="1"><span class="co">## Fitting multiple models on the data set</span></a>
<a class="sourceLine" id="cb341-2" data-line-number="2">disp_time &lt;-<span class="st"> </span><span class="kw">model.test</span>(<span class="dt">data =</span> BeckLee_disparity,</a>
<a class="sourceLine" id="cb341-3" data-line-number="3">                    <span class="dt">model =</span> <span class="kw">c</span>(<span class="st">&quot;Stasis&quot;</span>, <span class="st">&quot;BM&quot;</span>, <span class="st">&quot;OU&quot;</span>, <span class="st">&quot;Trend&quot;</span>, <span class="st">&quot;EB&quot;</span>))</a></code></pre></div>
<pre><code>## Evidence of equal variance (Bartlett&#39;s test of equal variances p = 0).
## Variance is not pooled.
## Running Stasis model...Done. Log-likelihood = -18.694
## Running BM model...Done. Log-likelihood = 149.289
## Running OU model...Done. Log-likelihood = 152.119
## Running Trend model...Done. Log-likelihood = 152.116
## Running EB model...Done. Log-likelihood = 126.268</code></pre>
<div class="sourceCode" id="cb343"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb343-1" data-line-number="1"><span class="kw">summary</span>(disp_time)</a></code></pre></div>
<pre><code>##        aicc delta_aicc weight_aicc log.lik param theta.1 omega ancestral state
## Stasis   41      339.5       0.000   -18.7     2   3.629 0.074              NA
## BM     -294        3.6       0.112   149.3     2      NA    NA           3.267
## OU     -296        2.1       0.227   152.1     4      NA    NA           3.254
## Trend  -298        0.0       0.661   152.1     3      NA    NA           3.255
## EB     -246       51.7       0.000   126.3     3      NA    NA           4.092
##        sigma squared alpha optima.1 trend     eb
## Stasis            NA    NA       NA    NA     NA
## BM             0.001    NA       NA    NA     NA
## OU             0.001 0.001    12.88    NA     NA
## Trend          0.001    NA       NA 0.007     NA
## EB             0.000    NA       NA    NA -0.032</code></pre>
<p>As seen before, the Trend model fitted this dataset the best.
To simulate what 1000 Trend models would look like using the same parameters as the ones estimated with <code>model.test</code> (here the ancestral state being 3.255, the sigma squared being 0.001 and the trend of 0.007), we can simply pass this model to <code>model.test.sim</code>:</p>
<div class="sourceCode" id="cb345"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb345-1" data-line-number="1"><span class="co">## Simulating 1000 Trend model with the observed parameters</span></a>
<a class="sourceLine" id="cb345-2" data-line-number="2">sim_trend &lt;-<span class="st"> </span><span class="kw">model.test.sim</span>(<span class="dt">sim =</span> <span class="dv">1000</span>, <span class="dt">model =</span> disp_time)</a>
<a class="sourceLine" id="cb345-3" data-line-number="3">sim_trend</a></code></pre></div>
<pre><code>## Disparity evolution model simulation:
## Call: model.test.sim(sim = 1000, model = disp_time) 
## 
## Model simulated (1000 times):
##       aicc log.lik param ancestral state sigma squared trend
## Trend -298   152.1     3           3.255         0.001 0.007
## 
## Rank envelope test
##  p-value of the test: 0.99001 (ties method: midrank)
##  p-interval         : (0.99001, 0.99001)</code></pre>
<p>By default, the model simulated is the one with the lowest AICc (<code>model.rank = 1</code>) but it is possible to choose any ranked model, for example, the OU (second one):</p>
<div class="sourceCode" id="cb347"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb347-1" data-line-number="1"><span class="co">## Simulating 1000 OU model with the observed parameters</span></a>
<a class="sourceLine" id="cb347-2" data-line-number="2">sim_OU &lt;-<span class="st"> </span><span class="kw">model.test.sim</span>(<span class="dt">sim =</span> <span class="dv">1000</span>, <span class="dt">model =</span> disp_time,</a>
<a class="sourceLine" id="cb347-3" data-line-number="3">                         <span class="dt">model.rank =</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb347-4" data-line-number="4">sim_OU</a></code></pre></div>
<pre><code>## Disparity evolution model simulation:
## Call: model.test.sim(sim = 1000, model = disp_time, model.rank = 2) 
## 
## Model simulated (1000 times):
##    aicc log.lik param ancestral state sigma squared alpha optima.1
## OU -296   152.1     4           3.254         0.001 0.001    12.88
## 
## Rank envelope test
##  p-value of the test: 0.9915085 (ties method: midrank)
##  p-interval         : (0.991009, 0.992008)</code></pre>
<p>And as the example above, the simulated data can be plotted or summarised:</p>
<div class="sourceCode" id="cb349"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb349-1" data-line-number="1"><span class="kw">head</span>(<span class="kw">summary</span>(sim_trend))</a></code></pre></div>
<pre><code>##   subsets n        var   median     2.5%      25%      75%    97.5%
## 1     120 5 0.01723152 3.255121 3.135057 3.219150 3.293407 3.375118
## 2     119 5 0.03555816 3.265538 3.093355 3.200493 3.323520 3.440795
## 3     118 6 0.03833089 3.269497 3.090438 3.212015 3.329629 3.443074
## 4     117 7 0.03264826 3.279180 3.112205 3.224810 3.336801 3.447997
## 5     116 7 0.03264826 3.284500 3.114788 3.223247 3.347970 3.463631
## 6     115 7 0.03264826 3.293918 3.101298 3.231659 3.354321 3.474645</code></pre>
<div class="sourceCode" id="cb351"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb351-1" data-line-number="1"><span class="kw">head</span>(<span class="kw">summary</span>(sim_OU))</a></code></pre></div>
<pre><code>##   subsets n        var   median     2.5%      25%      75%    97.5%
## 1     120 5 0.01723152 3.253446 3.141550 3.212259 3.293839 3.371701
## 2     119 5 0.03555816 3.263230 3.083542 3.197505 3.324500 3.440508
## 3     118 6 0.03833089 3.262999 3.101401 3.203909 3.332642 3.440208
## 4     117 7 0.03264826 3.272600 3.104511 3.214542 3.330617 3.442819
## 5     116 7 0.03264826 3.280440 3.100239 3.219782 3.342742 3.475893
## 6     115 7 0.03264826 3.287360 3.094703 3.222526 3.355281 3.477519</code></pre>
<div class="sourceCode" id="cb353"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb353-1" data-line-number="1"><span class="co">## The trend model with some graphical options</span></a>
<a class="sourceLine" id="cb353-2" data-line-number="2"><span class="kw">plot</span>(sim_trend, <span class="dt">xlab =</span> <span class="st">&quot;Time (Mya)&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;sum of variances&quot;</span>,</a>
<a class="sourceLine" id="cb353-3" data-line-number="3">    <span class="dt">col =</span> <span class="kw">c</span>(<span class="st">&quot;#F65205&quot;</span>, <span class="st">&quot;#F38336&quot;</span>, <span class="st">&quot;#F7B27E&quot;</span>))</a>
<a class="sourceLine" id="cb353-4" data-line-number="4"></a>
<a class="sourceLine" id="cb353-5" data-line-number="5"><span class="co">## Adding the observed disparity through time</span></a>
<a class="sourceLine" id="cb353-6" data-line-number="6"><span class="kw">plot</span>(BeckLee_disparity, <span class="dt">add =</span> <span class="ot">TRUE</span>, <span class="dt">col =</span> <span class="kw">c</span>(<span class="st">&quot;#3E9CBA&quot;</span>, <span class="st">&quot;#98D4CF90&quot;</span>, <span class="st">&quot;#BFE4E390&quot;</span>))</a></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:plot8"></span>
<img src="dispRity_manual_files/figure-html/plot8-1.png" alt="The best fitted model (Trend) and the observed disparity through time" width="576" />
<p class="caption">
Figure 4.8: The best fitted model (Trend) and the observed disparity through time
</p>
</div>
</div>
</div>
</div>
<div id="disparity-distribution" class="section level2">
<h2><span class="header-section-number">4.8</span> Disparity as a distribution</h2>
<p>Disparity is often regarded as a summary value of the position of the all elements in the ordinated space.
For example, the sum of variances, the product of ranges or the median distance between the elements and their centroid will summarise disparity as a single value.
This value can be pseudo-replicated (bootstrapped) to obtain a distribution of the summary metric with estimated error.
However, another way to perform disparity analysis is to use the <em>whole distribution</em> rather than just a summary metric (e.g. the variances or the ranges).</p>
<p>This is possible in the <code>dispRity</code> package by calculating disparity as a dimension-level 2 metric only!
Let’s have a look using our <a href="#summarising-dispRity-data-plots">previous example</a> of bootstrapped time slices but by measuring the distances between each taxon and their centroid as disparity.</p>
<div class="sourceCode" id="cb354"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb354-1" data-line-number="1"><span class="co">## Measuring disparity as a whole distribution</span></a>
<a class="sourceLine" id="cb354-2" data-line-number="2">disparity_centroids &lt;-<span class="st"> </span><span class="kw">dispRity</span>(boot_time_slices, </a>
<a class="sourceLine" id="cb354-3" data-line-number="3">                                <span class="dt">metric =</span> centroids)</a></code></pre></div>
<p>The resulting disparity object is of dimension-level 2, so it can easily be transformed into a dimension-level 1 object by, for example, measuring the median distance of all these distributions:</p>
<div class="sourceCode" id="cb355"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb355-1" data-line-number="1"><span class="co">## Measuring median disparity in each time slice</span></a>
<a class="sourceLine" id="cb355-2" data-line-number="2">disparity_centroids_median &lt;-<span class="st"> </span><span class="kw">dispRity</span>(disparity_centroids,</a>
<a class="sourceLine" id="cb355-3" data-line-number="3">                                       <span class="dt">metric =</span> median)</a></code></pre></div>
<p>And we can now compare the differences between these methods:</p>
<div class="sourceCode" id="cb356"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb356-1" data-line-number="1"><span class="co">## Summarising both disparity measurements:</span></a>
<a class="sourceLine" id="cb356-2" data-line-number="2"><span class="co">## The distributions:</span></a>
<a class="sourceLine" id="cb356-3" data-line-number="3"><span class="kw">summary</span>(disparity_centroids)</a></code></pre></div>
<pre><code>##   subsets  n obs.median bs.median  2.5%   25%   75% 97.5%
## 1     120  5      1.605     1.369 0.849 1.208 1.662 1.915
## 2      80 19      1.834     1.776 1.527 1.687 1.848 1.967
## 3      40 15      1.804     1.782 1.403 1.682 1.895 2.096
## 4       0 10      1.911     1.823 1.376 1.711 1.965 2.104</code></pre>
<div class="sourceCode" id="cb358"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb358-1" data-line-number="1"><span class="co">## The summary of the distributions (as median)</span></a>
<a class="sourceLine" id="cb358-2" data-line-number="2"><span class="kw">summary</span>(disparity_centroids_median)</a></code></pre></div>
<pre><code>##   subsets  n   obs bs.median  2.5%   25%   75% 97.5%
## 1     120  5 1.605     1.396 0.849 0.989 1.630 1.670
## 2      80 19 1.834     1.773 1.688 1.751 1.791 1.824
## 3      40 15 1.804     1.772 1.685 1.743 1.807 1.872
## 4       0 10 1.911     1.824 1.621 1.788 1.889 1.934</code></pre>
<p>We can see that the summary message for the distribution is slightly different than before.
Here <code>summary</code> also displays the observed central tendency (i.e. the central tendency of the measured distributions).
Note that, as expected, this central tendency is the same in both metrics!</p>
<p>Another, maybe more intuitive way, to compare both approaches for measuring disparity is to plot the distributions:</p>
<div class="sourceCode" id="cb360"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb360-1" data-line-number="1"><span class="co">## Graphical parameters</span></a>
<a class="sourceLine" id="cb360-2" data-line-number="2">op &lt;-<span class="st"> </span><span class="kw">par</span>(<span class="dt">bty =</span> <span class="st">&quot;n&quot;</span>, <span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))</a>
<a class="sourceLine" id="cb360-3" data-line-number="3"></a>
<a class="sourceLine" id="cb360-4" data-line-number="4"><span class="co">## Plotting both disparity measurements</span></a>
<a class="sourceLine" id="cb360-5" data-line-number="5"><span class="kw">plot</span>(disparity_centroids,</a>
<a class="sourceLine" id="cb360-6" data-line-number="6">     <span class="dt">ylab =</span> <span class="st">&quot;Distribution of all the distances&quot;</span>)</a>
<a class="sourceLine" id="cb360-7" data-line-number="7"><span class="kw">plot</span>(disparity_centroids_median,</a>
<a class="sourceLine" id="cb360-8" data-line-number="8">     <span class="dt">ylab =</span> <span class="st">&quot;Distribution of the medians of all the distances&quot;</span>)</a></code></pre></div>
<p><img src="dispRity_manual_files/figure-html/unnamed-chunk-107-1.png" width="768" /></p>
<div class="sourceCode" id="cb361"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb361-1" data-line-number="1"><span class="kw">par</span>(op)</a></code></pre></div>
<p>We can then test for differences in the resulting distributions using <code>test.dispRity</code> and the <code>bhatt.coeff</code> test as described above.</p>
<div class="sourceCode" id="cb362"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb362-1" data-line-number="1"><span class="co">## Probability of overlap in the distribution of medians</span></a>
<a class="sourceLine" id="cb362-2" data-line-number="2"><span class="kw">test.dispRity</span>(disparity_centroids_median, <span class="dt">test =</span> bhatt.coeff)</a></code></pre></div>
<pre><code>## Warning in test.dispRity(disparity_centroids_median, test = bhatt.coeff): Multiple p-values will be calculated without adjustment!
## This can inflate Type I error!</code></pre>
<pre><code>##          bhatt.coeff
## 120 : 80   0.1643168
## 120 : 40   0.1519868
## 120 : 0    0.2271532
## 80 : 40    0.8809326
## 80 : 0     0.5698764
## 40 : 0     0.7767260</code></pre>
<p>In this case, we are looking at the probability of overlap of the distribution of median distances from centroids among each pair of time slices.
In other words, we are measuring whether the medians from each bootstrap pseudo-replicate for each time slice overlap.
But of course, we might be interested in the actual distribution of the distances from the centroid rather than simply their central tendencies.
This can be problematic depending on the research question asked since we are effectively comparing non-independent medians distributions (because of the pseudo-replication).</p>
<p>One solution, therefore, is to look at the full distribution:</p>
<div class="sourceCode" id="cb365"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb365-1" data-line-number="1"><span class="co">## Probability of overlap for the full distributions</span></a>
<a class="sourceLine" id="cb365-2" data-line-number="2"><span class="kw">test.dispRity</span>(disparity_centroids, <span class="dt">test =</span> bhatt.coeff)</a></code></pre></div>
<pre><code>## Warning in test.dispRity(disparity_centroids, test = bhatt.coeff): Multiple p-values will be calculated without adjustment!
## This can inflate Type I error!</code></pre>
<pre><code>##          bhatt.coeff
## 120 : 80   0.5899902
## 120 : 40   0.6436707
## 120 : 0    0.6271424
## 80 : 40    0.9119738
## 80 : 0     0.8444125
## 40 : 0     0.9531318</code></pre>
<p>These results show the actual overlap among all the measured distances from centroids concatenated across all the bootstraps.
For example, when comparing the slices 120 and 80, we are effectively comparing the 5 <span class="math inline">\(\times\)</span> 100 distances (the distances of the five elements in slice 120 bootstrapped 100 times) to the 19 <span class="math inline">\(\times\)</span> 100 distances from slice 80.
However, this can also be problematic for some specific tests since the <em>n</em> <span class="math inline">\(\times\)</span> 100 distances are also pseudo-replicates and thus are still not independent.</p>
<p>A second solution is to compare the distributions to each other <em>for each replicate</em>:</p>
<div class="sourceCode" id="cb368"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb368-1" data-line-number="1"><span class="co">## Boostrapped probability of overlap for the full distributions</span></a>
<a class="sourceLine" id="cb368-2" data-line-number="2"><span class="kw">test.dispRity</span>(disparity_centroids, <span class="dt">test =</span> bhatt.coeff,</a>
<a class="sourceLine" id="cb368-3" data-line-number="3">              <span class="dt">concatenate =</span> <span class="ot">FALSE</span>)</a></code></pre></div>
<pre><code>## Warning in test.dispRity(disparity_centroids, test = bhatt.coeff, concatenate = FALSE): Multiple p-values will be calculated without adjustment!
## This can inflate Type I error!</code></pre>
<pre><code>##          bhatt.coeff      2.5%       25%       75%     97.5%
## 120 : 80   0.2582035 0.0000000 0.1695523 0.3745110 0.5652651
## 120 : 40   0.2985743 0.0000000 0.2000000 0.4499599 0.6444474
## 120 : 0    0.2527329 0.0000000 0.1414214 0.4000000 0.6007397
## 80 : 40    0.5762757 0.2036442 0.4400379 0.6924779 0.8713920
## 80 : 0     0.4579673 0.1227841 0.3487172 0.6082889 0.7583736
## 40 : 0     0.5616576 0.2449490 0.4420687 0.6838864 0.8757140</code></pre>
<p>These results show the median overlap among pairs of distributions in the first column (<code>bhatt.coeff</code>) and then the distribution of these overlaps among each pair of bootstraps.
In other words, when two distributions are compared, they are now compared for each bootstrap pseudo-replicate, thus effectively creating a distribution of probabilities of overlap.
For example, when comparing the slices 120 and 80, we have a mean probability of overlap of 0.28 and a probability between 0.18 and 0.43 in 50% of the pseudo-replicates.
Note that the quantiles and central tendencies can be modified via the <code>conc.quantiles</code> option.</p>
</div>
<div id="other-matrices" class="section level2">
<h2><span class="header-section-number">4.9</span> Disparity from other matrices</h2>
<p>In the example so far, disparity was measured from an ordinated multidimensional space (i.e. a PCO of the distances between taxa based on discrete morphological characters).
This is a common approach in palaeobiology, morphometrics or ecology but ordinated matrices are not mandatory for the <code>dispRity</code> package!
It is totally possible to perform the same analysis detailed above using other types of matrices as long as your elements are rows in your matrix.</p>
<p>For example, we can use the data set <code>eurodist</code>, an <code>R</code> inbuilt dataset that contains the distances (in km) between European cities.
We can check for example, if Northern European cities are closer to each other than Southern ones:</p>
<div class="sourceCode" id="cb371"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb371-1" data-line-number="1"><span class="co">## Making the eurodist data set into a matrix (rather than &quot;dist&quot; object)</span></a>
<a class="sourceLine" id="cb371-2" data-line-number="2">eurodist &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(eurodist)</a>
<a class="sourceLine" id="cb371-3" data-line-number="3">eurodist[<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>]</a></code></pre></div>
<pre><code>##           Athens Barcelona Brussels Calais Cherbourg
## Athens         0      3313     2963   3175      3339
## Barcelona   3313         0     1318   1326      1294
## Brussels    2963      1318        0    204       583
## Calais      3175      1326      204      0       460
## Cherbourg   3339      1294      583    460         0</code></pre>
<div class="sourceCode" id="cb373"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb373-1" data-line-number="1"><span class="co">## The two groups of cities</span></a>
<a class="sourceLine" id="cb373-2" data-line-number="2">Northern &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Brussels&quot;</span>, <span class="st">&quot;Calais&quot;</span>, <span class="st">&quot;Cherbourg&quot;</span>, <span class="st">&quot;Cologne&quot;</span>, <span class="st">&quot;Copenhagen&quot;</span>,</a>
<a class="sourceLine" id="cb373-3" data-line-number="3">              <span class="st">&quot;Hamburg&quot;</span>, <span class="st">&quot;Hook of Holland&quot;</span>, <span class="st">&quot;Paris&quot;</span>, <span class="st">&quot;Stockholm&quot;</span>)</a>
<a class="sourceLine" id="cb373-4" data-line-number="4">Southern &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Athens&quot;</span>, <span class="st">&quot;Barcelona&quot;</span>, <span class="st">&quot;Geneva&quot;</span>, <span class="st">&quot;Gibraltar&quot;</span>, <span class="st">&quot;Lisbon&quot;</span>, <span class="st">&quot;Lyons&quot;</span>,</a>
<a class="sourceLine" id="cb373-5" data-line-number="5">              <span class="st">&quot;Madrid&quot;</span>, <span class="st">&quot;Marseilles&quot;</span>, <span class="st">&quot;Milan&quot;</span>, <span class="st">&quot;Munich&quot;</span>, <span class="st">&quot;Rome&quot;</span>, <span class="st">&quot;Vienna&quot;</span>)</a>
<a class="sourceLine" id="cb373-6" data-line-number="6"></a>
<a class="sourceLine" id="cb373-7" data-line-number="7"><span class="co">## Creating the subset dispRity object</span></a>
<a class="sourceLine" id="cb373-8" data-line-number="8">eurodist_subsets &lt;-<span class="st"> </span><span class="kw">custom.subsets</span>(eurodist, <span class="dt">group =</span> <span class="kw">list</span>(<span class="st">&quot;Northern&quot;</span> =<span class="st"> </span>Northern,</a>
<a class="sourceLine" id="cb373-9" data-line-number="9">                                                        <span class="st">&quot;Southern&quot;</span> =<span class="st"> </span>Southern))</a></code></pre></div>
<pre><code>## Warning: custom.subsets is applied on what seems to be a distance matrix.
## The resulting matrices won&#39;t be distance matrices anymore!</code></pre>
<div class="sourceCode" id="cb375"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb375-1" data-line-number="1"><span class="co">## Bootstrapping and rarefying to 9 elements (the number of Northern cities)</span></a>
<a class="sourceLine" id="cb375-2" data-line-number="2">eurodist_bs &lt;-<span class="st"> </span><span class="kw">boot.matrix</span>(eurodist_subsets, <span class="dt">rarefaction =</span> <span class="dv">9</span>)</a>
<a class="sourceLine" id="cb375-3" data-line-number="3"></a>
<a class="sourceLine" id="cb375-4" data-line-number="4"><span class="co">## Measuring disparity as the median distance from group&#39;s centroid</span></a>
<a class="sourceLine" id="cb375-5" data-line-number="5">euro_disp &lt;-<span class="st"> </span><span class="kw">dispRity</span>(eurodist_bs, <span class="dt">metric =</span> <span class="kw">c</span>(median, centroids))</a>
<a class="sourceLine" id="cb375-6" data-line-number="6"></a>
<a class="sourceLine" id="cb375-7" data-line-number="7"><span class="co">## Testing the differences using a simple wilcox.test</span></a>
<a class="sourceLine" id="cb375-8" data-line-number="8">euro_diff &lt;-<span class="st"> </span><span class="kw">test.dispRity</span>(euro_disp, <span class="dt">test =</span> wilcox.test)</a>
<a class="sourceLine" id="cb375-9" data-line-number="9">euro_diff_rar &lt;-<span class="st"> </span><span class="kw">test.dispRity</span>(euro_disp, <span class="dt">test =</span> wilcox.test, <span class="dt">rarefaction =</span> <span class="dv">9</span>)</a></code></pre></div>
<p>We can compare this approach to an ordination one:</p>
<div class="sourceCode" id="cb376"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb376-1" data-line-number="1"><span class="co">## Ordinating the eurodist matrix (with 11 dimensions)</span></a>
<a class="sourceLine" id="cb376-2" data-line-number="2">euro_ord &lt;-<span class="st"> </span><span class="kw">cmdscale</span>(eurodist, <span class="dt">k =</span> <span class="dv">11</span>)</a>
<a class="sourceLine" id="cb376-3" data-line-number="3"></a>
<a class="sourceLine" id="cb376-4" data-line-number="4"><span class="co">## Calculating disparity on the bootstrapped and rarefied subset data</span></a>
<a class="sourceLine" id="cb376-5" data-line-number="5">euro_ord_disp &lt;-<span class="st"> </span><span class="kw">dispRity</span>(<span class="kw">boot.matrix</span>(<span class="kw">custom.subsets</span>(euro_ord, <span class="dt">group =</span></a>
<a class="sourceLine" id="cb376-6" data-line-number="6">        <span class="kw">list</span>(<span class="st">&quot;Northern&quot;</span> =<span class="st"> </span>Northern, <span class="st">&quot;Southern&quot;</span> =<span class="st"> </span>Southern)), <span class="dt">rarefaction =</span> <span class="dv">9</span>),</a>
<a class="sourceLine" id="cb376-7" data-line-number="7">        <span class="dt">metric =</span> <span class="kw">c</span>(median, centroids))</a>
<a class="sourceLine" id="cb376-8" data-line-number="8"></a>
<a class="sourceLine" id="cb376-9" data-line-number="9"><span class="co">## Testing the differences using a simple wilcox.test</span></a>
<a class="sourceLine" id="cb376-10" data-line-number="10">euro_ord_diff &lt;-<span class="st"> </span><span class="kw">test.dispRity</span>(euro_ord_disp, <span class="dt">test =</span> wilcox.test)</a>
<a class="sourceLine" id="cb376-11" data-line-number="11">euro_ord_diff_rar &lt;-<span class="st"> </span><span class="kw">test.dispRity</span>(euro_ord_disp, <span class="dt">test =</span> wilcox.test, <span class="dt">rarefaction =</span> <span class="dv">9</span>)</a></code></pre></div>
<p>And visualise the differences:</p>
<div class="sourceCode" id="cb377"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb377-1" data-line-number="1"><span class="co">## Plotting the differences</span></a>
<a class="sourceLine" id="cb377-2" data-line-number="2"><span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">2</span>), <span class="dt">bty =</span> <span class="st">&quot;n&quot;</span>)</a>
<a class="sourceLine" id="cb377-3" data-line-number="3"><span class="co">## Plotting the normal disparity</span></a>
<a class="sourceLine" id="cb377-4" data-line-number="4"><span class="kw">plot</span>(euro_disp, <span class="dt">main =</span> <span class="st">&quot;Distance differences&quot;</span>)</a>
<a class="sourceLine" id="cb377-5" data-line-number="5"><span class="co">## Adding the p-value</span></a>
<a class="sourceLine" id="cb377-6" data-line-number="6"><span class="kw">text</span>(<span class="fl">1.5</span>, <span class="dv">4000</span>, <span class="kw">paste0</span>(<span class="st">&quot;p=&quot;</span>,<span class="kw">round</span>(euro_diff[[<span class="dv">2</span>]][[<span class="dv">1</span>]], <span class="dt">digit =</span> <span class="dv">5</span>)))</a>
<a class="sourceLine" id="cb377-7" data-line-number="7"><span class="co">## Plotting the rarefied disparity</span></a>
<a class="sourceLine" id="cb377-8" data-line-number="8"><span class="kw">plot</span>(euro_disp, <span class="dt">rarefaction =</span> <span class="dv">9</span>, <span class="dt">main =</span> <span class="st">&quot;Distance differences (rarefied)&quot;</span>)</a>
<a class="sourceLine" id="cb377-9" data-line-number="9"><span class="co">## Adding the p-value</span></a>
<a class="sourceLine" id="cb377-10" data-line-number="10"><span class="kw">text</span>(<span class="fl">1.5</span>, <span class="dv">4000</span>, <span class="kw">paste0</span>(<span class="st">&quot;p=&quot;</span>,<span class="kw">round</span>(euro_diff_rar[[<span class="dv">2</span>]][[<span class="dv">1</span>]], <span class="dt">digit =</span> <span class="dv">5</span>)))</a>
<a class="sourceLine" id="cb377-11" data-line-number="11"></a>
<a class="sourceLine" id="cb377-12" data-line-number="12"><span class="co">## Plotting the ordinated disparity</span></a>
<a class="sourceLine" id="cb377-13" data-line-number="13"><span class="kw">plot</span>(euro_ord_disp, <span class="dt">main =</span> <span class="st">&quot;Ordinated differences&quot;</span>)</a>
<a class="sourceLine" id="cb377-14" data-line-number="14"><span class="co">## Adding the p-value</span></a>
<a class="sourceLine" id="cb377-15" data-line-number="15"><span class="kw">text</span>(<span class="fl">1.5</span>, <span class="dv">1400</span>, <span class="kw">paste0</span>(<span class="st">&quot;p=&quot;</span>,<span class="kw">round</span>(euro_ord_diff[[<span class="dv">2</span>]][[<span class="dv">1</span>]], <span class="dt">digit =</span> <span class="dv">5</span>) ))</a>
<a class="sourceLine" id="cb377-16" data-line-number="16"><span class="co">## Plotting the rarefied disparity</span></a>
<a class="sourceLine" id="cb377-17" data-line-number="17"><span class="kw">plot</span>(euro_ord_disp, <span class="dt">rarefaction =</span> <span class="dv">9</span>, <span class="dt">main =</span> <span class="st">&quot;Ordinated differences (rarefied)&quot;</span>)</a>
<a class="sourceLine" id="cb377-18" data-line-number="18"><span class="co">## Adding the p-value</span></a>
<a class="sourceLine" id="cb377-19" data-line-number="19"><span class="kw">text</span>(<span class="fl">1.5</span>, <span class="dv">1400</span>, <span class="kw">paste0</span>(<span class="st">&quot;p=&quot;</span>,<span class="kw">round</span>(euro_ord_diff_rar[[<span class="dv">2</span>]][[<span class="dv">1</span>]], <span class="dt">digit =</span> <span class="dv">5</span>) ))</a></code></pre></div>
<p><img src="dispRity_manual_files/figure-html/unnamed-chunk-113-1.png" width="1152" /></p>
<p>As expected, the results are pretty similar in pattern but different in terms of scale.
The median centroids distance is expressed in km in the “Distance differences” plots and in Euclidean units of variation in the “Ordinated differences” plots.</p>
</div>
<div id="multi.input" class="section level2">
<h2><span class="header-section-number">4.10</span> Disparity from multiple matrices (and multiple trees!)</h2>
<p>Since the version <code>1.4</code> of this package, it is possible to use multiple trees and multiple matrices in <code>dispRity</code> objects.
To use multiple matrices, this is rather easy: just supply a list of matrices to any of the <code>dispRity</code> functions and, as long as they have the same size and the same rownames they will be handled as a distribution of matrices.</p>
<div class="sourceCode" id="cb378"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb378-1" data-line-number="1"><span class="kw">set.seed</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb378-2" data-line-number="2"><span class="co">## Creating 3 matrices with 4 dimensions and 10 elements each (called t1, t2, t3, etc...)</span></a>
<a class="sourceLine" id="cb378-3" data-line-number="3">matrix_list &lt;-<span class="st"> </span><span class="kw">replicate</span>(<span class="dv">3</span>, <span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">40</span>), <span class="dv">10</span>, <span class="dv">4</span>, <span class="dt">dimnames =</span> <span class="kw">list</span>(<span class="kw">paste0</span>(<span class="st">&quot;t&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>))),</a>
<a class="sourceLine" id="cb378-4" data-line-number="4">                         <span class="dt">simplify =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb378-5" data-line-number="5"><span class="kw">class</span>(matrix_list) <span class="co"># This is a list of matrices</span></a></code></pre></div>
<pre><code>## [1] &quot;list&quot;</code></pre>
<div class="sourceCode" id="cb380"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb380-1" data-line-number="1"><span class="co">## Measuring some disparity metric on one of the matrices</span></a>
<a class="sourceLine" id="cb380-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(matrix_list[[<span class="dv">1</span>]], <span class="dt">metric =</span> <span class="kw">c</span>(sum, variances)))</a></code></pre></div>
<pre><code>##   subsets  n  obs
## 1       1 10 3.32</code></pre>
<div class="sourceCode" id="cb382"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb382-1" data-line-number="1"><span class="co">## Measuring the same disparity metric on the three matrices</span></a>
<a class="sourceLine" id="cb382-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">dispRity</span>(matrix_list, <span class="dt">metric =</span> <span class="kw">c</span>(sum, variances)))</a></code></pre></div>
<pre><code>##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10       3.32 3.044 3.175 3.381 3.435</code></pre>
<p>As you can see, when measuring the sum of variances on multiple matrices, we now have a distribution of sum of variances rather than a single observed value.</p>
<p>Similarly as running disparity analysis using multiple matrices, you can run the <code>chrono.subsets</code> function using multiple trees.
This can be useful if you want to use a tree posterior distribution rather than a single consensus tree.
These trees can be passed to <code>chrono.subsets</code> as a <code>&quot;multiPhylo&quot;</code> object (with the same node and tip labels in each tree).
First let’s define a function to generate multiple trees with the same labels and root ages:</p>
<div class="sourceCode" id="cb384"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb384-1" data-line-number="1"><span class="kw">set.seed</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb384-2" data-line-number="2"><span class="co">## Matches the trees and the matrices</span></a>
<a class="sourceLine" id="cb384-3" data-line-number="3"><span class="co">## A bunch of trees</span></a>
<a class="sourceLine" id="cb384-4" data-line-number="4">make.tree &lt;-<span class="st"> </span><span class="cf">function</span>(n, <span class="dt">fun =</span> rtree) {</a>
<a class="sourceLine" id="cb384-5" data-line-number="5">    <span class="co">## Make the tree</span></a>
<a class="sourceLine" id="cb384-6" data-line-number="6">    tree &lt;-<span class="st"> </span><span class="kw">fun</span>(n)</a>
<a class="sourceLine" id="cb384-7" data-line-number="7">    tree &lt;-<span class="st"> </span><span class="kw">chronos</span>(tree, <span class="dt">quiet =</span> <span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb384-8" data-line-number="8">                    <span class="dt">calibration =</span> <span class="kw">makeChronosCalib</span>(tree, <span class="dt">age.min =</span> <span class="dv">10</span>, <span class="dt">age.max =</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb384-9" data-line-number="9">    <span class="kw">class</span>(tree) &lt;-<span class="st"> &quot;phylo&quot;</span></a>
<a class="sourceLine" id="cb384-10" data-line-number="10">    <span class="co">## Add the node labels</span></a>
<a class="sourceLine" id="cb384-11" data-line-number="11">    tree<span class="op">$</span>node.label &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;n&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="kw">Nnode</span>(tree))</a>
<a class="sourceLine" id="cb384-12" data-line-number="12">    <span class="co">## Add the root time</span></a>
<a class="sourceLine" id="cb384-13" data-line-number="13">    tree<span class="op">$</span>root.time &lt;-<span class="st"> </span><span class="kw">max</span>(<span class="kw">tree.age</span>(tree)<span class="op">$</span>ages)</a>
<a class="sourceLine" id="cb384-14" data-line-number="14">    <span class="kw">return</span>(tree)</a>
<a class="sourceLine" id="cb384-15" data-line-number="15">}</a>
<a class="sourceLine" id="cb384-16" data-line-number="16">trees &lt;-<span class="st"> </span><span class="kw">replicate</span>(<span class="dv">3</span>, <span class="kw">make.tree</span>(<span class="dv">10</span>), <span class="dt">simplify =</span> <span class="ot">FALSE</span>)</a></code></pre></div>
<pre><code>## Warning: false convergence (8)</code></pre>
<div class="sourceCode" id="cb386"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb386-1" data-line-number="1"><span class="kw">class</span>(trees) &lt;-<span class="st"> &quot;multiPhylo&quot;</span></a>
<a class="sourceLine" id="cb386-2" data-line-number="2">trees</a></code></pre></div>
<pre><code>## 3 phylogenetic trees</code></pre>
<p>We can now simulate some ancestral states for the matrices in the example above to have multiple matrices associated with the multiple trees.</p>
<div class="sourceCode" id="cb388"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb388-1" data-line-number="1"><span class="co">## A function for running the ancestral states estimations</span></a>
<a class="sourceLine" id="cb388-2" data-line-number="2">do.ace &lt;-<span class="st"> </span><span class="cf">function</span>(tree, matrix) {</a>
<a class="sourceLine" id="cb388-3" data-line-number="3">    <span class="co">## Run one ace</span></a>
<a class="sourceLine" id="cb388-4" data-line-number="4">    fun.ace &lt;-<span class="st"> </span><span class="cf">function</span>(character, tree) {</a>
<a class="sourceLine" id="cb388-5" data-line-number="5">        results &lt;-<span class="st"> </span><span class="kw">ace</span>(character, <span class="dt">phy =</span> tree)<span class="op">$</span>ace</a>
<a class="sourceLine" id="cb388-6" data-line-number="6">        <span class="kw">names</span>(results) &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;n&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="kw">Nnode</span>(tree))</a>
<a class="sourceLine" id="cb388-7" data-line-number="7">        <span class="kw">return</span>(results)</a>
<a class="sourceLine" id="cb388-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb388-9" data-line-number="9">    <span class="co">## Run all ace</span></a>
<a class="sourceLine" id="cb388-10" data-line-number="10">    <span class="kw">return</span>(<span class="kw">rbind</span>(matrix, <span class="kw">apply</span>(matrix, <span class="dv">2</span>, fun.ace, <span class="dt">tree =</span> tree)))</a>
<a class="sourceLine" id="cb388-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb388-12" data-line-number="12"></a>
<a class="sourceLine" id="cb388-13" data-line-number="13"><span class="co">## All matrices</span></a>
<a class="sourceLine" id="cb388-14" data-line-number="14">matrices &lt;-<span class="st"> </span><span class="kw">mapply</span>(do.ace, trees, matrix_list, <span class="dt">SIMPLIFY =</span> <span class="ot">FALSE</span>)</a></code></pre></div>
<p>Let’s first see an example of time-slicing with one matrix and multiple trees.
This assumes that your tip values (observed) and node values (estimated) are fixed with no error on them.
It also assumes that the nodes in the matrix always corresponds to the node in the trees (in other words, the tree topologies are fixed):</p>
<div class="sourceCode" id="cb389"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb389-1" data-line-number="1"><span class="co">## Making three &quot;proximity&quot; time slices across one tree</span></a>
<a class="sourceLine" id="cb389-2" data-line-number="2">one_tree &lt;-<span class="st"> </span><span class="kw">chrono.subsets</span>(matrices[[<span class="dv">1</span>]], trees[[<span class="dv">1</span>]],</a>
<a class="sourceLine" id="cb389-3" data-line-number="3">                           <span class="dt">method =</span> <span class="st">&quot;continuous&quot;</span>,</a>
<a class="sourceLine" id="cb389-4" data-line-number="4">                           <span class="dt">model =</span> <span class="st">&quot;proximity&quot;</span>, <span class="dt">time =</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb389-5" data-line-number="5"><span class="co">## Making three &quot;proximity&quot; time slices across the three trees</span></a>
<a class="sourceLine" id="cb389-6" data-line-number="6">three_tree &lt;-<span class="st"> </span><span class="kw">chrono.subsets</span>(matrices[[<span class="dv">1</span>]], trees,</a>
<a class="sourceLine" id="cb389-7" data-line-number="7">                             <span class="dt">method =</span> <span class="st">&quot;continuous&quot;</span>,</a>
<a class="sourceLine" id="cb389-8" data-line-number="8">                             <span class="dt">model =</span> <span class="st">&quot;proximity&quot;</span>, <span class="dt">time =</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb389-9" data-line-number="9"><span class="co">## Measuring disparity as the sum of variances and summarising it</span></a>
<a class="sourceLine" id="cb389-10" data-line-number="10"><span class="kw">summary</span>(<span class="kw">dispRity</span>(one_tree, <span class="dt">metric =</span> <span class="kw">c</span>(sum, variances)))</a></code></pre></div>
<pre><code>##   subsets  n   obs
## 1     8.3  3 0.080
## 2    4.15  5 2.903
## 3       0 10 3.320</code></pre>
<div class="sourceCode" id="cb391"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb391-1" data-line-number="1"><span class="kw">summary</span>(<span class="kw">dispRity</span>(three_tree, <span class="dt">metric =</span> <span class="kw">c</span>(sum, variances)))</a></code></pre></div>
<pre><code>##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1     7.9  3      0.250 0.088 0.165 0.307 0.360
## 2    3.95  5      0.256 0.133 0.191 1.579 2.771
## 3       0 10      3.320 3.320 3.320 3.320 3.320</code></pre>
<p>This results show the effect of considering a tree distribution: in the first case (<code>one_tree</code>) the time slice at 3.95 Mya has a sum of variances of 2.9 but this values goes down to 0.256 in the second case (<code>three_tree</code>) which is due to the differences in branch lengths distributions:</p>
<div class="sourceCode" id="cb393"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb393-1" data-line-number="1"><span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">1</span>))</a>
<a class="sourceLine" id="cb393-2" data-line-number="2">slices &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">7.9</span>, <span class="fl">3.95</span>, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb393-3" data-line-number="3">fun.plot &lt;-<span class="st"> </span><span class="cf">function</span>(tree) {</a>
<a class="sourceLine" id="cb393-4" data-line-number="4">  <span class="kw">plot</span>(tree)</a>
<a class="sourceLine" id="cb393-5" data-line-number="5">  <span class="kw">nodelabels</span>(tree<span class="op">$</span>node.label, <span class="dt">cex =</span> <span class="fl">0.8</span>)</a>
<a class="sourceLine" id="cb393-6" data-line-number="6">  <span class="kw">axisPhylo</span>()</a>
<a class="sourceLine" id="cb393-7" data-line-number="7">  <span class="kw">abline</span>(<span class="dt">v =</span> tree<span class="op">$</span>root.time <span class="op">-</span><span class="st"> </span>slices)</a>
<a class="sourceLine" id="cb393-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb393-9" data-line-number="9">silent &lt;-<span class="st"> </span><span class="kw">lapply</span>(trees, fun.plot)</a></code></pre></div>
<p><img src="dispRity_manual_files/figure-html/unnamed-chunk-118-1.png" width="672" /></p>
<p>Note that in this example, the nodes are actually even different in each tree! The node <code>n4</code> for example, is not direct descendent of <code>t4</code> and <code>t6</code> in all trees!
To fix that, it is possible to input a list of trees and a list of matrices that correspond to each tree in <code>chrono.subsets</code> by using the <code>bind.data = TRUE</code> option.
In this case, the matrices need to all have the same row names and the trees all need the same labels as before:</p>
<div class="sourceCode" id="cb394"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb394-1" data-line-number="1"><span class="co">## Making three &quot;proximity&quot; time slices across three trees and three bound matrices</span></a>
<a class="sourceLine" id="cb394-2" data-line-number="2">bound_data &lt;-<span class="st"> </span><span class="kw">chrono.subsets</span>(matrices, trees,</a>
<a class="sourceLine" id="cb394-3" data-line-number="3">                             <span class="dt">method =</span> <span class="st">&quot;continuous&quot;</span>,</a>
<a class="sourceLine" id="cb394-4" data-line-number="4">                             <span class="dt">model =</span> <span class="st">&quot;proximity&quot;</span>,</a>
<a class="sourceLine" id="cb394-5" data-line-number="5">                             <span class="dt">time =</span> <span class="dv">3</span>,</a>
<a class="sourceLine" id="cb394-6" data-line-number="6">                             <span class="dt">bind.data =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb394-7" data-line-number="7"><span class="co">## Making three &quot;proximity&quot; time slices across three trees and three matrices</span></a>
<a class="sourceLine" id="cb394-8" data-line-number="8">unbound_data &lt;-<span class="st"> </span><span class="kw">chrono.subsets</span>(matrices, trees,</a>
<a class="sourceLine" id="cb394-9" data-line-number="9">                               <span class="dt">method =</span> <span class="st">&quot;continuous&quot;</span>,</a>
<a class="sourceLine" id="cb394-10" data-line-number="10">                               <span class="dt">model =</span> <span class="st">&quot;proximity&quot;</span>,</a>
<a class="sourceLine" id="cb394-11" data-line-number="11">                               <span class="dt">time =</span> <span class="dv">3</span>,</a>
<a class="sourceLine" id="cb394-12" data-line-number="12">                               <span class="dt">bind.data =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb394-13" data-line-number="13"></a>
<a class="sourceLine" id="cb394-14" data-line-number="14"><span class="co">## Measuring disparity as the sum of variances and summarising it</span></a>
<a class="sourceLine" id="cb394-15" data-line-number="15"><span class="kw">summary</span>(<span class="kw">dispRity</span>(bound_data, <span class="dt">metric =</span> <span class="kw">c</span>(sum, variances)))</a></code></pre></div>
<pre><code>##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1     7.9  3       0.08 0.076 0.078 0.273 0.447
## 2    3.95  5       1.79 0.353 1.034 2.347 2.848
## 3       0 10       3.32 3.044 3.175 3.381 3.435</code></pre>
<div class="sourceCode" id="cb396"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb396-1" data-line-number="1"><span class="kw">summary</span>(<span class="kw">dispRity</span>(unbound_data, <span class="dt">metric =</span> <span class="kw">c</span>(sum, variances)))</a></code></pre></div>
<pre><code>##   subsets  n obs.median 2.5%  25%  75% 97.5%
## 1     7.9  3       0.79 0.48 0.63 0.83  0.85
## 2    3.95  5       3.25 1.36 2.25 3.94  4.56
## 3       0 10       9.79 9.79 9.79 9.79  9.79</code></pre>
<p>Note here that the results are again rather different: with the bound data, the slices are done across the three trees and each of their corresponding matrix (resulting in three observation) which is more accurate than the previous results from <code>three_trees</code> above.
With the unbound data, the slices are done across the three trees and applied to the three matrices (resulting in 9 observations).
As we’ve seen before, this is incorrect in this case since the trees don’t have the same topology (so the nodes selected by a slice through the second tree are not equivalent to the nodes in the first matrix) but it can be useful if the topology is fixed to integrate both uncertainty in branch length (slicing through different trees) and uncertainty from, say, ancestral states estimations (applying the slices on different matrices).</p>
</div>
<div id="disparity-with-trees-dispritree" class="section level2">
<h2><span class="header-section-number">4.11</span> Disparity with trees: <em>dispRitree!</em></h2>
<p>Since the package’s version 1.5.10, trees can be directly attached to <code>dispRity</code> objects.
This allows any function in the package that has an input argument called “<code>tree</code>” to automatically intake the tree from the <code>dispRity</code> object.
This is especially useful for disparity metrics that requires calculations based on a phylogenetic tree (e.g. <code>ancestral.dist</code> or <code>projections.tree</code>) and if phylogeny (or phylogenie*s*) are going to be an important part of your analyses.</p>
<p>Trees are attached to <code>dispRity</code> object as soon as they are called in any function of the package (e.g. as an argument in <code>chrono.subsets</code> or in <code>dispRity</code>) and are stored in <code>my_dispRity_object$tree</code>.
You can always manually attach, detach or modify the tree parts of a <code>dispRity</code> object using the utility functions <code>get.tree</code> (to access the trees), <code>remove.tree</code> (to remove it) and <code>add.tree</code> (to… add trees!).
The only requirement for this to work is that the labels in the tree must match the ones in the data.
If the tree has node labels, their node labels must also match the data.
Similarly if the data has entries for node labels, they must be present in the tree.</p>
<p>Here is a quick demo on how attaching trees to <code>dispRity</code> objects can work and make your life easy: for example here we will measure how the sum of branch length changes through time when time slicing through some demo data with a acctran split time slice model (see more info <a href="details-of-specific-functions.html#chrono-subsets">here</a>).</p>
<div class="sourceCode" id="cb398"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb398-1" data-line-number="1"><span class="co">## Loading some demo data:</span></a>
<a class="sourceLine" id="cb398-2" data-line-number="2"><span class="co">## An ordinated matrix with node and tip labels</span></a>
<a class="sourceLine" id="cb398-3" data-line-number="3"><span class="kw">data</span>(BeckLee_mat99)</a>
<a class="sourceLine" id="cb398-4" data-line-number="4"><span class="co">## The corresponding tree with tip and node labels</span></a>
<a class="sourceLine" id="cb398-5" data-line-number="5"><span class="kw">data</span>(BeckLee_tree)</a>
<a class="sourceLine" id="cb398-6" data-line-number="6"><span class="co">## A list of tips ages for the fossil data</span></a>
<a class="sourceLine" id="cb398-7" data-line-number="7"><span class="kw">data</span>(BeckLee_ages)</a>
<a class="sourceLine" id="cb398-8" data-line-number="8"></a>
<a class="sourceLine" id="cb398-9" data-line-number="9"><span class="co">## Time slicing through the tree using the equal split algorithm</span></a>
<a class="sourceLine" id="cb398-10" data-line-number="10">time_slices &lt;-<span class="st"> </span><span class="kw">chrono.subsets</span>(<span class="dt">data   =</span> BeckLee_mat99,</a>
<a class="sourceLine" id="cb398-11" data-line-number="11">                              <span class="dt">tree   =</span> BeckLee_tree,</a>
<a class="sourceLine" id="cb398-12" data-line-number="12">                              <span class="dt">FADLAD =</span> BeckLee_ages,</a>
<a class="sourceLine" id="cb398-13" data-line-number="13">                              <span class="dt">method =</span> <span class="st">&quot;continuous&quot;</span>,</a>
<a class="sourceLine" id="cb398-14" data-line-number="14">                              <span class="dt">model  =</span> <span class="st">&quot;acctran&quot;</span>,</a>
<a class="sourceLine" id="cb398-15" data-line-number="15">                              <span class="dt">time   =</span> <span class="dv">15</span>)</a>
<a class="sourceLine" id="cb398-16" data-line-number="16"></a>
<a class="sourceLine" id="cb398-17" data-line-number="17"><span class="co">## We can visualise the resulting trait space with the phylogeny</span></a>
<a class="sourceLine" id="cb398-18" data-line-number="18"><span class="co">## (using the specific argument as follows)</span></a>
<a class="sourceLine" id="cb398-19" data-line-number="19"><span class="kw">plot</span>(time_slices, <span class="dt">type =</span> <span class="st">&quot;preview&quot;</span>,</a>
<a class="sourceLine" id="cb398-20" data-line-number="20">     <span class="dt">specific.args =</span> <span class="kw">list</span>(<span class="dt">tree =</span> <span class="ot">TRUE</span>))</a></code></pre></div>
<p><img src="dispRity_manual_files/figure-html/unnamed-chunk-120-1.png" width="672" /></p>
<div class="sourceCode" id="cb399"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb399-1" data-line-number="1"><span class="co">## Note that some nodes are never selected thus explaining the branches not reaching them.</span></a></code></pre></div>
<p>And we can then measure disparity as the sum of the edge length at each time slice on the bootstrapped data:</p>
<div class="sourceCode" id="cb400"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb400-1" data-line-number="1"><span class="co">## Measuring the sum of the edge length per slice</span></a>
<a class="sourceLine" id="cb400-2" data-line-number="2">sum_edge_length &lt;-<span class="st"> </span><span class="kw">dispRity</span>(<span class="kw">boot.matrix</span>(time_slices), <span class="dt">metric =</span> <span class="kw">c</span>(sum, edge.length.tree))</a>
<a class="sourceLine" id="cb400-3" data-line-number="3"><span class="co">## Summarising and plotting</span></a>
<a class="sourceLine" id="cb400-4" data-line-number="4"><span class="kw">summary</span>(sum_edge_length)</a></code></pre></div>
<pre><code>##    subsets  n  obs bs.median 2.5%  25%  75% 97.5%
## 1   133.51  3   51        51   36   40   61    69
## 2   123.97  6  163       166  141  158  172   188
## 3   114.44  9  332       331  287  317  354   383
## 4    104.9 12  558       565  489  540  587   620
## 5    95.37 15  762       763  723  745  782   815
## 6    85.83 20 1303      1305 1218 1271 1342  1415
## 7    76.29 19 1565      1559 1408 1491 1620  1802
## 8    66.76 23 2055      2040 1865 1965 2095  2262
## 9    57.22 20 2029      2031 1842 1949 2091  2190
## 10   47.68 16 1908      1892 1727 1840 1945  2057
## 11   38.15 16 2017      2016 1910 1975 2081  2152
## 12   28.61 10 1391      1391 1391 1391 1391  1391
## 13   19.07 10 1391      1391 1391 1391 1391  1391
## 14    9.54 10 1391      1391 1391 1391 1391  1391
## 15       0 10 1391      1391 1391 1391 1391  1391</code></pre>
<div class="sourceCode" id="cb402"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb402-1" data-line-number="1"><span class="kw">plot</span>(sum_edge_length)</a></code></pre></div>
<p><img src="dispRity_manual_files/figure-html/unnamed-chunk-121-1.png" width="672" /></p>
<p>Of course this can be done with multiple trees and be combined with an approach using multiple matrices (see <a href="details-of-specific-functions.html#multi.input">here</a>)!</p>

</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-aguilera2004">
<p>Aguilera, Antonio, and Ricardo Pérez-Aguila. 2004. “General N-Dimensional Rotations.” Václav Skala-UNION Agency. <a href="http://wscg.zcu.cz/wscg2004/Papers_2004_Short/N29.pdf" class="uri">http://wscg.zcu.cz/wscg2004/Papers_2004_Short/N29.pdf</a>.</p>
</div>
<div id="ref-beckancient2014">
<p>Beck, Robin M, and Michael S Lee. 2014. “Ancient Dates or Accelerated Rates? Morphological Clocks and the Antiquity of Placental Mammals.” <em>Proceedings of the Royal Society B: Biological Sciences</em> 281 (20141278): 1–10. <a href="https://doi.org/10.1098/rspb.2014.1278" class="uri">https://doi.org/10.1098/rspb.2014.1278</a>.</p>
</div>
<div id="ref-Cooper2016">
<p>Cooper, Natalie, Gavin H. Thomas, Chris Venditti, Andrew Meade, and Rob P. Freckleton. 2016. “A Cautionary Note on the Use of Ornstein Uhlenbeck Models in Macroevolutionary Studies.” <em>Biological Journal of the Linnean Society</em> 118 (1): 64–77. <a href="https://doi.org/10.1111/bij.12701" class="uri">https://doi.org/10.1111/bij.12701</a>.</p>
</div>
<div id="ref-diaz2016global">
<p>Díaz, Sandra, Jens Kattge, Johannes HC Cornelissen, Ian J Wright, Sandra Lavorel, Stéphane Dray, Björn Reu, et al. 2016. “The Global Spectrum of Plant Form and Function.” <em>Nature</em> 529 (7585). Nature Publishing Group: 167. <a href="http://dx.doi.org/10.1038/nature16489" class="uri">http://dx.doi.org/10.1038/nature16489</a>.</p>
</div>
<div id="ref-endler2005">
<p>Endler, John A, David A Westcott, Joah R Madden, and Tim Robson. 2005. “Animal Visual Systems and the Evolution of Color Patterns: Sensory Processing Illuminates Signal Evolution.” <em>Evolution</em> 59 (8). Wiley Online Library: 1795–1818.</p>
</div>
<div id="ref-time-slice">
<p>Guillerme, T., and N. Cooper. 2018. “Time for a Rethink: Time Sub-Sampling Methods in Disparity-Through-Time Analyses.” <em>Palaeontology</em> 61 (4): 481–93. <a href="https://doi.org/10.1111/pala.12364" class="uri">https://doi.org/10.1111/pala.12364</a>.</p>
</div>
<div id="ref-Guillerme2020">
<p>Guillerme, Thomas, Natalie Cooper, Stephen L. Brusatte, Katie E. Davis, Andrew L. Jackson, Sylvain Gerber, Anjali Goswami, et al. 2020. “Disparities in the Analysis of Morphological Disparity.” <em>Biology Letters</em> 16 (7): 20200199. <a href="https://doi.org/10.1098/rsbl.2020.0199" class="uri">https://doi.org/10.1098/rsbl.2020.0199</a>.</p>
</div>
<div id="ref-moms">
<p>Guillerme, Thomas, Mark N Puttick, Ariel E Marcy, and Vera Weisbecker. 2020. “Shifting Spaces: Which Disparity or Dissimilarity Measurement Best Summarize Occupancy in Multidimensional Spaces?” <em>Ecology and Evolution</em>. Wiley Online Library.</p>
</div>
<div id="ref-hunt2006fitting">
<p>Hunt, Gene. 2006. “Fitting and Comparing Models of Phyletic Evolution: Random Walks and Beyond.” <em>Paleobiology</em> 32 (4). Cambridge University Press: 578–601. <a href="https://doi.org/10.1666/05070.1" class="uri">https://doi.org/10.1666/05070.1</a>.</p>
</div>
<div id="ref-hunt2012measuring">
<p>Hunt, Gene. 2012. “Measuring Rates of Phenotypic Evolution and the Inseparability of Tempo and Mode.” <em>Paleobiology</em> 38 (3). GeoScienceWorld: 351–73. <a href="https://doi.org/10.1666/11047.1" class="uri">https://doi.org/10.1666/11047.1</a>.</p>
</div>
<div id="ref-hunt2015simple">
<p>Hunt, Gene, Melanie J Hopkins, and Scott Lidgard. 2015. “Simple Versus Complex Models of Trait Evolution and Stasis as a Response to Environmental Change.” <em>Proceedings of the National Academy of Sciences</em>. National Acad Sciences, 201403662. <a href="https://doi.org/10.1073/pnas.1403662111" class="uri">https://doi.org/10.1073/pnas.1403662111</a>.</p>
</div>
<div id="ref-murrell2018global">
<p>Murrell, David J. 2018. “A Global Envelope Test to Detect Non-Random Bursts of Trait Evolution.” <em>Methods in Ecology and Evolution</em> 9 (7). Wiley Online Library: 1739–48. <a href="https://doi.org/10.1111/2041-210X.13006" class="uri">https://doi.org/10.1111/2041-210X.13006</a>.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="getting-started-with-disprity.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="making-stuff-up.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/TGuillerme/dispRity/inst/gitbook/edit/master/03_specific-tutorials.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>

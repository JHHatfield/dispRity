expect_is(test1, "dispRity")
expect_is(test2, "dispRity")
expect_equal(names(test1), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
expect_equal(names(test2), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
## Different results
expect_equal(c(summary(test1)$obs), c(0.390, 0.020, 0.125))
expect_equal(c(summary(test2)$obs), c(119.1, 107.6,  73.3))
## Test with VCV, loc toggles
sum.var.dist <- function(matrix, loc = rep(0, ncol(matrix))) {
## Get the sum of the diagonal of the matrix
sum_diag <- sum(diag(matrix))
## Get the distance between 0 and the loc
dist_loc <- dist(matrix(c(rep(0, ncol(matrix)), loc), nrow = 2, byrow = TRUE))[1]
## Return the sum of the diagonal minus the distance
return(sum_diag - dist_loc)
}
sum.var.group <- function(matrix, matrix2, loc = rep(0, ncol(matrix)), loc2 = rep(0, ncol(matrix2)), ...) {
return(sum.var.dist(matrix, loc) + sum.var.dist(matrix2, loc2))
}
## Test works OK with base
set.seed(42)
data <- MCMCglmm.subsets(data       = charadriiformes$data,
posteriors = charadriiformes$posteriors,
tree       = charadriiformes$tree,
group      = MCMCglmm.levels(
charadriiformes$posteriors)[1:3],
rename.groups = c("gulls", "plovers", "sandpipers"),
n = 3)
## Adding some loc for groups 2 and 3
data$covar[[2]][[1]]$loc <- data$covar[[2]][[2]]$loc <- data$covar[[2]][[3]]$loc <- rep(1, 3)
data$covar[[3]][[1]]$loc <- data$covar[[3]][[2]]$loc <- data$covar[[3]][[3]]$loc <- rep(10, 3)
## VCV && !loc
test2 <- dispRity(data, metric = as.covar(sum.var.dist, VCV = TRUE, loc = FALSE))
expect_is(test2, "dispRity")
expect_equal(names(test2), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
## Different results
expect_equal(c(summary(test2)$obs), c(0.297, 0.012, 0.052))
## !VCV && loc
test2 <- dispRity(data, metric = as.covar(sum.var.dist, VCV = FALSE, loc = TRUE))
expect_is(test2, "dispRity")
expect_equal(names(test2), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
## Different results
expect_equal(c(summary(test2)$obs), c(0, 1, 10))
## VCV && loc
test2 <- dispRity(data, metric = as.covar(sum.var.dist, VCV = TRUE, loc = TRUE))
expect_is(test2, "dispRity")
expect_equal(names(test2), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
## Different results
expect_equal(c(summary(test2)$obs), c(0.3, -1.7, -17.3))
## Works with between groups
## VCV && !loc
test3 <- dispRity(data, metric = as.covar(sum.var.group, VCV = TRUE, loc = FALSE), between.groups = TRUE)
expect_is(test3, "dispRity")
expect_equal(names(test3), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
## Different results
expect_equal(c(summary(test3)$obs), c(0.309, 0.387, 0.069))
## !VCV && loc
test3 <- dispRity(data, metric = as.covar(sum.var.group, VCV = FALSE, loc = TRUE), between.groups = TRUE)
expect_is(test3, "dispRity")
expect_equal(names(test3), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
## Different results
expect_equal(c(summary(test3)$obs), c(1, 10, 11))
## VCV && loc
test3 <- dispRity(data, metric = as.covar(sum.var.group, VCV = TRUE, loc = TRUE), between.groups = TRUE)
expect_is(test3, "dispRity")
expect_equal(names(test3), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
## Different results
expect_equal(c(summary(test3)$obs), c(-1.4, -16.9, -19))
})
data(charadriiformes)
covar_data <- MCMCglmm.subsets(data       = charadriiformes$data,
posteriors = charadriiformes$posteriors)
## Get one matrix and one covar matrix
set.seed(1)
one_matrix <- get.matrix(covar_data, subsets = 1)
one_covar  <- get.covar(covar_data, subsets = 1, n = 1)[[1]][[1]]
## Measure the centroids on the covar matrix
expect_equal_round(as.covar(centroids)(one_covar), c(0.3253075, 0.1678841, 0.1600487), digits = 6)
## Is the same as:
expect_equal_round(as.covar(centroids)(one_covar), centroids(one_covar$VCV), digits = 6)
as.covar(centroids)(one_covar)
expect_equal_round(as.covar(centroids)(one_covar), c(0.06730570, 0.05852601, 0.01730266), digits = 6)
## Is the same as:
expect_equal_round(as.covar(centroids)(one_covar), centroids(one_covar$VCV), digits = 6)
expect_equal(c(summary(dispRity(covar_data, metric = c(sum, centroids)))$obs), c(71.2, 49.0, 52.1, 182.9, 182.9))
expect_equal(c(summary(dispRity(covar_data, metric = c(sum, as.covar(centroids))))$obs), c(0.390, 0.020, 0.125, 0.217, 0.029))
c(summary(dispRity(covar_data, metric = c(sum, as.covar(centroids))))$obs)
expect_equal(c(summary(dispRity(covar_data, metric = c(sum, as.covar(centroids))))$obs), c(0.375, 0.017, 0.112, 0.229, 0.029))
expect_equal(c(summary(dispRity(covar_data,
metric = c(sum, as.covar(centroids)),
centre = 100))$obs), c(119.1, 107.6, 73.3, 100.0, 100.0))
data(charadriiformes)
## Test works OK with base
data0 <- custom.subsets(data  = charadriiformes$data[, -c(18, 19)],
group = charadriiformes$data[, "clade"])
test0 <- dispRity(data0, metric = c(sum, variances))
expect_is(test0, "dispRity")
expect_equal(names(test0), c("matrix", "tree", "call", "subsets", "disparity"))
expect_equal(c(summary(test0)$obs), c(0.272, 0.351, 0.360))
## Same but selecting only the three first random terms
data <- MCMCglmm.subsets(data       = charadriiformes$data,
posteriors = charadriiformes$posteriors,
tree       = charadriiformes$tree,
group      = MCMCglmm.levels(
charadriiformes$posteriors)[1:3],
rename.groups = c("gulls", "plovers", "sandpipers"))
for(i in 1:3) {
expect_equal(c(data0$subsets[[i]]$elements), c(data$subsets[[i]]$elements))
}
test1 <- dispRity(data, metric = c(sum, variances), dimensions = c(1:17))
expect_is(test1, "dispRity")
expect_equal(names(test1), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
expect_equal(c(summary(test1)$obs), c(0.272, 0.351, 0.360))
testA <- dispRity(data, metric = variances, dimensions = c(1:17))
expect_is(testA, "dispRity")
expect_equal(names(testA), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
testB <- dispRity(testA, metric = sum)
expect_is(testB, "dispRity")
expect_equal(names(testB), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
expect_equal(c(summary(testB)$obs), c(0.272, 0.351, 0.360))
## Test works OK with as.covar
test2 <- dispRity(data, metric = c(sum, as.covar(variances)))
expect_is(test2, "dispRity")
expect_equal(names(test2), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
## Different results
expect_equal(c(summary(test2)$obs), c(0.029, 0.000, 0.003))
## Test works in 2 times (1st covar)
testA <- dispRity(data, metric = as.covar(variances), dimensions = c(1:17))
expect_is(testA, "dispRity")
expect_equal(names(testA), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
expect_equal(c(summary(testA)$`97.5%`), c(0.067, 0.002, 0.015))
## Works with level 1
testB <- dispRity(testA, metric = sum)
expect_is(testB, "dispRity")
expect_equal(names(testB), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
expect_equal(c(summary(testB)$obs), c(0.029, 0.000, 0.003))
## Error if level 1 is also covar
error <- capture_error(dispRity(testA, metric = as.covar(sum)))
expect_equal(error[[1]], "Impossible to apply a metric as.covar() on a dispRity object that already contains disparity results.")
## But works with just a level 1
test <- dispRity(data, metric = as.covar(sum))
expect_equal(summary(test)$obs.median, c(0.219, 0.014, 0.100))
## Test works OK with as.covar
test2 <- dispRity(data, metric = c(sum, as.covar(variances)))
expect_is(test2, "dispRity")
expect_equal(names(test2), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
## Different results
expect_equal(c(summary(test2)$obs), c(0.029, 0.000, 0.003))
c(summary(test2)$obs)
expect_equal(c(summary(test2)$obs), c(0.026, 0.000, 0.002))
testA <- dispRity(data, metric = as.covar(variances), dimensions = c(1:17))
expect_is(testA, "dispRity")
expect_equal(names(testA), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
expect_equal(c(summary(testA)$`97.5%`), c(0.067, 0.002, 0.015))
expect_equal(c(summary(testA)$`97.5%`), c(0.068, 0.002, 0.016))
testB <- dispRity(testA, metric = sum)
expect_is(testB, "dispRity")
expect_equal(names(testB), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
expect_equal(c(summary(testB)$obs), c(0.029, 0.000, 0.003))
error <- capture_error(dispRity(testA, metric = as.covar(sum)))
expect_equal(error[[1]], "Impossible to apply a metric as.covar() on a dispRity object that already contains disparity results.")
## But works with just a level 1
test <- dispRity(data, metric = as.covar(sum))
expect_equal(summary(test)$obs.median, c(0.219, 0.014, 0.100))
expect_equal(summary(test)$obs.median, c(0.213, 0.016, 0.088))
test1 <- dispRity(data, metric = c(sum, as.covar(centroids)))
test2 <- dispRity(data, metric = c(sum, as.covar(centroids)), centre = 100)
expect_is(test1, "dispRity")
expect_is(test2, "dispRity")
expect_equal(names(test1), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
expect_equal(names(test2), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
expect_equal(c(summary(test1)$obs), c(0.390, 0.020, 0.125))
expect_equal(c(summary(test1)$obs), c(0.375, 0.017, .0112))
expect_equal(c(summary(test2)$obs), c(119.1, 107.6,  73.3))
expect_equal(c(summary(test1)$obs), c(0.375, 0.017, .0112))
expect_equal(c(summary(test2)$obs), c(119.1, 107.6,  73.3))
expect_equal(c(summary(test1)$obs), c(0.375, 0.017, 0.112))
expect_equal(c(summary(test2)$obs), c(119.1, 107.6,  73.3))
sum.var.dist <- function(matrix, loc = rep(0, ncol(matrix))) {
## Get the sum of the diagonal of the matrix
sum_diag <- sum(diag(matrix))
## Get the distance between 0 and the loc
dist_loc <- dist(matrix(c(rep(0, ncol(matrix)), loc), nrow = 2, byrow = TRUE))[1]
## Return the sum of the diagonal minus the distance
return(sum_diag - dist_loc)
}
sum.var.group <- function(matrix, matrix2, loc = rep(0, ncol(matrix)), loc2 = rep(0, ncol(matrix2)), ...) {
return(sum.var.dist(matrix, loc) + sum.var.dist(matrix2, loc2))
}
set.seed(42)
data <- MCMCglmm.subsets(data       = charadriiformes$data,
posteriors = charadriiformes$posteriors,
tree       = charadriiformes$tree,
group      = MCMCglmm.levels(
charadriiformes$posteriors)[1:3],
rename.groups = c("gulls", "plovers", "sandpipers"),
n = 3)
## Adding some loc for groups 2 and 3
data$covar[[2]][[1]]$loc <- data$covar[[2]][[2]]$loc <- data$covar[[2]][[3]]$loc <- rep(1, 3)
data$covar[[3]][[1]]$loc <- data$covar[[3]][[2]]$loc <- data$covar[[3]][[3]]$loc <- rep(10, 3)
## VCV && !loc
test2 <- dispRity(data, metric = as.covar(sum.var.dist, VCV = TRUE, loc = FALSE))
expect_is(test2, "dispRity")
expect_equal(names(test2), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
expect_equal(c(summary(test2)$obs), c(0.297, 0.012, 0.052))
expect_equal(c(summary(test2)$obs), c(0.384, 0.046, 0.147))
test2 <- dispRity(data, metric = as.covar(sum.var.dist, VCV = FALSE, loc = TRUE))
expect_is(test2, "dispRity")
expect_equal(names(test2), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
expect_equal(c(summary(test2)$obs), c(0, 1, 10))
test2 <- dispRity(data, metric = as.covar(sum.var.dist, VCV = TRUE, loc = TRUE))
expect_is(test2, "dispRity")
expect_equal(names(test2), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
expect_equal(c(summary(test2)$obs), c(0.3, -1.7, -17.3))
expect_equal(c(summary(test2)$obs), c(0.4, -1.7, -17.2))
test3 <- dispRity(data, metric = as.covar(sum.var.group, VCV = TRUE, loc = FALSE), between.groups = TRUE)
expect_is(test3, "dispRity")
expect_equal(names(test3), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
expect_equal(c(summary(test3)$obs), c(0.309, 0.387, 0.069))
test3 <- dispRity(data, metric = as.covar(sum.var.group, VCV = FALSE, loc = TRUE), between.groups = TRUE)
expect_is(test3, "dispRity")
expect_equal(names(test3), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
expect_equal(c(summary(test3)$obs), c(0.418, 0.539, 0.191))
test3 <- dispRity(data, metric = as.covar(sum.var.group, VCV = TRUE, loc = FALSE), between.groups = TRUE)
expect_is(test3, "dispRity")
expect_equal(names(test3), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
## Different results
expect_equal(c(summary(test3)$obs), c(0.418, 0.539, 0.191))
test3 <- dispRity(data, metric = as.covar(sum.var.group, VCV = FALSE, loc = TRUE), between.groups = TRUE)
expect_is(test3, "dispRity")
expect_equal(names(test3), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
## Different results
expect_equal(c(summary(test3)$obs), c(1, 10, 11))
test3 <- dispRity(data, metric = as.covar(sum.var.group, VCV = TRUE, loc = TRUE), between.groups = TRUE)
expect_is(test3, "dispRity")
expect_equal(names(test3), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
## Different results
expect_equal(c(summary(test3)$obs), c(-1.4, -16.9, -19))
expect_equal(c(summary(test3)$obs), c(-1.3, -16.8, -18.9))
test_that("example works", {
## Creating a dispRity
data(charadriiformes)
## Creating a dispRity object from the charadriiformes model
covar_data <- MCMCglmm.subsets(data       = charadriiformes$data,
posteriors = charadriiformes$posteriors)
## Get one matrix and one covar matrix
set.seed(1)
one_matrix <- get.matrix(covar_data, subsets = 1)
one_covar  <- get.covar(covar_data, subsets = 1, n = 1)[[1]][[1]]
## Measure the centroids on the covar matrix
expect_equal_round(as.covar(centroids)(one_covar), c(0.06730570, 0.05852601, 0.01730266), digits = 6)
## Is the same as:
expect_equal_round(as.covar(centroids)(one_covar), centroids(one_covar$VCV), digits = 6)
## Apply the measurement on a dispRity object:
## On the traitspace:
expect_equal(c(summary(dispRity(covar_data, metric = c(sum, centroids)))$obs), c(71.2, 49.0, 52.1, 182.9, 182.9))
## On the covariance matrices:
expect_equal(c(summary(dispRity(covar_data, metric = c(sum, as.covar(centroids))))$obs), c(0.375, 0.017, 0.112, 0.229, 0.029))
## The same but with additional options (centre = 100)
expect_equal(c(summary(dispRity(covar_data,
metric = c(sum, as.covar(centroids)),
centre = 100))$obs), c(119.1, 107.6, 73.3, 100.0, 100.0))
})
test_that("as.covar works in dispRity", {
data(charadriiformes)
## Test works OK with base
data0 <- custom.subsets(data  = charadriiformes$data[, -c(18, 19)],
group = charadriiformes$data[, "clade"])
test0 <- dispRity(data0, metric = c(sum, variances))
expect_is(test0, "dispRity")
expect_equal(names(test0), c("matrix", "tree", "call", "subsets", "disparity"))
expect_equal(c(summary(test0)$obs), c(0.272, 0.351, 0.360))
## Same but selecting only the three first random terms
data <- MCMCglmm.subsets(data       = charadriiformes$data,
posteriors = charadriiformes$posteriors,
tree       = charadriiformes$tree,
group      = MCMCglmm.levels(
charadriiformes$posteriors)[1:3],
rename.groups = c("gulls", "plovers", "sandpipers"))
## The subsets are the same
for(i in 1:3) {
expect_equal(c(data0$subsets[[i]]$elements), c(data$subsets[[i]]$elements))
}
## Test works OK with base + covar (same as test0)
test1 <- dispRity(data, metric = c(sum, variances), dimensions = c(1:17))
expect_is(test1, "dispRity")
expect_equal(names(test1), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
expect_equal(c(summary(test1)$obs), c(0.272, 0.351, 0.360))
## Test works in 2 times
testA <- dispRity(data, metric = variances, dimensions = c(1:17))
expect_is(testA, "dispRity")
expect_equal(names(testA), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
testB <- dispRity(testA, metric = sum)
expect_is(testB, "dispRity")
expect_equal(names(testB), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
expect_equal(c(summary(testB)$obs), c(0.272, 0.351, 0.360))
## Test works OK with as.covar
test2 <- dispRity(data, metric = c(sum, as.covar(variances)))
expect_is(test2, "dispRity")
expect_equal(names(test2), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
## Different results
expect_equal(c(summary(test2)$obs), c(0.026, 0.000, 0.002))
## Test works in 2 times (1st covar)
testA <- dispRity(data, metric = as.covar(variances), dimensions = c(1:17))
expect_is(testA, "dispRity")
expect_equal(names(testA), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
expect_equal(c(summary(testA)$`97.5%`), c(0.068, 0.002, 0.016))
## Works with level 1
testB <- dispRity(testA, metric = sum)
expect_is(testB, "dispRity")
expect_equal(names(testB), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
expect_equal(c(summary(testB)$obs), c(0.026, 0.000, 0.002))
## Error if level 1 is also covar
error <- capture_error(dispRity(testA, metric = as.covar(sum)))
expect_equal(error[[1]], "Impossible to apply a metric as.covar() on a dispRity object that already contains disparity results.")
## But works with just a level 1
test <- dispRity(data, metric = as.covar(sum))
expect_equal(summary(test)$obs.median, c(0.213, 0.016, 0.088))
## Test works with extra arguments
test1 <- dispRity(data, metric = c(sum, as.covar(centroids)))
test2 <- dispRity(data, metric = c(sum, as.covar(centroids)), centre = 100)
expect_is(test1, "dispRity")
expect_is(test2, "dispRity")
expect_equal(names(test1), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
expect_equal(names(test2), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
## Different results
expect_equal(c(summary(test1)$obs), c(0.375, 0.017, 0.112))
expect_equal(c(summary(test2)$obs), c(119.1, 107.6,  73.3))
## Test with VCV, loc toggles
sum.var.dist <- function(matrix, loc = rep(0, ncol(matrix))) {
## Get the sum of the diagonal of the matrix
sum_diag <- sum(diag(matrix))
## Get the distance between 0 and the loc
dist_loc <- dist(matrix(c(rep(0, ncol(matrix)), loc), nrow = 2, byrow = TRUE))[1]
## Return the sum of the diagonal minus the distance
return(sum_diag - dist_loc)
}
sum.var.group <- function(matrix, matrix2, loc = rep(0, ncol(matrix)), loc2 = rep(0, ncol(matrix2)), ...) {
return(sum.var.dist(matrix, loc) + sum.var.dist(matrix2, loc2))
}
## Test works OK with base
set.seed(42)
data <- MCMCglmm.subsets(data       = charadriiformes$data,
posteriors = charadriiformes$posteriors,
tree       = charadriiformes$tree,
group      = MCMCglmm.levels(
charadriiformes$posteriors)[1:3],
rename.groups = c("gulls", "plovers", "sandpipers"),
n = 3)
## Adding some loc for groups 2 and 3
data$covar[[2]][[1]]$loc <- data$covar[[2]][[2]]$loc <- data$covar[[2]][[3]]$loc <- rep(1, 3)
data$covar[[3]][[1]]$loc <- data$covar[[3]][[2]]$loc <- data$covar[[3]][[3]]$loc <- rep(10, 3)
## VCV && !loc
test2 <- dispRity(data, metric = as.covar(sum.var.dist, VCV = TRUE, loc = FALSE))
expect_is(test2, "dispRity")
expect_equal(names(test2), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
## Different results
expect_equal(c(summary(test2)$obs), c(0.384, 0.046, 0.147))
## !VCV && loc
test2 <- dispRity(data, metric = as.covar(sum.var.dist, VCV = FALSE, loc = TRUE))
expect_is(test2, "dispRity")
expect_equal(names(test2), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
## Different results
expect_equal(c(summary(test2)$obs), c(0, 1, 10))
## VCV && loc
test2 <- dispRity(data, metric = as.covar(sum.var.dist, VCV = TRUE, loc = TRUE))
expect_is(test2, "dispRity")
expect_equal(names(test2), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
## Different results
expect_equal(c(summary(test2)$obs), c(0.4, -1.7, -17.2))
## Works with between groups
## VCV && !loc
test3 <- dispRity(data, metric = as.covar(sum.var.group, VCV = TRUE, loc = FALSE), between.groups = TRUE)
expect_is(test3, "dispRity")
expect_equal(names(test3), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
## Different results
expect_equal(c(summary(test3)$obs), c(0.418, 0.539, 0.191))
## !VCV && loc
test3 <- dispRity(data, metric = as.covar(sum.var.group, VCV = FALSE, loc = TRUE), between.groups = TRUE)
expect_is(test3, "dispRity")
expect_equal(names(test3), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
## Different results
expect_equal(c(summary(test3)$obs), c(1, 10, 11))
## VCV && loc
test3 <- dispRity(data, metric = as.covar(sum.var.group, VCV = TRUE, loc = TRUE), between.groups = TRUE)
expect_is(test3, "dispRity")
expect_equal(names(test3), c("matrix", "tree", "call", "subsets", "covar", "disparity"))
## Different results
expect_equal(c(summary(test3)$obs), c(-1.3, -16.8, -18.9))
})
test_that("as.covar works in standalone", {
## Creating a dispRity
data(charadriiformes)
covar_data <- MCMCglmm.subsets(data       = charadriiformes$data,
posteriors = charadriiformes$posteriors)
## Testing the handling
match_call <- list()
## level 3 covar
metric <- as.covar(var)
expect_true(check.covar(metric, covar_data)$is_covar)
test <- get.dispRity.metric.handle(c(sum, metric), match_call, data = covar_data, tree = NULL)$levels
expect_true(!is.null(test$level3.fun))
expect_true(is.null(test$level2.fun))
expect_true(!is.null(test$level1.fun))
expect_true(eval.covar(test$level3.fun, null.return = FALSE))
expect_false(eval.covar(test$level1.fun, null.return = FALSE))
## level 2 covar
metric <- as.covar(variances)
expect_true(check.covar(metric, covar_data)$is_covar)
test <- get.dispRity.metric.handle(metric, match_call, data = covar_data, tree = NULL)$levels
expect_true(is.null(test$level3.fun))
expect_true(!is.null(test$level2.fun))
expect_true(is.null(test$level1.fun))
expect_true(eval.covar(test$level2.fun, null.return = FALSE))
## level 1 covar (with no formals)
metric <- as.covar(sum)
expect_true(check.covar(metric, covar_data)$is_covar)
test <- get.dispRity.metric.handle(metric, match_call, data = covar_data, tree = NULL)$levels
expect_true(is.null(test$level3.fun))
expect_true(is.null(test$level2.fun))
expect_true(!is.null(test$level1.fun))
expect_true(eval.covar(test$level1.fun, null.return = FALSE))
## level 1 covar (with formals)
metric <- as.covar(ellipse.volume)
expect_true(check.covar(metric, covar_data)$is_covar)
test <- get.dispRity.metric.handle(metric, match_call, data = covar_data, tree = NULL)$levels
expect_true(is.null(test$level3.fun))
expect_true(is.null(test$level2.fun))
expect_true(!is.null(test$level1.fun))
expect_true(eval.covar(test$level1.fun, null.return = FALSE))
## pairs of metrics:
# Possible combinations:
# covar(lvl1)
# lvl1 + covar(lvl2)
# lvl1 + lvl2 + covar(lvl3)
metric <- c(sum, as.covar(variances))
test <- get.dispRity.metric.handle(metric, match_call, data = covar_data, tree = NULL)$levels
expect_true(is.null(test$level3.fun))
expect_true(!is.null(test$level2.fun))
expect_true(!is.null(test$level1.fun))
expect_true(eval.covar(test$level2.fun, null.return = FALSE))
expect_false(eval.covar(test$level1.fun, null.return = FALSE))
metric <- c(sd, variances, as.covar(var))
test <- get.dispRity.metric.handle(metric, match_call, data = covar_data, tree = NULL)$levels
expect_true(!is.null(test$level3.fun))
expect_true(!is.null(test$level2.fun))
expect_true(!is.null(test$level1.fun))
expect_true(eval.covar(test$level3.fun, null.return = FALSE))
expect_false(eval.covar(test$level2.fun, null.return = FALSE))
expect_false(eval.covar(test$level1.fun, null.return = FALSE))
metric <- c(as.covar(sum), variances)
error <- capture_error(get.dispRity.metric.handle(metric, match_call, data = covar_data, tree = NULL))
expect_equal(error[[1]], "Only the highest dimension-level metric can be set as as.covar().")
metric <- c(as.covar(sum), as.covar(variances))
error <- capture_error(get.dispRity.metric.handle(metric, match_call, data = covar_data, tree = NULL))
expect_equal(error[[1]], "Only one metric can be set as as.covar().")
})
refresh.dispRity()
## Two dummy matrices
matrix_1 <- matrix(rnorm(16), 4, 4)
matrix_2 <- matrix(rnorm(16), 4, 4)
## Projecting the major axis of matrix_2 onto the one from matrix_1
expect_equal_round(projections.between(matrix_1, matrix_2), -0.312014, 6)
## Projecting both second major 0.75 axes
## and getting the rejections (see projections() for option details)
expect_equal_round(projections.between(matrix_1, matrix_2,
measure = "distance",
axis = 4, level = 0.75),
0.7356813, 6)
set.seed(1)
## Two dummy matrices
matrix_1 <- matrix(rnorm(16), 4, 4)
matrix_2 <- matrix(rnorm(16), 4, 4)
## Projecting the major axis of matrix_2 onto the one from matrix_1
expect_equal_round(projections.between(matrix_1, matrix_2), -0.312014, 6)
## Projecting both second major 0.75 axes
## and getting the rejections (see projections() for option details)
expect_equal_round(projections.between(matrix_1, matrix_2,
measure = "distance",
axis = 4, level = 0.75),
0.7356813, 6)
data(charadriiformes)
data <- MCMCglmm.subsets(data       = charadriiformes$data,
posteriors = charadriiformes$posteriors,
group = MCMCglmm.levels(charadriiformes$posteriors)[1:4],
rename.groups = c(levels(charadriiformes$data$clade), "phylogeny"))
## Testing the metric in the pipeline without covar option
no_covar <- dispRity(data, metric = projections.between, between.groups = TRUE)
## Test the values out
disparity <- get.disparity(no_covar)
expect_equal(names(disparity), c("gulls:plovers", "gulls:sandpipers", "gulls:phylogeny", "plovers:sandpipers", "plovers:phylogeny", "sandpipers:phylogeny"))
expect_equal_round(unname(unlist(disparity)), c(-0.1915237,-1.5257785,-1.5257785,0.2534359,0.2534359,1.0000000), 6)
is_covar <- dispRity(data, metric = as.covar(projections.between), between.groups = TRUE)
## Test the values out
disparity <- get.disparity(is_covar, concatenate = FALSE)
expect_equal(names(disparity), c("gulls:plovers", "gulls:sandpipers", "gulls:phylogeny", "plovers:sandpipers", "plovers:phylogeny", "sandpipers:phylogeny"))
expect_equal(unique(unlist(lapply(disparity, dim))), c(1, 1000))
disparity <- get.disparity(is_covar)
expect_equal_round(unname(unlist(disparity)), c(2.8863957,1.5628570,1.2798770,0.3934976,0.2566334,0.7740176), 5)
unname(unlist(disparity))
expect_equal_round(unname(unlist(disparity)), c(2.8175937, 1.5718191, 1.2262642, 0.3840770, 0.2389399, 0.7011024), 5)
no_covar <- dispRity(data, metric = projections.between, between.groups = TRUE, measure = "degree", level = 0.9)
disparity <- get.disparity(no_covar)
expect_equal(names(disparity), c("gulls:plovers", "gulls:sandpipers", "gulls:phylogeny", "plovers:sandpipers", "plovers:phylogeny", "sandpipers:phylogeny"))
expect_equal_round(unname(unlist(disparity)), c(96.69595,148.31804,148.31804,76.57482,76.57482,0), 5)
is_covar <- dispRity(data, metric = as.covar(projections.between), between.groups = TRUE, measure = "degree", level = 0.9)
disparity <- get.disparity(is_covar, concatenate = FALSE)
expect_equal(names(disparity), c("gulls:plovers", "gulls:sandpipers", "gulls:phylogeny", "plovers:sandpipers", "plovers:phylogeny", "sandpipers:phylogeny"))
expect_equal(unique(unlist(lapply(disparity, dim))), c(1, 1000))
disparity <- get.disparity(is_covar)
unname(unlist(disparity))
refresh.dispRity()

set.seed(123)
data(iris)
head(iris, 3)
C <- CPU.hours()
C <- CPU.hours
C("44:21:38")
C("39:14:49")
C("44:23:26")
C("39:38:43")
C("41:20:53")
C("37:40:10")
C("7:45:06")
C("37:45:06")
C("37:41:36")
C("39:07:11")
C("37:42:43")
C("39:49:39")
C("39:49:23")
C("40:03:47")
C("37:41:45")
C("48:43:30")
C("48:29:46")
C("49:52:22")
C("60:33:21")
C("41:35:12")
C("40:51:25")
C("41:26:46")
C("44:08:52")
C("43:32:34")
C("37:49:09")
C("50:45:05")
C("49:12:05")
setwd("/home/tguillerme/Projects/elaboration_exploration_bird_beaks/Analysis")
library(dispRity)
## Load the data
load(file = "../Data/Processed/shapespace_allbirds_lvl_superorder_order.rda")
## Select the data
shapespace <- shapespace_allbirds_lvl_superorder_order[[1]]$space
tree <- shapespace_allbirds_lvl_superorder_order[[1]]$consensus_tree
## Clean garbage
rm(shapespace_allbirds_lvl_superorder_order)
## Load the covar
load(file = "../Data/Processed/shapespace_allbirds_lvl_superorder_order.MCMCglmm")
shapespace_allbirds_lvl_superorder_order <- shapespace_allbirds_lvl_superorder_order[[1]]
## Get the levels
phylo_lvl <- which(MCMCglmm.levels(shapespace_allbirds_lvl_superorder_order) == "animal")
super_lvl <- grep("level1_", MCMCglmm.levels(shapespace_allbirds_lvl_superorder_order))
order_lvl <- grep("level2_", MCMCglmm.levels(shapespace_allbirds_lvl_superorder_order))
## Creating the subsets
superorder_shapespace <- MCMCglmm.subsets(n = 1000, # Just run it on 1k matrices for now
data          = shapespace,
posteriors    = shapespace_allbirds_lvl_superorder_order,
group         = MCMCglmm.levels(shapespace_allbirds_lvl_superorder_order)[c(super_lvl, phylo_lvl)],
rename.groups = c(levels(shapespace$level1)[-1], "phylogeny")) #[-1] is because the first level is ""
order_shapespace <- MCMCglmm.subsets(n = 1000, # Just run it on 1k matrices for now
data          = shapespace,
posteriors    = shapespace_allbirds_lvl_superorder_order,
group         = MCMCglmm.levels(shapespace_allbirds_lvl_superorder_order)[c(order_lvl, phylo_lvl)],
rename.groups = c(levels(shapespace$level2)[-1], "phylogeny")) #[-1] is because the first level is ""
## Clean garbage
rm(shapespace_allbirds_lvl_superorder_order)
covar.plot(superorder_shapespace,
col = c(rainbow(n.subsets(superorder_shapespace)-1), "grey"),
main = "Average ellipses by super order",
ellipses = mean,
legend = FALSE,
points = FALSE,
cex = 0.5)
data <- superorder_shapespace
col = c(rainbow(n.subsets(superorder_shapespace)-1), "grey")
ellipses = mean
legend = FALSE
points = FALSE
major.axes = FALSE
level = 0.95
dimensions = c(1,2)
centres = colMeans
add = FALSE
fun.VCV = TRUE
match_call <- match.call()
dots <- list(
)
check.class(data, "dispRity")
if(is.null(data$covar)) {
stop.call(match_call$data, msg = "does not contain a $covar element.\nSee MCMCglmm.subsets for adding covar element to dispRity objects.")
}
refresh.dispRity(test = FALSE)
if(is.null(dots$legend)) {
plot_legend <- FALSE
dots$legend <- NULL
} else {
if(is.logical(dots$legend)) {
plot_legend <-dots$legend
dots$legend <- NULL
}
}
plot_args <- c(list(x = NULL), dots)
## Removing specific args from dots
remove <- c(grep(c("legend"), names(plot_args)), grep(c("lines"), names(plot_args)), grep(c("points"), names(plot_args)))
plot_args[remove] <- NULL
if(missing(n)) {
n <- length(data$covar[[1]])
} else {
check.class(n, c("numeric", "integer"))
}
covars <- sample.n(data$covar, n)
n <- length(data$covar[[1]])
covars <- sample.n(data$covar, n)
check.class(dimensions, c("integer", "numeric"))
check.length(dimensions, 2, msg = " argument must contain only 2 dimensions (for now).")
centre_class <- check.class(centres, c("function", "numeric", "integer", "list", "character"), msg = " must be either a function (e.g. colMeans) a set or a list of sets of coordinates (e.g. list(c(1,2), c(0,0))) or \"intercept\" for using the posteriors intercepts.")
centre_class <- ifelse(centre_class == "standardGeneric", "function", centre_class)
centre_class <- ifelse(centre_class == "integer", "numeric", centre_class)
if(centre_class != "character") {
## Get the centres
centres <- switch(centre_class,
"function" = lapply(unlist(data$subsets, recursive = FALSE) ,function(group, data, fun) fun(data[c(group), ]), data = data$matrix[[1]], fun = centres),
"numeric"  = replicate(length(data$subsets), adjust.centre(centres, data$call$dimensions), simplify = FALSE),
"list"     = lapply(centres, adjust.centre, dim = data$call$dimension))
names(centres) <- names(data$subsets)
## recentre covar matrices
covars <- mapply(recentre, covars, centres, MoreArgs = list(dimensions = dimensions), SIMPLIFY = FALSE)
} else {
## Handled by ellipses and axes
if(centre)
centres <- "intercept"
}
major_axes_class <- check.class(major.axes, c("logical", "function", "standardGeneric"), msg = " must be either logical or a function for summarising the major axes.")
do_major_axes <- !(major_axes_class == "logical" && !major.axes)
ellipses_class <- check.class(ellipses, c("logical", "function", "standardGeneric"), msg = " must be either logical or a function for summarising the ellipses.")
do_ellipses <- !(ellipses_class == "logical" && !ellipses)
do_major_axes
do_ellipses
all_ellipses <- lapply(covars, level.ellipses, dimensions, npoints = 50, centres)
covars
length(covars)
names(covars)
length(covars[[1]])
test <- covars[[1]][1:3]
test
lapply(test, `[[`, "VCV")
VCVs <- lapply(test, `[[`, "VCV")
locs <- lapply(test, `[[`, "loc")
Y <- do.call(cbind, VCVs)
Y
Y <- array(Y, dim = c(dim(VCVs[[1]]), length(VCVs)))
Y
apply(Y, c(1,2), fun)
fun = mean
apply(Y, c(1,2), fun)
covars <- list(VCV = apply(array(do.call(cbind, VCVs), dim = c(dim(VCVs[[1]]), length(VCVs))), c(1,2), fun),
loc = apply(array(do.call(cbind, locs), dim = c(dim(locs[[1]]), length(locs))), c(1,2), fun))
do.call(cbind, locs)
locs
do.call(rbind, loc)
do.call(rbind, locs)
locs
covars
list(VCV = apply(array(do.call(cbind, VCVs), dim = c(dim(VCVs[[1]]), length(VCVs))), c(1,2), fun),
loc = apply(do.call(rbind, locs), 2, fun))
covars_tmp <- list(VCV = apply(array(do.call(cbind, VCVs), dim = c(dim(VCVs[[1]]), length(VCVs))), c(1,2), fun),
loc = apply(do.call(rbind, locs), 2, fun))
covars_tmp
all_ellipses <- level.ellipses(covars_tmp, dimensions, npoints = 50, centres)
covars <- sample.n(data$covar, n)
covars_cent_tend <- lapply(covars, VCV.cent.tend, fun)
## Get the VCV central tendency
VCV.cent.tend <- function(one_covar, fun) {
VCVs <- lapply(one_covar, `[[`, "VCV")
locs <- lapply(one_covar, `[[`, "loc")
return(list(VCV = apply(array(do.call(cbind, VCVs), dim = c(dim(VCVs[[1]]), length(VCVs))), c(1,2), fun),
loc = apply(do.call(rbind, locs), 2, fun)))
}
covars_cent_tend <- lapply(covars, VCV.cent.tend, fun)
covars_cent_tend
all_axes <- lapply(covars_cent_tend, get.one.axis, axis = 1, level = level, dimensions = dimensions)
all_axes
all_ellipses <- lapply(covars_cent_tend, level.ellipses, dimensions, npoints = 50, centres)
covars_cent_tend <- lapply(covars, VCV.cent.tend, fun)
all_ellipses <- lapply(covars_cent_tend, level.ellipses, dimensions, npoints = 50, centres)
all_ellipses <- level.ellipses(covars_cent_tend, dimensions, npoints = 50, centres)
all_ellipses
load_all()
covar.plot(superorder_shapespace,
col = c(rainbow(n.subsets(superorder_shapespace)-1), "grey"),
main = "Average ellipses by super order",
ellipses = mean,
legend = FALSE,
points = FALSE,
cex = 0.5)
covar.plot(superorder_shapespace,
col = c(rainbow(n.subsets(superorder_shapespace)-1), "grey"),
main = "Average ellipses by super order",
ellipses = mean,
legend = FALSE,
points = FALSE,
cex = 0.5, fun.VCV = TRUE)
covar.plot(superorder_shapespace,
col = c(rainbow(n.subsets(superorder_shapespace)-1), "grey"),
main = "Average ellipses by super order",
ellipses = mean,
legend = FALSE,
points = FALSE,
cex = 0.5)
covar.plot(superorder_shapespace,
col = c(rainbow(n.subsets(superorder_shapespace)-1), "grey"),
main = "Average ellipses by super order",
ellipses = mean,
legend = FALSE,
points = FALSE,
cex = 0.5, fun.VCV = FALSE)
covar.plot(superorder_shapespace,
col = c(rainbow(n.subsets(superorder_shapespace)-1), "grey"),
main = "Average ellipses by super order",
ellipses = mean,
legend = FALSE,
points = FALSE,
cex = 0.5, fun.VCV = TRUE)
covar.plot(superorder_shapespace,
col = c(rainbow(n.subsets(superorder_shapespace)-1), "grey"),
main = "Average ellipses by super order",
ellipses = mean,
legend = FALSE,
points = FALSE,
cex = 0.5, fun.VCV = FALSE)
n = 1000
data          = shapespace
posteriors    = shapespace_allbirds_lvl_superorder_order
group         = MCMCglmm.levels(shapespace_allbirds_lvl_superorder_order)[c(super_lvl, phylo_lvl)],
setwd("/home/tguillerme/Projects/elaboration_exploration_bird_beaks/Analysis")
## Load the data
# load(file = "../Data/Processed/shapespace_allbirds_lvl_superorder_order.rda")
# ## Select the data
# shapespace <- shapespace_allbirds_lvl_superorder_order[[1]]$space
# tree <- shapespace_allbirds_lvl_superorder_order[[1]]$consensus_tree
# ## Clean garbage
# rm(shapespace_allbirds_lvl_superorder_order)
# ## Load the covar
# load(file = "../Data/Processed/shapespace_allbirds_lvl_superorder_order.MCMCglmm")
# shapespace_allbirds_lvl_superorder_order <- shapespace_allbirds_lvl_superorder_order[[1]]
# ## Get the levels
# phylo_lvl <- which(MCMCglmm.levels(shapespace_allbirds_lvl_superorder_order) == "animal")
# super_lvl <- grep("level1_", MCMCglmm.levels(shapespace_allbirds_lvl_superorder_order))
# order_lvl <- grep("level2_", MCMCglmm.levels(shapespace_allbirds_lvl_superorder_order))
## Load the data
load(file = "../Data/Processed/shapespace_allbirds_lvl_superorder_order.rda")
## Select the data
shapespace <- shapespace_allbirds_lvl_superorder_order[[1]]$space
tree <- shapespace_allbirds_lvl_superorder_order[[1]]$consensus_tree
## Clean garbage
rm(shapespace_allbirds_lvl_superorder_order)
## Load the covar
load(file = "../Data/Processed/shapespace_allbirds_lvl_superorder_order.MCMCglmm")
shapespace_allbirds_lvl_superorder_order <- shapespace_allbirds_lvl_superorder_order[[1]]
## Get the levels
phylo_lvl <- which(MCMCglmm.levels(shapespace_allbirds_lvl_superorder_order) == "animal")
super_lvl <- grep("level1_", MCMCglmm.levels(shapespace_allbirds_lvl_superorder_order))
order_lvl <- grep("level2_", MCMCglmm.levels(shapespace_allbirds_lvl_superorder_order))
n = 10
data          = shapespace
posteriors    = shapespace_allbirds_lvl_superorder_order
group         = MCMCglmm.levels(shapespace_allbirds_lvl_superorder_order)[c(super_lvl, phylo_lvl)]
match_call <- match.call()
data_class <- check.class(data, c("data.frame", "matrix"))
if(data_class == "data.frame") {
## Remove potential non-numeric columns
col_classes <- sapply(1:ncol(data), function(col, dat) class(data[,col]), dat = data)
numerics <- (col_classes %in% c("numeric", "integer"))
## Check for non-numerics
if(!any(numerics)) {
stop.call(msg = " does not contain any column with numeric or integer values.", call = match_call)
}
## Clean the data
cleaned_data <- as.matrix(data[,numerics])
## Is there any classification column?
classifier <- col_classes[!numerics] %in% "factor"
if(any(classifier)) {
group_classifier <- data[,which(!numerics)[which(classifier)], drop = FALSE]
}
}
## Checking the posteriors
check.class(posteriors, "MCMCglmm")
## Check which dimensions where used
dimensions <- match(MCMCglmm.traits(posteriors), colnames(cleaned_data))
## Extracting the residuals and randoms
posterior_levels <- MCMCglmm.levels(posteriors)
extracted_group <- lapply(posterior_terms, get.one.group, group_classifier, elements = rownames(cleaned_data))
posterior_terms
posterior_levels <- MCMCglmm.levels(posteriors)
posterior_terms <- lapply(posterior_levels, split.term.name)
posterior_terms
extracted_group <- lapply(posterior_terms, get.one.group, group_classifier, elements = rownames(cleaned_data))
names(extracted_group) <- posterior_levels
group
if(is.null(names(group))) {
stop.call(msg = "The group argument must be a named vector.", call = "")
} else {
if(!any(is.na(selected_groups <- match(group, posterior_levels)))) {
## Select only the specific groups
subsets <- extracted_group[selected_groups]
} else {
## Empty groups
nas <- which(is.na(selected_groups))
stop.call(msg = paste0("The following group", ifelse(length(nas) == 1, "", "s"), " cannot be found in the posteriors: ", paste0(group[nas], collapse = ", "), ".\nCheck MCMCglmm(posteriors) for the available group names."), call = "")
}
}
covar_matrices <- MCMCglmm.covars(posteriors)[selected_groups]
covar_matrices
rename.groups = c(levels(shapespace$level1)[-1], "phylogeny")
if(length(rename.groups) != length(subsets)) {
stop.call(msg = paste0("The rename.groups argument must the same length as group argument (", length(selected_groups), ")."), call = "")
}
names(subsets) <- names(covar_matrices) <- rename.groups
covvar_matrices[[1]][[1]]
covar_matrices[[1]][[1]]
covar_matrices[[2]][[1]]
covar_matrices[[3]][[1]]
covar_matrices[[4]][[1]]
covar_matrices[[45][[1]]
covar_matrices[[5][[1]]
covar_matrices[[5]][[1]]
refresh.dispRity()
